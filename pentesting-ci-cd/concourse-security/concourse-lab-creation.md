# Concourse Laborerstellung

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys senden.

</details>

## Testumgebung

### Ausf√ºhren von Concourse

#### Mit Docker-Compose

Diese Docker-Compose-Datei vereinfacht die Installation, um einige Tests mit Concourse durchzuf√ºhren:
```bash
wget https://raw.githubusercontent.com/starkandwayne/concourse-tutorial/master/docker-compose.yml
docker-compose up -d
```
Du kannst das Befehlszeilentool `fly` f√ºr dein Betriebssystem von der Website unter `127.0.0.1:8080` herunterladen.

#### Mit Kubernetes (Empfohlen)

Du kannst Concourse einfach in **Kubernetes** (zum Beispiel in **minikube**) mithilfe des Helm-Charts bereitstellen: [**concourse-chart**](https://github.com/concourse/concourse-chart).
```bash
brew install helm
helm repo add concourse https://concourse-charts.storage.googleapis.com/
helm install concourse-release concourse/concourse
# concourse-release will be the prefix name for the concourse elements in k8s
# After the installation you will find the indications to connect to it in the console

# If you need to delete it
helm delete concourse-release
```
Nachdem Sie die Concourse-Umgebung generiert haben, k√∂nnen Sie ein Geheimnis generieren und dem SA, der in Concourse Web l√§uft, Zugriff auf K8s-Secrets geben:
```yaml
echo 'apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: read-secrets
rules:
- apiGroups: [""]
resources: ["secrets"]
verbs: ["get"]

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
name: read-secrets-concourse
roleRef:
apiGroup: rbac.authorization.k8s.io
kind: ClusterRole
name: read-secrets
subjects:
- kind: ServiceAccount
name: concourse-release-web
namespace: default

---

apiVersion: v1
kind: Secret
metadata:
name: super
namespace: concourse-release-main
type: Opaque
data:
secret: MWYyZDFlMmU2N2Rm

' | kubectl apply -f -
```
### Erstellen Sie eine Pipeline

Eine Pipeline besteht aus einer Liste von [Jobs](https://concourse-ci.org/jobs.html), die eine geordnete Liste von [Schritten](https://concourse-ci.org/steps.html) enthalten.

### Schritte

Es k√∂nnen verschiedene Arten von Schritten verwendet werden:

* Der [**`task` Schritt**](https://concourse-ci.org/task-step.html) f√ºhrt eine [Aufgabe](https://concourse-ci.org/tasks.html) aus.
* Der [`get` Schritt](https://concourse-ci.org/get-step.html) ruft eine [Ressource](https://concourse-ci.org/resources.html) ab.
* Der [`put` Schritt](https://concourse-ci.org/put-step.html) aktualisiert eine [Ressource](https://concourse-ci.org/resources.html).
* Der [`set_pipeline` Schritt](https://concourse-ci.org/set-pipeline-step.html) konfiguriert eine [Pipeline](https://concourse-ci.org/pipelines.html).
* Der [`load_var` Schritt](https://concourse-ci.org/load-var-step.html) l√§dt einen Wert in eine [lokale Variable](https://concourse-ci.org/vars.html#local-vars).
* Der [`in_parallel` Schritt](https://concourse-ci.org/in-parallel-step.html) f√ºhrt Schritte parallel aus.
* Der [`do` Schritt](https://concourse-ci.org/do-step.html) f√ºhrt Schritte in Sequenz aus.
* Der [`across` Schrittmacher](https://concourse-ci.org/across-step.html#schema.across) f√ºhrt einen Schritt mehrmals aus; einmal f√ºr jede Kombination von Variablenwerten.
* Der [`try` Schritt](https://concourse-ci.org/try-step.html) versucht, einen Schritt auszuf√ºhren und hat Erfolg, auch wenn der Schritt fehlschl√§gt.

Jeder [Schritt](https://concourse-ci.org/steps.html) in einem [Jobplan](https://concourse-ci.org/jobs.html#schema.job.plan) wird in seinem **eigenen Container** ausgef√ºhrt. Sie k√∂nnen alles ausf√ºhren, was Sie m√∂chten, innerhalb des Containers _(z. B. meine Tests ausf√ºhren, dieses Bash-Skript ausf√ºhren, dieses Image erstellen usw.)_. Wenn Sie also einen Job mit f√ºnf Schritten haben, erstellt Concourse f√ºnf Container, einen f√ºr jeden Schritt.

Daher ist es m√∂glich, den Typ des Containers anzugeben, in dem jeder Schritt ausgef√ºhrt werden soll.

### Einfaches Pipeline-Beispiel
```yaml
jobs:
- name: simple
plan:
- task: simple-task
privileged: true
config:
# Tells Concourse which type of worker this task should run on
platform: linux
image_resource:
type: registry-image
source:
repository: busybox # images are pulled from docker hub by default
run:
path: sh
args:
- -cx
- |
sleep 1000
echo "$SUPER_SECRET"
params:
SUPER_SECRET: ((super.secret))
```

```bash
fly -t tutorial set-pipeline -p pipe-name -c hello-world.yml
# pipelines are paused when first created
fly -t tutorial unpause-pipeline -p pipe-name
# trigger the job and watch it run to completion
fly -t tutorial trigger-job --job pipe-name/simple --watch
# From another console
fly -t tutorial intercept --job pipe-name/simple
```
√úberpr√ºfen Sie **127.0.0.1:8080**, um den Pipeline-Fluss zu sehen.

### Bash-Skript mit Ein- und Ausgabepipeline

Es ist m√∂glich, **die Ergebnisse einer Aufgabe in einer Datei zu speichern** und anzugeben, dass es sich um eine Ausgabe handelt, und dann den Eingang der n√§chsten Aufgabe als Ausgabe der vorherigen Aufgabe anzugeben. Was Concourse tut, ist, **das Verzeichnis der vorherigen Aufgabe in der neuen Aufgabe einzuh√§ngen, wo Sie auf die von der vorherigen Aufgabe erstellten Dateien zugreifen k√∂nnen**.

### Ausl√∂ser

Sie m√ºssen die Jobs nicht jedes Mal manuell ausl√∂sen, wenn Sie sie ausf√ºhren m√ºssen, Sie k√∂nnen sie auch programmieren, um jedes Mal ausgef√ºhrt zu werden:

* Eine gewisse Zeit vergeht: [Zeit-Ressource](https://github.com/concourse/time-resource/)
* Bei neuen Commits im Hauptzweig: [Git-Ressource](https://github.com/concourse/git-resource)
* Neue PRs: [Github-PR-Ressource](https://github.com/telia-oss/github-pr-resource)
* Das neueste Abbild Ihrer App abrufen oder pushen: [Registry-Abbild-Ressource](https://github.com/concourse/registry-image-resource/)

√úberpr√ºfen Sie ein YAML-Pipeline-Beispiel, das bei neuen Commits im Master ausgel√∂st wird unter [https://concourse-ci.org/tutorial-resources.html](https://concourse-ci.org/tutorial-resources.html)
