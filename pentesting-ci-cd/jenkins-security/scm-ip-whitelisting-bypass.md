# Bypass de la Lista Blanca de IP de SCM

<details>

<summary><strong>춰Apoya a HackTricks y obt칠n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **칰ltima versi칩n de PEASS o descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop).
* Obt칠n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

Esta p치gina fue copiada de [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Introducci칩n

Muchas organizaciones combinan sistemas de gesti칩n de control de origen (SCM) basados en SaaS (como GitHub o GitLab) con una soluci칩n de CI interna y autohospedada (por ejemplo, Jenkins, TeamCity), lo que permite que estos sistemas de CI reciban eventos de webhook de los proveedores de control de origen de SaaS, con el simple prop칩sito de activar trabajos de canalizaci칩n.

Por lo tanto, las organizaciones incluyen en la lista blanca los rangos de IP del SCM que les permiten llegar al sistema de CI interno con webhooks. Sin embargo, hay que tener en cuenta que **cualquiera** puede crear una cuenta en GitHub o GitLab y hacer que **active un webhook** que podr칤a enviar una solicitud a ese sistema de CI interno.

Adem치s, hay que tener en cuenta que si bien se abri칩 el rango de IP del servicio de webhook del proveedor de SCM en el firewall de la organizaci칩n para **permitir que las solicitudes de webhook activen las canalizaciones**, esto no significa que las solicitudes de webhook no puedan dirigirse a otros puntos finales de CI, adem치s de los que escuchan regularmente los eventos de webhook. Podemos intentar acceder a estos puntos finales para **ver datos valiosos como usuarios**, **canalizaciones**, **salida de consola** de los trabajos de canalizaci칩n, o si tenemos la suerte de encontrar una instancia que otorgue privilegios de administrador a usuarios no autenticados (s칤, sucede), podemos acceder a las **secciones de configuraciones y credenciales**.

### Escenario

Imagina un servicio de Jenkins que solo **permite** que las IP de **GitHub** y **GitLab** lo alcancen **externamente**.

En este escenario, un atacante activar치 webhooks arbitrarios en GitHub y GitLab para iniciar sesi칩n dentro de Jenkins y extraer informaci칩n.

### Limitaciones comunes de los webhooks

* **Solo solicitudes POST**: Los webhooks generalmente solo te permiten enviar solicitudes POST, sin embargo, algunos **puntos finales** con informaci칩n **interesante** deben ser accedidos mediante solicitudes GET.
* Si la respuesta del POST es **redirigida**, puede seguirla.
* Algunos CI (Jenkins) permiten tener un **par치metro GET que indica d칩nde redirigir al cliente** una vez que haya logrado iniciar sesi칩n, puedes usar esto para redirigirlo a una p치gina espec칤fica con un GET.
* **No se puede controlar el cuerpo de la solicitud POST**: Si necesitas enviar datos espec칤ficos en el cuerpo del POST, no podr치s hacerlo.
* **Tokens CSRF**: Si el punto final interesante espera tokens CSRF, no podr치s extraerlos ni proporcionarlos.

## Webhooks de GitHub

### Abuso del inicio de sesi칩n de Jenkins

El inicio de sesi칩n requiere enviar una **solicitud POST**. Elegir el punto final de inicio de sesi칩n resuelve el desaf칤o de tener tokens CSRF, ya que esta solicitud espec칤fica no lo requiere. Pero a칰n enfrentamos el otro desaf칤o, ya que nuestras habilidades para **modificar el cuerpo de la solicitud siguen siendo limitadas**.

Una solicitud de inicio de sesi칩n de Jenkins se ve de la siguiente manera:
```
POST /j_acegi_security_check HTTP/1.1
Host: jenkins.example-domain.com
[...]

j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in
```
Necesitamos **enviar las credenciales que desciframos de alguna manera**.\
Afortunadamente, el punto de acceso de inicio de sesi칩n de Jenkins **acepta** una solicitud POST con los **campos enviados como par치metros de consulta**:
```
POST /j_acegi_security_check?j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in HTTP/1.1
Host: jenkins.example-domain.com
[...]

[webhook json in body of request]
```
Entonces, 쯖칩mo podemos hacer que funcione? Podemos **crear un nuevo webhook en GitHub**, estableciendo la **URL de solicitud de inicio de sesi칩n de Jenkins como la URL del payload**. Luego, podemos crear una automatizaci칩n utilizando la API de GitHub para **forzar la contrase침a de la cuenta de usuario**, modificando el campo de contrase침a, activando el webhook e inspeccionando la respuesta en el registro de eventos del webhook del repositorio.
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=therealpassword&from=%2F&Submit=Sign+in
```
<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

Disparamos el webhook y vemos los resultados. Todos los proveedores de SCM muestran la solicitud HTTP y la respuesta enviada a trav칠s del webhook en su interfaz de usuario.\
Si el intento de inicio de sesi칩n falla, somos redirigidos a la p치gina de error de inicio de sesi칩n.

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

Pero si el **inicio de sesi칩n es exitoso**, somos redirigidos a la p치gina principal de Jenkins y se establece una **cookie de sesi칩n**.

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

Por lo tanto, podemos **forzar las credenciales de Jenkins y obtener una cookie de sesi칩n**.\
Sin embargo, estamos un poco limitados: solo podemos **enviar una solicitud sin estado cada vez** y la **cookie no se puede adjuntar** a nuestra solicitud, ya que no podemos controlar las cabeceras.

Otra opci칩n ser칤a intentar obtener un **token de acceso de Jenkins**, que se puede adjuntar en la URL y utilizar para enviar solicitudes POST a Jenkins sin necesidad de agregar un token CSRF. Esta opci칩n es un poco m치s compleja, ya que requiere que un atacante encuentre de alguna manera un CI autohospedado que solo sea accesible desde los rangos de IP de SCM y tambi칠n obtenga un token de acceso v치lido para ese CI. Por el momento, nos centraremos en escenarios m치s pr치cticos.

## Webhooks de GitLab

### Abuso del inicio de sesi칩n de Jenkins

Intentemos enviar la misma solicitud, pero esta vez a trav칠s de GitLab. Debido a las mismas limitaciones, enviamos la **misma solicitud POST, agregando las credenciales como par치metros de consulta**.

<figure><img src="../../.gitbook/assets/image (2) (2).png" alt=""><figcaption></figcaption></figure>

Disparamos la solicitud, pero a diferencia de GitHub, la respuesta es 200. Como en el 칰ltimo ejemplo, utilizamos el servicio de webhook de **GitLab para forzar las credenciales de un usuario y obtener una cookie de sesi칩n**, pero esta vez, el contenido de la respuesta de Jenkins se transmiti칩 de vuelta a la interfaz de usuario de GitLab, proporcion치ndonos esencialmente el **contenido completo de la p치gina principal de Jenkins**.\
Esto se debe a que **GitLab sigui칩 la redirecci칩n** agregando la **Cookie** a la solicitud:

<figure><img src="../../.gitbook/assets/image (4) (1) (2).png" alt=""><figcaption></figcaption></figure>

Esto significa que podemos:

1. forzar usuarios y descubrir credenciales v치lidas,
2. utilizar las credenciales v치lidas en la p치gina de inicio de sesi칩n para iniciar sesi칩n correctamente,
3. obtener el contenido de la p치gina principal interna de Jenkins.

### Obtenci칩n de datos internos de Jenkins

El inicio de sesi칩n de Jenkins acepta un par치metro de redirecci칩n: "_from_". Originalmente utilizado para **redirigir a los usuarios a la p치gina a la que pretend칤an acceder despu칠s de iniciar sesi칩n**, pero en nuestro caso, es una caracter칤stica que podemos abusar para enviar una solicitud GET adjunta con una cookie de sesi칩n a una p치gina interna de Jenkins de nuestra elecci칩n. Veamos c칩mo:

<figure><img src="../../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

1. Establezca un webhook con la siguiente URL:
```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=secretpass123&from=/job/prod_pipeline/1/consoleText&Submit=Sign+in
```
Se env칤a una solicitud POST a Jenkins y la autenticaci칩n tiene 칠xito.

* Obtenemos una respuesta de redirecci칩n 302, con una cookie de sesi칩n y una redirecci칩n a la p치gina de salida de la consola del trabajo.
* El servicio de webhook de GitLab sigue autom치ticamente la redirecci칩n con una solicitud GET enviada a la p치gina de salida de la consola del trabajo, junto con la cookie de sesi칩n que se agrega a la solicitud:
```
http://jenkins.example-domain.com/job/prod_pipeline/1/consoleText
```
* La salida de la consola del trabajo se env칤a y se presenta en el registro de eventos del webhook de GitLab del atacante.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

Es importante mencionar aqu칤 que Jenkins se puede **configurar para permitir el acceso a componentes internos sin autenticaci칩n**, o de una manera que exija que solo los usuarios autenticados puedan acceder a los componentes internos. 쮺칩mo nos afecta esto?

* Si no hay autenticaci칩n configurada, podemos hacer que el servicio de webhook de **GitLab acceda a cualquier p치gina interna en CI**, capturar la respuesta y presentarla ante nosotros.
* Si se configura la autenticaci칩n, podemos intentar forzar el acceso de un usuario y luego usar las credenciales para acceder a cualquier p치gina interna (como en el punto anterior).

<details>

<summary><strong>춰Apoya a HackTricks y obt칠n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **칰ltima versi칩n de PEASS o descargar HackTricks en PDF**, 춰consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
