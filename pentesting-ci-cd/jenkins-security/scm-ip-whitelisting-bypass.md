# Bypass de lista blanca de IP de SCM

<details>

<summary><strong>隆Apoya a HackTricks y obt茅n beneficios!</strong></summary>

* Si deseas ver a tu **empresa anunciada en HackTricks** o si deseas acceder a la **煤ltima versi贸n de PEASS o descargar HackTricks en PDF**, 隆consulta los [**PLANES DE SUSCRIPCIN**](https://github.com/sponsors/carlospolop)!
* Obt茅n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci贸n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos.
* **nete al**  [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s铆gueme** en **Twitter**  [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Comparte tus trucos de hacking enviando PR a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Esta p谩gina fue copiada de [https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/](https://www.cidersecurity.io/blog/research/how-we-abused-repository-webhooks-to-access-internal-ci-systems-at-scale/)

## Introducci贸n

Muchas organizaciones combinan sistemas de gesti贸n de control de origen (SCM) basados en SaaS (como GitHub o GitLab) con una soluci贸n de CI interna autohospedada (por ejemplo, Jenkins, TeamCity) que permite a estos sistemas de CI recibir eventos de webhook de los proveedores de control de origen de SaaS, con el simple prop贸sito de activar trabajos de canalizaci贸n.

Por lo tanto, las organizaciones incluyen en la lista blanca los rangos de IP de SCM que les permiten llegar al sistema de CI interno con webhooks. Sin embargo, tenga en cuenta c贸mo **cualquiera** puede crear una cuenta en GitHub o Gitlab y hacer que **active un webhook** que podr铆a enviar una solicitud a ese sistema de CI **interno**.

Adem谩s, tenga en cuenta que aunque se abri贸 el rango de IP del servicio de webhook del proveedor de SCM en el firewall de la organizaci贸n para **permitir que las solicitudes de webhook activen las canalizaciones**, esto **no significa** que las solicitudes de webhook no puedan ser **dirigidas hacia otros puntos finales de CI**, adem谩s de los que escuchan regularmente los eventos de webhook. Podemos intentar acceder a estos puntos finales para **ver datos valiosos como usuarios**, **canalizaciones**, **salida de consola** de trabajos de canalizaci贸n, o si tenemos la suerte de caer en una instancia que otorga privilegios de administrador a usuarios no autenticados (s铆, sucede), podemos acceder a las secciones de **configuraciones y credenciales**.

### Escenario

Imagina un servicio **Jenkins** que solo **permite que las IPs de GitHub y GitLab** lo alcancen **externamente**.

En este escenario, un atacante activar谩 webhooks arbitrarios en GitHub y GitLab para iniciar sesi贸n dentro de Jenkins y extraer informaci贸n.

### Limitaciones comunes de los webhooks

* **Solo solicitudes POST**: los webhooks generalmente solo le permiten enviar solicitudes POST, sin embargo, algunos **puntos finales** con informaci贸n **interesante** deben ser accedidos a trav茅s de solicitudes **GET**.
  * Si la publicaci贸n es **respondida con una redirecci贸n**, puede seguirla.
  * Algunos CIs (Jenkins) permiten tener un **par谩metro GET que indica d贸nde redirigir al cliente** una vez que logr贸 iniciar sesi贸n, puede usar esto para redirigirlo a una p谩gina espec铆fica con un GET.
* **No se puede controlar el cuerpo de la solicitud POST**: si desea enviar datos espec铆ficos en el cuerpo POST, no puede hacerlo.
* **Tokens CSRF**: si el punto final interesante espera tokens CSRF, no podr谩 extraerlos y proporcionarlos.

## Webhooks de GitHub

### Abuso de inicio de sesi贸n de Jenkins

El inicio de sesi贸n requiere el env铆o de una **solicitud POST**. Elegir el punto final de inicio de sesi贸n resuelve el desaf铆o de mantener los tokens CSRF, ya que esta solicitud espec铆fica no lo requiere. Pero todav铆a enfrentamos el otro desaf铆o, ya que nuestras habilidades para **modificar el cuerpo de la solicitud siguen siendo limitadas**.

Una solicitud de inicio de sesi贸n de Jenkins se ve as铆:

```
POST /j_acegi_security_check HTTP/1.1
Host: jenkins.example-domain.com
[...]

j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in
```

Necesitamos **enviar las credenciales que fuerza bruta de alguna manera**.\
Afortunadamente, el punto final de inicio de sesi贸n de Jenkins **acepta una solicitud POST con los campos enviados como par谩metros de consulta**:

```
POST /j_acegi_security_check?j_username=admin&j_password=mypass123&from=%2F&Submit=Sign+in HTTP/1.1
Host: jenkins.example-domain.com
[...]

[webhook json en el cuerpo de la solicitud]
```

Entonces, 驴c贸mo podemos hacer que funcione? Podemos **crear un nuevo webhook en GitHub**, estableciendo la **URL de solicitud de inicio de sesi贸n de Jenkins como la URL de carga 煤til**. Luego podemos crear una automatizaci贸n usando la API de GitHub para **fuerza bruta de la contrase帽a de la cuenta de usuario**, modificando el campo de contrase帽a, activando el webhook e inspeccionando la respuesta en el registro de eventos de webhook del repositorio.

```
http://jenkins.example-domain.com/j_acegi_security_check?j_username=admin&j_password=therealpassword&from=%2F&Submit=Sign+in
```

<figure><img src="../../.gitbook/assets/image (7) (1) (1).png" alt=""><figcaption></figcaption></figure>

Disparamos el webhook y vemos los resultados. Todos los proveedores de