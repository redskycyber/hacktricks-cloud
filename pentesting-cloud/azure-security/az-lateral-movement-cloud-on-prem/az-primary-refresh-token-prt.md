# Az - Primary Refresh Token (PRT)

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Post copiado de** [**https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/**](https://dirkjanm.io/abusing-azure-ad-sso-with-the-primary-refresh-token/) aunque otro post que explica lo mismo se puede encontrar en [**https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30**](https://posts.specterops.io/requesting-azure-ad-request-tokens-on-azure-ad-joined-machines-for-browser-sso-2b0409caad30)

## Informaci칩n B치sica

Un **Primary Refresh Token** puede compararse con un **Ticket Granting Ticket (TGT) persistente a largo plazo** en Active Directory. Es un token que permite a los usuarios **iniciar sesi칩n una vez** en su dispositivo conectado a Azure AD y luego **iniciar sesi칩n autom치ticamente en recursos conectados a Azure AD**.&#x20;

Un Primary Refresh Token puede usarse para **autenticarse en cualquier aplicaci칩n**. Por eso Microsoft ha aplicado protecciones adicionales a este token. La protecci칩n m치s importante es que en dispositivos con un **TPM**, las claves criptogr치ficas se almacenan dentro de ese TPM, lo que hace que bajo la mayor칤a de las circunstancias **no sea posible recuperar las claves reales desde el propio SO**. Hay documentaci칩n bastante extensa sobre el Primary Refresh Token [disponible aqu칤](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token). Te sugiero que leas el art칤culo completo ya que tiene bastantes detalles t칠cnicos, pero para el prop칩sito de este post, aqu칤 est치n los puntos m치s importantes:

* Si hay un TPM presente, las claves requeridas para solicitar o usar el PRT est치n **protegidas por el TPM** y no pueden ser extra칤das bajo circunstancias normales.
* **Un PRT puede actualizarse con una afirmaci칩n de MFA cuando se usa MFA en el dispositivo**, lo que permite SSO a recursos que requieren MFA despu칠s.
* El **PRT contiene el ID del dispositivo** y por lo tanto est치 **vinculado al objeto del dispositivo** en Azure AD, esto puede usarse para hacer coincidir los tokens con pol칤ticas de Acceso Condicional que requieren dispositivos compatibles.
* El **PRT se invalida cuando el dispositivo se deshabilita** en Azure AD y no puede usarse m치s para solicitar nuevos tokens en ese punto.
* Durante el SSO, el **PRT se usa para solicitar tokens de actualizaci칩n y acceso**. Los tokens de actualizaci칩n son mantenidos por el **plug-in de CloudAP y cifrados con DPAPI**, los tokens de acceso se pasan a la aplicaci칩n solicitante.

Algo a tener en cuenta es que varias de estas protecciones usan el **TPM**, que es **opcional** en una uni칩n h칤brida. Si no hay TPM, las **claves se almacenan en software**. En este escenario es posible **recuperarlas** del SO con los privilegios adecuados. Otro punto a investigar m치s a fondo es la **clave de sesi칩n** que se menciona varias veces a lo largo de la [documentaci칩n de PRT](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token), que se descifra usando la clave de transporte y luego se almacena en el TPM. A menos que este sea un paso 칰nico que ocurre enteramente dentro del TPM, esto podr칤a proporcionar una **breve ventana en la que la clave de sesi칩n est치 desencriptada en memoria**, momento en el cual podr칤a ser interceptada por un atacante ya en el sistema. El n칰mero de oportunidades para interceptar esta clave podr칤a aumentar si la clave de sesi칩n se renueva o cambia en ciertos momentos.

## Single Sign On <a href="#single-sign-on" id="single-sign-on"></a>

Como se describe en la documentaci칩n de PRT, el PRT permite **single sign-on a recursos de Azure AD**. En Edge esto se hace de forma nativa (como se esperaba), pero **Chrome no lo hace de forma nativa**, utiliza una extensi칩n de Chrome de Microsoft para habilitar esta capacidad.

### PRT por la Extensi칩n de Chrome <a href="#interaction-with-the-prt-from-chrome" id="interaction-with-the-prt-from-chrome"></a>

Empecemos con la [extensi칩n de Chrome](https://chrome.google.com/webstore/detail/windows-10-accounts/ppnbnpeolgkicgegkbkbjmhlideopiji?hl=en) que Microsoft proporciona para SSO en Windows 10. Una vez instalada la extensi칩n y cuando navegas a una aplicaci칩n conectada a Azure AD como office.com, el proceso de inicio de sesi칩n no solicita nada, sino que contin칰a directamente a tu cuenta. Dado que las extensiones de Chrome est치n escritas en JavaScript, puedes cargar el c칩digo en tu editor favorito. Para referencia, las extensiones se guardan en `C:\Users\youruser\AppData\Local\Google\Chrome\User Data\Default\Extensions`. En su manifiesto, se declara el permiso `nativeMessaging`, con el script `background.js` usando efectivamente la funci칩n `sendNativeMessage` al espacio de nombres `com.microsoft.browsercore`.

<figure><img src="../../../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

Seg칰n la [documentaci칩n](https://developer.chrome.com/extensions/nativeMessaging), esto requiere una clave de registro en `HKCU\Software\Google\Chrome\NativeMessagingHosts`, que de hecho est치 presente para el nombre `com.microsoft.browsercore` que vimos en la extensi칩n. Nos se침ala a `C:\Windows\BrowserCore\manifest.json`, que contiene una referencia a qu칠 extensiones est치n permitidas para llamar al binario `BrowserCore.exe`. Nota que `C:\Windows\BrowserCore` es la ubicaci칩n en versiones recientes de Windows 10, en versiones anteriores se encuentra en `C:\Program Files\Windows Security\BrowserCore`.

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

Y el `manifest.json`:
```json
{
"name": "com.microsoft.browsercore",
"description": "BrowserCore",
"path": "BrowserCore.exe",
"type": "stdio",
"allowed_origins": [
"chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/",
"chrome-extension://ndjpnladcallmjemlbaebfadecfhkepb/"
]
}
```
Para ver qu칠 se env칤a a este proceso, inici칠 sesi칩n un par de veces mientras Process Monitor de Sysinternals estaba en ejecuci칩n, lo que captur칩 la l칤nea de comandos del proceso:

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>
```bash
C:\Windows\system32\cmd.exe /d /c "C:\Windows\BrowserCore\BrowserCore.exe" chrome-extension://ppnbnpeolgkicgegkbkbjmhlideopiji/ --parent-window=0 < \\.\pipe\chrome.nativeMessaging.in.720bfd13d22dec77 > \\.\pipe\chrome.nativeMessaging.out.720bfd13d22dec77
```
Como vemos, Chrome est치 utilizando tuber칤as con nombre para alimentar informaci칩n a `stdin` y otra tuber칤a para leer `stdout`. Pens칠 que la mejor manera de ver qu칠 se env칤a a trav칠s de estas tuber칤as con nombre era intentar interceptar o monitorear el tr치fico. No pude encontrar una herramienta de c칩digo abierto que permitiera f치cilmente el monitoreo de tuber칤as con nombre, as칤 que tuve que optar por el Monitor de Tubos comercial de [IO Ninja](https://ioninja.com/plugins/pipe-monitor.html) (ofrecen una versi칩n de evaluaci칩n que utilic칠 para esto). Esto funcion칩 bastante bien y despu칠s de borrar las cookies y volver a iniciar sesi칩n en Office.com, vi aparecer la comunicaci칩n de la tuber칤a con nombre:

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

Como ya se mencion칩 en la documentaci칩n de `nativeMessaging`, los primeros bytes son la longitud total del mensaje y el resto son los datos (en JSON) transferidos al componente nativo. El JSON es el siguiente:
```json
{
"method":"GetCookies",
"uri":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>ANDARD2_0&x-client-ver=6.6.0.0&sso_nonce=AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA",
"sender":"https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&redirect_uri=https%3<cut>oth8XvXy-663HzpYYNgNtUPkF0RwNtvu1WdojjxycLl-zbLOsM_T4s&x-client-SKU=ID_NETSTANDARD2_0&x-client-ver=6.6.0.0"
}
```
Luego recibe una respuesta JSON similar que contiene la cookie del token de actualizaci칩n, que es (como otros tokens en Azure AD) un JSON Web Token (JWT):
```json
{
"response":[
{
"name":"x-ms-RefreshTokenCredential",
"data":"eyJhbGciOiJIUzI1NiIsICJjdHgiOiJxSDBtSzc0VE92Z1Rz<cut>NjcjkwZXlhaDV5QUEifQ.Er2I_1unszMORwB5K0ZESc-HD1uZW9dQlJd8MulOQi0",
"p3pHeader":"CP=\"CAO DSP COR ADMa DEV CONo TELo CUR PSA PSD TAI IVDo OUR SAMi BUS DEM NAV STA UNI COM INT PHY ONL FIN PUR LOCi CNT\"",
"flags":8256
}
]
}
```
Al decodificar este JWT, vemos que contiene el PRT en s칤 y un nonce, que vincula la cookie al inicio de sesi칩n actual que se est치 realizando:
```json
{
"refresh_token": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAZ18nQkT-eD6Hqt7sf5QY0iWPSssZOto]<cut>VhcDew7XCHAVmCutIod8bae4YFj8o2OOEl6JX-HIC9ofOG-1IOyJegQBPce1WS-ckcO1gIOpKy-m-JY8VN8xY93kmj8GBKiT8IAA",
"is_primary": "true",
"request_nonce": "AQABAAAAAAAGV_bv21oQQ4ROqh0_1-tAPrlbf_TrEVJRMW2Cr7cJvYKDh2XsByis2eCF9iBHNqJJVzYR_boX8VfBpZpeIV078IE4QY0pIBtCcr90eyah5yAA"
}
```
Mientras que la mayor칤a de los JWT en Azure est치n firmados con una clave que es gestionada por Azure AD, en este caso el JWT que contiene el **PRT est치 firmado por la clave de sesi칩n que est치 en el TPM del dispositivo**. El PRT en s칤 es un **blob cifrado** y no puede ser descifrado por ninguna clave en el dispositivo, porque esto contiene las afirmaciones de identidad que son gestionadas por Azure AD.

### El proceso de inicio de sesi칩n

El dominio principal donde ocurre toda la autenticaci칩n importante en Azure AD es `login.microsoftonline.com`. Este es el dominio donde se **env칤an las credenciales y se solicitan y renuevan los tokens**.

Esta solicitud a칰n no contiene la cookie PRT, pero dado que utiliza el agente de usuario de Chrome, nos recibe una p치gina de "Redireccionamiento" que contiene c칩digo JavaScript para interactuar con la extensi칩n de Chrome.

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

Cuando observamos la URL que se env칤a desde la extensi칩n al componente nativo, esta URL consiste en la URL que est치bamos visitando, m치s el par치metro **`sso_nonce`** (que se pasa a la extensi칩n a trav칠s de JavaScript en la p치gina). Este nonce se **refleja de vuelta en el token**, vinculando esencialmente el JWT firmado con PRT a este inicio de sesi칩n espec칤fico. No estoy seguro de c칩mo la p치gina de inicio de sesi칩n maneja el estado y d칩nde, si es que lo hace, almacena este nonce, pero no aceptar치 un JWT con un nonce diferente.

<figure><img src="../../../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

### Deshacerse del nonce <a href="#getting-rid-of-the-nonce" id="getting-rid-of-the-nonce"></a>

Ahora que descubrimos c칩mo podemos interactuar con `BrowserCore.exe`, escrib칤 una peque침a herramienta en Python que inicia el proceso y escribe el JSON directamente en su `stdin` y `stdout`. Luego lee la respuesta y la decodifica, permiti칠ndonos solicitar cookies PRT para una URL arbitraria.
```python
import subprocess
import struct
import json
process = subprocess.Popen([r"C:\Windows\BrowserCore\browsercore.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
inv = {}
inv['method'] = 'GetCookies'
inv['sender'] = "https://login.microsoftonline.com"
inv['uri'] = 'https://login.microsoftonline.com/common/oauth2/authorize?client_id=4345a7b9-9a63-4910-a426-35363201d503&response_mode=form_post&response_type=code+id_token&scope=openid+profile&state=OpenIdConnect.AuthenticationProperties%3dhiUgyLP6LnqNTRRyNpT0W1WGjOO_9hNAUjayiM5WJb0wwdAK0fwF635Dw5XStDKDP9EV_AeGIuWqN_rtyrl8m9t6pUGiXHhG3GMSSpW-AWcpfxW9D6bmWECYrN36_9zw&nonce=636957966885511040.YmI2MDIxNmItZDA0Yy00MjZlLThlYjAtYjNkNDM5NzkwMjVlYThhYTMyZGYtMGVlZi00Mjk4LWE2ODktY2Q2ZjllODU4ZjNk&redirect_uri=https%3a%2f%2fwww.office.com%2f&ui_locales=nl&mkt=nl&client-request-id=d738dfc8-db89-4f27-9522-eb70aa55c2b3&sso_nonce=AQABAAAAAADCoMpjJXrxTq9VG9te-7FX2rBuuPsFpQIW4_wk_IAK5pG2t1EdXLfKDDJotUpwFvQKzd0U_I_IKLw4CEQ5d9uzoWgbWEsY6lt1Tm3Kpw9CfiAA'
text = json.dumps(inv).encode('utf-8')
encoded_length = struct.pack('=I', len(text))
print(process.communicate(input=encoded_length + text)[0])
```
Jugando un poco con esto, not칠 que la mayor칤a de los par치metros en la URL no son necesarios para obtener una cookie PRT v치lida. Por ejemplo, una URL con `https://login.microsoftonline.com/?sso_nonce=aaaaa"` es suficiente para obtener una cookie PRT firmada v치lida con el nonce `aaaaa`.

En mis pruebas, la **cookie PRT expir칩 despu칠s de unos 35 minutos**, despu칠s de lo cual no se pudo utilizar m치s para iniciar sesi칩n. La mayor칤a de los sitios que realizan su propia gesti칩n de sesiones te mantendr치n conectado durante un tiempo, ya que pueden usar el **token de actualizaci칩n** para extender el acceso, pero los sitios que utilizan el flujo impl칤cito de **OAuth2** solo entregan un token de acceso. Este token de acceso **expira despu칠s de una hora**, lo que significa que si usas la cookie PRT para iniciar sesi칩n en un sitio de este tipo, se cerrar치 la sesi칩n despu칠s de una hora. Esto tambi칠n significa que si pierdes el acceso al dispositivo por cualquier motivo, tambi칠n se perder치 el acceso a Azure AD.

### Uso de la cookie PRT con clientes p칰blicos <a href="#using-the-prt-cookie-with-public-clients" id="using-the-prt-cookie-with-public-clients"></a>

Ten칤a curiosidad por saber si podr칤amos usar SSO con otras aplicaciones de Azure AD, como el m칩dulo de PowerShell de Azure. Cuando ejecutamos el cmdlet `Connect-AzureAD`, se abre una ventana emergente que nos pide iniciar sesi칩n, y no se realiza SSO. ~~No estoy seguro de por qu칠 es esto, tal vez no se admite todav칤a~~ Como [se침al칩 @cnotin](https://twitter.com/cnotin/status/1285734903389265922?s=20) SSO s칤 se realiza si se especifica el par치metro `-AccountId`, pero incluso sin 칠l hay una cookie PRT incluida en el encabezado HTTP `x-ms-RefreshTokenCredential`:

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

Sin embargo, **no se realiza SSO, a pesar de que hay una cookie PRT**. Esto es causado por el par치metro `prompt=login`, que fuerza expl칤citamente la aparici칩n del mensaje de inicio de sesi칩n en lugar de iniciar sesi칩n directamente al usuario. No estoy seguro de qu칠 marco utilizan los m칩dulos de PowerShell, pero asumo que est치 relacionado con el marco WAM mencionado en la documentaci칩n (쯘l agente de usuario apunta a Internet Explorer?). Cuando eliminamos el par치metro `prompt` en la solicitud HTTP, obtenemos un c칩digo de autorizaci칩n:

<figure><img src="../../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

Este c칩digo se utiliza en el [flujo de c칩digo de autorizaci칩n OAuth2](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow), y podemos usarlo para **obtener un token de acceso y un token de actualizaci칩n**. Debido a que el m칩dulo de PowerShell de Azure AD es una aplicaci칩n _p칰blica_, no hay ning칰n secreto involucrado en la solicitud del token de acceso y actualizaci칩n utilizando este c칩digo de autorizaci칩n. Esto es as칤 para todas las aplicaciones m칩viles y nativas, ya que no hay forma de almacenar de manera segura dicho secreto, ya que no hay un backend en su lugar y estos clientes hablan directamente con las diversas API. Esto tambi칠n est치 [documentado](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow#request-an-access-token) en la misma p치gina. En este ejemplo estoy usando el m칩dulo de PowerShell de Azure porque tiene bastantes permisos por defecto, pero hay otros. He descrito algunos de estos en mi [charla de BlueHat](https://dirkjanm.io/assets/raw/Im%20in%20your%20cloud%20bluehat-v1.0.pdf) en la diapositiva 24. Tambi칠n puedes **encontrar clientes p칰blicos usando ROADrecon**. Para aplicaciones de primera parte (aplicaciones que existen en el mismo inquilino), esto se muestra como una columna en la vista general. Para aplicaciones que no est치n en tu inquilino, pero que tienen un principal de servicio (como la mayor칤a de las aplicaciones de Office 365), puedes encontrar clientes p칰blicos en la base de datos en la tabla ApplicationRefs:

<figure><img src="../../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

Al enviar el c칩digo de autorizaci칩n obtenido al punto final correcto (`https://login.microsoftonline.com/Common/oauth2/token`) obtenemos tanto un token de acceso como un token de actualizaci칩n. Aunque normalmente el token de actualizaci칩n no se env칤a a la aplicaci칩n sino que est치 protegido por el WAM, al enviar la solicitud nosotros mismos podemos obtener ambos tokens sin problemas:

<figure><img src="../../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure>

Respuesta JSON resultante:

<figure><img src="../../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

## Reclamaciones de tokens e implicaciones <a href="#token-claims-and-implications" id="token-claims-and-implications"></a>

Los tokens de acceso y actualizaci칩n emitidos por este proceso tendr치n las mismas reclamaciones que ten칤a el PRT. Entonces, si se realiz칩 la autenticaci칩n MFA en una aplicaci칩n que utiliza SSO, el **PRT contendr치 la reclamaci칩n MFA** [seg칰n la documentaci칩n](https://docs.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token#when-does-a-prt-get-an-mfa-claim). Esto significa que, en la mayor칤a de los casos, el **token de actualizaci칩n** obtenido de esta manera **incluir치 la reclamaci칩n MFA** y, por lo tanto, satisfar치 las pol칤ticas de Acceso Condicional que requieren MFA. Adem치s, dado que el PRT se emite a un dispositivo unido a Azure AD, los tokens que obtenemos al usar la cookie PRT tambi칠n contienen el ID del dispositivo, lo que los hace satisfacer pol칤ticas que requieren un dispositivo compatible o h칤brido:

<figure><img src="../../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

En resumen, no importa cu치n fuerte sea la protecci칩n de inicio de sesi칩n, una vez que un atacante obtiene ejecuci칩n de c칩digo en una m치quina con capacidades de SSO, pueden **aprovechar ese SSO para adquirir un token que satisface incluso las pol칤ticas de Acceso Condicional m치s estrictas**. De hecho, la m치quina en la que he estado probando esto hasta ahora est치 utilizando un YubiKey con FIDO2 para autenticarse. Sin embargo, despu칠s de obtener el token de actualizaci칩n, un atacante puede acceder a los datos del usuario, como el correo electr칩nico o los archivos de OneDrive, sin estar en posesi칩n del token de seguridad de hardware. Esto ofrece una forma de persistencia ya que el **token de actualizaci칩n ya no est치 vinculado criptogr치ficamente al dispositivo**, y con el ID de aplicaci칩n correcto se puede acceder a la mayor칤a de las API de Office 365, ya que hay varias aplicaciones predeterminadas que tienen permisos completos en esas API. El token de actualizaci칩n es v치lido por 90 d칤as por defecto, pero si lo usas se te emite un nuevo token de actualizaci칩n que tiene una validez extendida. Entonces, una vez que tienes este token, el acceso se puede mantener siempre y cuando actualices el token cada pocas semanas. [Sol칤a haber](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-configurable-token-lifetimes) una opci칩n de configuraci칩n en vista previa que podr칤a limitar la vida 칰til de un token de actualizaci칩n emitido a clientes p칰blicos, pero eso ya no se admite. No estoy seguro de c칩mo la configuraci칩n de la [frecuencia de inicio de sesi칩n](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/howto-conditional-access-session-lifetime) se relaciona con todo esto, pero mi suposici칩n es que usar tal pol칤tica limitar칤a la validez de los tokens de actualizaci칩n. Algunas observaciones m치s interesantes:

* El **PRT dejar치 de funcionar** cuando el **dispositivo** al que pertenece est칠 **deshabilitado** en Azure AD.
* El **token de actualizaci칩n obtenido usando el PRT sigue siendo v치lido incluso si el dispositivo est치 deshabilitado**. La 칰nica excepci칩n es que cuando el dispositivo est치 deshabilitado, **ya no pasar치 las pol칤ticas de Acceso Condicional** que requieren un dispositivo administrado o compatible.
* **Obtener un token de actualizaci칩n** cuenta como un inicio de sesi칩n y se **registra en** el registro de inicio de sesi칩n de Azure AD. **Actualizar** el **token de actualizaci칩n y obtener un token de acceso** con 칠l, sin embargo, **no cuenta como un inicio de sesi칩n** y no se registra en el registro de inicio de sesi칩n.
* Si hay pol칤ticas que involucran una IP espec칤fica como ubicaci칩n de confianza y niegan los inicios de sesi칩n desde fuera de estas, esto a칰n se activar치 cuando se use el token de actualizaci칩n para solicitar un nuevo token de acceso.

<figure><img src="../../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

## Ataque

Consulta c칩mo obtener un token PRT de un dispositivo comprometido y usarlo para acceder a Azure en esta p치gina:

{% content-ref url="pass-the-prt.md" %}
[pass-the-prt.md](pass-the-prt.md)
{% endcontent-ref %}

## [Roadtx](https://github.com/dirkjanm/ROADtools)

Esta herramienta permite realizar varias acciones como registrar una m치quina en Azure AD para obtener un PRT, y usar PRTs (leg칤timos o robados) para acceder a recursos de varias maneras diferentes. Estos no son ataques directos, pero facilita el uso de PRTs para acceder a recursos de diferentes maneras. Encuentra m치s informaci칩n en:

{% content-ref url="az-roadtx-authentication.md" %}
[az-roadtx-authentication.md](az-roadtx-authentication.md)
{% endcontent-ref %}

<details>

<summary><strong>Aprende hacking de AWS desde cero hasta h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
