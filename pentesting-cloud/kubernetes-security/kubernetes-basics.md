# Bases de Kubernetes

## Bases de Kubernetes

<details>

<summary><strong>Soutenez HackTricks et b√©n√©ficiez d'avantages !</strong></summary>

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou si vous souhaitez acc√©der √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection d'exclusivit√©s [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**L'auteur original de cette page est** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lisez son post original** [**ici**](https://sickrov.github.io)**)**

## Architecture et bases

### Que fait Kubernetes ?

* Permet l'ex√©cution de conteneurs dans un moteur de conteneurs.
* La planification permet une mission efficace des conteneurs.
* Garde les conteneurs en vie.
* Permet les communications entre conteneurs.
* Permet les techniques de d√©ploiement.
* G√®re les volumes d'informations.

### Architecture

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: syst√®me d'exploitation avec pod ou des pods.
  * **Pod**: Enveloppe autour d'un conteneur ou de plusieurs conteneurs. Un pod ne doit contenir qu'une seule application (donc g√©n√©ralement, un pod ex√©cute seulement 1 conteneur). Le pod est la fa√ßon dont Kubernetes abstrait la technologie de conteneur en cours d'ex√©cution.
    * **Service**: Chaque pod a 1 **adresse IP interne** de la plage interne du n≈ìud. Cependant, il peut √©galement √™tre expos√© via un service. Le **service a √©galement une adresse IP** et son objectif est de maintenir la communication entre les pods afin que si l'un meurt, le **nouveau remplacement** (avec une adresse IP interne diff√©rente) **sera accessible** expos√© dans la **m√™me adresse IP du service**. Il peut √™tre configur√© en interne ou en externe. Le service agit √©galement comme un **√©quilibreur de charge lorsque 2 pods sont connect√©s** au m√™me service.\
      Lorsqu'un **service** est **cr√©√©**, vous pouvez trouver les points de terminaison de chaque service en ex√©cutant `kubectl get endpoints`
* **Kubelet**: Agent principal du n≈ìud. Le composant qui √©tablit la communication entre le n≈ìud et kubectl, et ne peut ex√©cuter que des pods (via le serveur API). Le kubelet ne g√®re pas les conteneurs qui n'ont pas √©t√© cr√©√©s par Kubernetes.
* **Kube-proxy**: est le service charg√© des communications (services) entre l'apiserver et le n≈ìud. La base est un IPtables pour les n≈ìuds. Les utilisateurs les plus exp√©riment√©s peuvent installer d'autres kube-proxies provenant d'autres fournisseurs.
* **Conteneur Sidecar**: Les conteneurs Sidecar sont les conteneurs qui doivent s'ex√©cuter avec le conteneur principal dans le pod. Ce mod√®le de conteneur √©tend et am√©liore les fonctionnalit√©s des conteneurs actuels sans les modifier. De nos jours, nous savons que nous utilisons la technologie de conteneur pour envelopper toutes les d√©pendances n√©cessaires √† l'ex√©cution de l'application n'importe o√π. Un conteneur ne fait qu'une seule chose et le fait tr√®s bien.
* **Processus principal** :
  * **Serveur API** : C'est la fa√ßon dont les utilisateurs et les pods communiquent avec le processus principal. Seules les demandes authentifi√©es doivent √™tre autoris√©es.
  * **Planificateur** : La planification consiste √† s'assurer que les pods sont associ√©s aux n≈ìuds afin que Kubelet puisse les ex√©cuter. Il a suffisamment d'intelligence pour d√©cider quel n≈ìud a plus de ressources disponibles pour attribuer le nouveau pod. Notez que le planificateur ne d√©marre pas de nouveaux pods, il communique simplement avec le processus Kubelet en cours d'ex√©cution √† l'int√©rieur du n≈ìud, qui lancera le nouveau pod.
  * **Gestionnaire de contr√¥leur Kube** : Il v√©rifie les ressources telles que les ensembles de r√©plicas ou les d√©ploiements pour v√©rifier si, par exemple, le nombre correct de pods ou de n≈ìuds est en cours d'ex√©cution. Dans le cas o√π un pod est manquant, il communiquera avec le planificateur pour en d√©marrer un nouveau. Il contr√¥le la r√©plication, les jetons et les services de compte vers l'API.
  * **etcd** : Stockage de donn√©es, persistant, coh√©rent et distribu√©. C'est la base de donn√©es de Kubernetes et le stockage cl√©-valeur o√π il conserve l'√©tat complet des clusters (chaque changement est enregistr√© ici). Des composants tels que le planificateur ou le gestionnaire de contr√¥leur d√©pendent de cette date pour savoir quels changements ont eu lieu (ressources disponibles des n≈ìuds, nombre de pods en cours d'ex√©cution...)
* **Gestionnaire de contr√¥leur Cloud** : C'est le contr√¥leur sp√©cifique pour les contr√¥les de flux et les applications, c'est-√†-dire : si vous avez des clusters dans AWS ou OpenStack.

Notez qu'il peut y avoir plusieurs n≈ìuds (ex√©cutant plusieurs pods), il peut √©galement y avoir plusieurs processus principaux dont l'acc√®s au serveur API est √©quilibr√© et leur etcd synchronis√©.

**Volumes :**

Lorsqu'un pod cr√©e des donn√©es qui ne doivent pas √™tre perdues lorsque le pod dispara√Æt, elles doivent √™tre stock√©es dans un volume physique. **Kubernetes permet de joindre un volume √† un pod pour persister les donn√©es**. Le volume peut √™tre sur la machine locale ou dans un **stockage distant**. Si vous ex√©cutez des pods sur diff√©rents n≈ìuds physiques, vous devez utiliser un stockage distant pour que tous les pods puissent y acc√©der.

**Autres configurations :**

* **ConfigMap** : Vous pouvez configurer des **URL** pour acc√©der aux services. Le pod obtiendra des donn√©es d'ici pour savoir comment communiquer avec le reste des services (pods). Notez que ce n'est pas l'endroit recommand√© pour enregistrer les informations d'identification !
* **Secret** : C'est l'endroit pour **stocker des donn√©es secr√®tes** comme des mots de passe, des cl√©s API... encod√©es en B64. Le pod pourra acc√©der √† ces donn√©es pour utiliser les informations d'identification requises.
* **D√©ploiements** : C'est l√† que les composants √† ex√©cuter par Kubernetes sont indiqu√©s. Un utilisateur ne travaillera g√©n√©ralement pas directement avec des pods, les pods sont abstraits dans les **ReplicaSets** (nombre de m√™mes pods r√©pliqu√©s), qui sont ex√©cut√©s via des d√©ploiements. Notez que les d√©ploiements sont destin√©s aux applications **sans √©tat**. La configuration minimale pour un d√©ploiement est le nom et l'image √† ex√©cuter.
* **StatefulSet** : Ce composant est sp√©cifiquement destin√© aux applications comme les **bases de donn√©es** qui ont besoin d'**acc√©der au m√™me stockage**.
* **Ingress** : C'est la configuration qui est utilis√©e pour **exposer l'application publiquement avec une URL**. Notez que cela peut √©galement √™tre fait en utilisant des services externes, mais c'est la bonne fa√ßon d'exposer l'application.
  * Si vous impl√©mentez un Ingress, vous devrez cr√©er des **contr√¥leurs Ingress**. Le contr√¥leur Ingress est un **pod** qui sera le point de terminaison qui recevra les demandes et v√©rifiera et les √©quilibrera vers les services. le contr√¥leur Ingress **enverra la demande en fonction des r√®gles d'entr√©e configur√©es**. Notez que les r√®gles d'entr√©e peuvent pointer vers diff√©rents chemins ou m√™me sous-domaines vers diff√©rents services internes de Kubernetes.
    * Une meilleure pratique de s√©curit√© serait d'utiliser un √©quilibreur de charge cloud ou un serveur proxy comme point d'entr√©e pour ne pas avoir de partie du cluster Kubernetes expos√©e.
    * Lorsqu'une demande qui ne correspond √† aucune r√®gle d'entr√©e est re√ßue, le contr√¥leur Ingress la dirigera vers le "**Backend par d√©faut**". Vous pouvez `describe` le contr√¥leur Ingress pour obtenir l'adresse de ce param√®tre.
    * `minikube addons enable ingress`

### Infrastructure PKI - Autorit√© de certification CA :

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA est
## Actions de base

### Minikube

**Minikube** peut √™tre utilis√© pour effectuer des **tests rapides** sur Kubernetes sans avoir besoin de d√©ployer tout un environnement Kubernetes. Il ex√©cutera les processus de ma√Ætre et de n≈ìud sur une seule machine. Minikube utilisera virtualbox pour ex√©cuter le n≈ìud. Voir [**ici comment l'installer**](https://minikube.sigs.k8s.io/docs/start/).

```
$ minikube start
üòÑ  minikube v1.19.0 sur Ubuntu 20.04
‚ú®  Le pilote virtualbox a √©t√© automatiquement s√©lectionn√©. Autres choix : none, ssh
üíø  T√©l√©chargement de l'image de d√©marrage de la machine virtuelle...
    > minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
    > minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  D√©marrage du n≈ìud de plan de contr√¥le minikube dans le cluster minikube
üíæ  T√©l√©chargement de Kubernetes v1.20.2 preload...
    > preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Cr√©ation de la machine virtuelle virtualbox (CPUs=2, M√©moire=3900MB, Disque=20000MB)...
üê≥  Pr√©paration de Kubernetes v1.20.2 sur Docker 20.10.4...
    ‚ñ™ G√©n√©ration de certificats et de cl√©s...
    ‚ñ™ D√©marrage du plan de contr√¥le...
    ‚ñ™ Configuration des r√®gles RBAC...
üîé  V√©rification des composants Kubernetes...
    ‚ñ™ Utilisation de l'image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Add-ons activ√©s : storage-provisioner, default-storageclass
üèÑ  C'est fait ! kubectl est maintenant configur√© pour utiliser le cluster "minikube" et l'espace de noms "default" par d√©faut.

$ minikube status
h√¥te : en cours d'ex√©cution
kubelet : en cours d'ex√©cution
apiserver : en cours d'ex√©cution
kubeconfig : configur√©

---- UNE FOIS QUE VOUS AVEZ UN SERVICE K8 EN COURS D'EX√âCUTION AVEC UN SERVICE EXTERNE -----
$ minikube service mongo-express-service
(Cela ouvrira votre navigateur pour acc√©der au port expos√© du service)

$ minikube delete
üî•  Suppression de "minikube" dans virtualbox...
üíÄ  Toutes les traces du cluster "minikube" ont √©t√© supprim√©es
```

### Kubectl Basics

**`Kubectl`** est l'outil en ligne de commande pour les clusters Kubernetes. Il communique avec le serveur API du processus ma√Ætre pour effectuer des actions dans Kubernetes ou pour demander des donn√©es.

```bash
kubectl version #Obtenir la version client et serveur
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Acc√©der √† la configuration du d√©ploiement et la modifier
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Obtenir les journaux du pod pour le d√©bogage (la sortie du conteneur Docker en cours d'ex√©cution)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#D√©ployer √† partir d'un fichier de configuration
kubectl apply -f deployment.yml
```

### Tableau de bord Minikube

Le tableau de bord vous permet de voir plus facilement ce que Minikube ex√©cute, vous pouvez trouver l'URL pour y acc√©der dans :

```
minikube dashboard --url


üîå  Activation du tableau de bord...
    ‚ñ™ Utilisation de l'image kubernetesui/dashboard:v2.3.1
    ‚ñ™ Utilisation de l'image kubernetesui/metrics-scraper:v1.0.7
ü§î  V√©rification de la sant√© du tableau de bord...
üöÄ  Lancement du proxy...
ü§î  V√©rification de la sant√© du proxy...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```

### Exemples de fichiers de configuration YAML

Chaque fichier de configuration a 3 parties : **metadata**, **specification** (ce qui doit √™tre lanc√©), **status** (√©tat souhait√©).\
√Ä l'int√©rieur de la sp√©cification du fichier de configuration de d√©ploiement, vous pouvez trouver le mod√®le d√©fini avec une nouvelle structure de configuration d√©finissant l'image √† ex√©cuter :

**Exemple de d√©ploiement + service d√©clar√© dans le m√™me fichier de configuration (√† partir de** [**ici**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Comme un service est g√©n√©ralement li√© √† un d√©ploiement, il est possible de d√©clarer les deux dans le m√™me fichier de configuration (le service d√©clar√© dans cette configuration n'est accessible qu'en interne) :

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb-deployment
  labels:
    app: mongodb
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo
        ports:
        - containerPort: 27017
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom: 
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
  name:
### Helm

Helm est le **gestionnaire de paquets** pour Kubernetes. Il permet de cr√©er des fichiers YAML et de les distribuer dans des d√©p√¥ts publics et priv√©s. Ces paquets sont appel√©s **Helm Charts**.

```
helm search <mot-cl√©>
```

Helm est √©galement un moteur de mod√®le qui permet de g√©n√©rer des fichiers de configuration avec des variables :

## Secrets Kubernetes

Un **Secret** est un objet qui **contient des donn√©es sensibles** telles qu'un mot de passe, un jeton ou une cl√©. Ces informations pourraient autrement √™tre plac√©es dans une sp√©cification Pod ou dans une image. Les utilisateurs peuvent cr√©er des Secrets et le syst√®me cr√©e √©galement des Secrets. Le nom d'un objet Secret doit √™tre un **nom de sous-domaine DNS valide**. Lisez ici [la documentation officielle](https://kubernetes.io/docs/concepts/configuration/secret/).

Les secrets peuvent √™tre des choses comme :

* Cl√©s API, SSH.
* Jetons OAuth.
* Informations d'identification, mots de passe (texte brut ou b64 + chiffrement).
* Informations ou commentaires.
* Code de connexion √† la base de donn√©es, cha√Ænes... .

Il existe diff√©rents types de secrets dans Kubernetes

| Type int√©gr√©                        | Utilisation                                     |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **donn√©es arbitraires d√©finies par l'utilisateur (par d√©faut)** |
| kubernetes.io/service-account-token | jeton de compte de service                     |
| kubernetes.io/dockercfg             | fichier \~/.dockercfg s√©rialis√©             |
| kubernetes.io/dockerconfigjson      | fichier \~/.docker/config.json s√©rialis√©    |
| kubernetes.io/basic-auth            | informations d'identification pour l'authentification de base      |
| kubernetes.io/ssh-auth              | informations d'identification pour l'authentification SSH        |
| kubernetes.io/tls                   | donn√©es pour un client ou un serveur TLS           |
| bootstrap.kubernetes.io/token       | donn√©es de jeton de d√©marrage                      |

{% hint style="info" %}
**Le type Opaque est le type par d√©faut, la paire cl√©-valeur typique d√©finie par les utilisateurs.**
{% endhint %}

**Comment fonctionnent les secrets :**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Le fichier de configuration suivant d√©finit un **secret** appel√© `mysecret` avec 2 paires cl√©-valeur `username: YWRtaW4=` et `password: MWYyZDFlMmU2N2Rm`. Il d√©finit √©galement un **pod** appel√© `secretpod` qui aura les `username` et `password` d√©finis dans `mysecret` expos√©s dans les **variables d'environnement** `SECRET_USERNAME` et `SECRET_PASSWOR`. Il **montera** √©galement le secret `username` √† l'int√©rieur de `mysecret` dans le chemin `/etc/foo/my-group/my-username` avec des permissions `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
  name: secretpod
spec:
  containers:
  - name: secretpod
    image: nginx
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
  restartPolicy: Never
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
        mode: 0640
```
{% endcode %}

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Attendre que le pod secretpod soit en cours d'ex√©cution
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```

### Secrets dans etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** est un magasin de cl√©s-valeurs coh√©rent et hautement disponible utilis√© comme stockage de sauvegarde Kubernetes pour toutes les donn√©es de cluster. Acc√©dons aux secrets stock√©s dans etcd :

```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```

Vous verrez que les certificats, les cl√©s et les URL sont situ√©s dans le FS. Une fois que vous l'avez, vous pourrez vous connecter √† etcd.

```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```

Une fois que vous avez √©tabli la communication, vous pourrez obtenir les secrets :

```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```

**Ajout de chiffrement √† l'ETCD**

Par d√©faut, tous les secrets sont **stock√©s en clair** dans etcd √† moins que vous n'appliquiez une couche de chiffrement. L'exemple suivant est bas√© sur [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - aescbc:
        keys:
        - name: key1
          secret: cjjPMcWpTPKhAdieVtd+