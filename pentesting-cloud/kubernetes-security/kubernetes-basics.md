# Kubernetes Grundlagen

## Kubernetes Grundlagen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositorys einreichen.

</details>

**Der urspr√ºngliche Autor dieser Seite ist** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lesen Sie seinen Originalbeitrag** [**hier**](https://sickrov.github.io)**)**

## Architektur & Grundlagen

### Was macht Kubernetes?

* Erm√∂glicht das Ausf√ºhren von Container/n in einem Container-Engine.
* Der Scheduler erm√∂glicht effizientes Container-Management.
* H√§lt Container am Leben.
* Erm√∂glicht die Kommunikation zwischen Containern.
* Erm√∂glicht Bereitstellungstechniken.
* Verwaltet Datenmengen.

### Architektur

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: Betriebssystem mit Pod oder Pods.
* **Pod**: Wrapper um einen Container oder mehrere Container. Ein Pod sollte nur eine Anwendung enthalten (normalerweise f√ºhrt ein Pod nur 1 Container aus). Der Pod ist die Art und Weise, wie Kubernetes die Container-Technologie abstrahiert.
* **Service**: Jeder Pod hat 1 interne **IP-Adresse** aus dem internen Bereich des Nodes. Es kann jedoch auch √ºber einen Service freigegeben werden. Der **Service hat ebenfalls eine IP-Adresse** und sein Ziel ist es, die Kommunikation zwischen den Pods aufrechtzuerhalten, sodass, wenn einer stirbt, der **neue Ersatz** (mit einer anderen internen IP) im **gleichen IP des Service** zug√§nglich ist. Er kann als intern oder extern konfiguriert werden. Der Service fungiert auch als **Lastenausgleicher, wenn 2 Pods mit demselben Service verbunden sind**.\
Wenn ein **Service erstellt** wird, k√∂nnen Sie die Endpunkte jedes Dienstes finden, der `kubectl get endpoints` ausf√ºhrt.
* **Kubelet**: Prim√§rer Knoten-Agent. Die Komponente, die die Kommunikation zwischen Knoten und kubectl herstellt und nur Pods ausf√ºhren kann (√ºber den API-Server). Der Kubelet verwaltet keine Container, die nicht von Kubernetes erstellt wurden.
* **Kube-Proxy**: ist der Dienst, der f√ºr die Kommunikation (Services) zwischen dem API-Server und dem Knoten zust√§ndig ist. Die Basis ist ein IPtables f√ºr Knoten. Erfahrene Benutzer k√∂nnten auch andere Kube-Proxies von anderen Anbietern installieren.
* **Sidecar-Container**: Sidecar-Container sind die Container, die zusammen mit dem Hauptcontainer im Pod ausgef√ºhrt werden sollten. Dieses Sidecar-Muster erweitert und verbessert die Funktionalit√§t der aktuellen Container, ohne sie zu √§ndern. Heutzutage wissen wir, dass wir die Container-Technologie verwenden, um alle Abh√§ngigkeiten f√ºr die Anwendung zu verpacken, damit sie √ºberall ausgef√ºhrt werden kann. Ein Container macht nur eine Sache und macht diese Sache sehr gut.
* **Master-Prozess:**
* **API-Server:** Ist die Art und Weise, wie Benutzer und Pods mit dem Master-Prozess kommunizieren. Es sollten nur authentifizierte Anfragen zugelassen werden.
* **Scheduler**: Die Planung bezieht sich darauf, sicherzustellen, dass Pods den Knoten zugeordnet sind, damit Kubelet sie ausf√ºhren kann. Er verf√ºgt √ºber gen√ºgend Intelligenz, um zu entscheiden, welcher Knoten √ºber mehr verf√ºgbare Ressourcen verf√ºgt und den neuen Pod diesem zuweist. Beachten Sie, dass der Scheduler keine neuen Pods startet, sondern nur mit dem im Knoten ausgef√ºhrten Kubelet-Prozess kommuniziert, der den neuen Pod starten wird.
* **Kube-Controller-Manager**: √úberpr√ºft Ressourcen wie Replikamengen oder Bereitstellungen, um zu √ºberpr√ºfen, ob beispielsweise die richtige Anzahl von Pods oder Knoten ausgef√ºhrt wird. Wenn ein Pod fehlt, wird er mit dem Scheduler kommunizieren, um einen neuen zu starten. Er steuert Replikationen, Token und Kontodienste f√ºr die API.
* **etcd**: Datenspeicherung, persistent, konsistent und verteilt. Ist die Datenbank von Kubernetes und der Schl√ºssel-Wert-Speicher, in dem der vollst√§ndige Zustand der Cluster gespeichert wird (jede √Ñnderung wird hier protokolliert). Komponenten wie der Scheduler oder der Controller-Manager sind auf diese Daten angewiesen, um zu wissen, welche √Ñnderungen aufgetreten sind (verf√ºgbare Ressourcen der Knoten, Anzahl der ausgef√ºhrten Pods...).
* **Cloud-Controller-Manager**: Ist der spezifische Controller f√ºr Flusssteuerungen und Anwendungen, z. B. wenn Sie Cluster in AWS oder OpenStack haben.

Beachten Sie, dass es m√∂glicherweise mehrere Knoten (die mehrere Pods ausf√ºhren) gibt, es m√∂glicherweise auch mehrere Master-Prozesse gibt, deren Zugriff auf den API-Server ausbalanciert ist und deren etcd synchronisiert ist.

**Volumes:**

Wenn ein Pod Daten erstellt, die nicht verloren gehen sollten, wenn der Pod verschwindet, sollten sie in einem physischen Volume gespeichert werden. **Kubernetes erm√∂glicht das Anh√§ngen eines Volumes an einen Pod, um die Daten zu persistieren**. Das Volume kann sich auf der lokalen Maschine oder in einem **externen Speicher** befinden. Wenn Sie Pods auf verschiedenen physischen Knoten ausf√ºhren, sollten Sie einen externen Speicher verwenden, damit alle Pods darauf zugreifen k√∂nnen.

**Andere Konfigurationen:**

* **ConfigMap**: Sie k√∂nnen **URLs** konfigurieren, um auf Dienste zuzugreifen. Der Pod wird Daten von hier abrufen, um zu wissen, wie er mit dem Rest der Dienste (Pods) kommunizieren soll. Beachten Sie, dass dies nicht der empfohlene Ort zum Speichern von Anmeldeinformationen ist!
* **Secret**: Hier werden geheime Daten wie Passw√∂rter, API-Schl√ºssel... codiert in B64 gespeichert. Der Pod kann auf diese Daten zugreifen, um die erforderlichen Anmeldeinformationen zu verwenden.
* **Bereitstellungen**: Hier werden die von Kubernetes auszuf√ºhrenden Komponenten angegeben. Ein Benutzer arbeitet normalerweise nicht direkt mit Pods, Pods werden in **Replika-Sets** (Anzahl der replizierten gleichen Pods) abstrahiert, die √ºber Bereitstellungen ausgef√ºhrt werden. Beachten Sie, dass Bereitstellungen f√ºr **zustandslose** Anwendungen sind. Die Mindestkonfiguration f√ºr eine Bereitstellung ist der Name und das auszuf√ºhrende Image.
* **StatefulSet**: Diese Komponente ist speziell f√ºr Anwendungen wie **Datenbanken** gedacht, die auf **denselben Speicher zugreifen m√ºssen**.
* **Ingress**: Dies ist die Konfiguration, die verwendet wird, um die Anwendung √∂ffentlich mit einer URL **freizugeben**. Beachten Sie, dass dies auch mit externen Diensten m√∂glich ist, aber dies ist der richtige Weg, um die Anwendung freizugeben.
* Wenn Sie ein Ingress implementieren, m√ºssen Sie **Ingress-Controller** erstellen. Der Ingress-Controller ist ein **Pod**, der der Endpunkt ist, der die Anfragen empf√§ngt und √ºberpr√ºft und sie an die Dienste verteilt. Der Ingress-Controller wird die Anfrage basierend auf den konfigurierten Ingress-Regeln **weiterleiten**. Beachten Sie, dass die Ingress-Regeln auf verschiedene Pfade oder sogar Subdomains zu verschiedenen internen Kubernetes-Diensten verweisen k√∂nnen.
* Eine bessere Sicherheitspraxis w√§re die Verwendung eines Cloud-Lastenausgleichs oder eines Proxy-Servers als Einstiegspunkt, um keinen Teil des Kubernetes-Clusters freizulegen.
* Wenn eine Anfrage eingeht, die keiner Ingress-Regel entspricht, leitet der Ingress-Controller sie an den "**Standard-Backend**" weiter. Sie k√∂nnen `describe` des Ingress-Controllers verwenden, um die Adresse dieses Parameters zu erhalten.
* `minikube addons enable ingress`
### PKI Infrastruktur - Zertifizierungsstelle CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA ist die vertrauensw√ºrdige Wurzel f√ºr alle Zertifikate innerhalb des Clusters.
* Erm√∂glicht es Komponenten, sich gegenseitig zu validieren.
* Alle Cluster-Zertifikate werden von der CA signiert.
* ETCd hat sein eigenes Zertifikat.
* Typen:
  * apiserver-Zertifikat.
  * kubelet-Zertifikat.
  * Scheduler-Zertifikat.

## Grundlegende Aktionen

### Minikube

**Minikube** kann verwendet werden, um einige **schnelle Tests** auf Kubernetes durchzuf√ºhren, ohne eine komplette Kubernetes-Umgebung bereitzustellen. Es f√ºhrt die **Master- und Node-Prozesse auf einer Maschine** aus. Minikube verwendet VirtualBox, um den Node auszuf√ºhren. Siehe [**hier, wie man es installiert**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
‚ñ™ Generating certificates and keys ...
‚ñ™ Booting up control plane ...
‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```
### Kubectl Grundlagen

**`Kubectl`** ist das Befehlszeilentool f√ºr Kubernetes-Cluster. Es kommuniziert mit dem API-Server des Master-Prozesses, um Aktionen in Kubernetes auszuf√ºhren oder Daten abzurufen.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube-Dashboard

Das Dashboard erm√∂glicht es Ihnen, einfacher zu sehen, was Minikube ausf√ºhrt. Sie finden die URL zum Zugriff darauf unter:
```
minikube dashboard --url


üîå  Enabling dashboard ...
‚ñ™ Using image kubernetesui/dashboard:v2.3.1
‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Beispiele f√ºr YAML-Konfigurationsdateien

Jede Konfigurationsdatei hat 3 Teile: **Metadaten**, **Spezifikation** (was gestartet werden muss), **Status** (gew√ºnschter Zustand).\
Innerhalb der Spezifikation der Bereitstellungskonfigurationsdatei finden Sie die Vorlage definiert mit einer neuen Konfigurationsstruktur, die das auszuf√ºhrende Image definiert:

**Beispiel f√ºr Bereitstellung + Service, die in derselben Konfigurationsdatei deklariert sind (von** [**hier**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Da ein Dienst normalerweise mit einer Bereitstellung zusammenh√§ngt, ist es m√∂glich, beides in derselben Konfigurationsdatei zu deklarieren (der in dieser Konfiguration deklarierte Dienst ist nur intern zug√§nglich):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Beispiel f√ºr die Konfiguration eines externen Dienstes**

Dieser Dienst wird extern zug√§nglich sein (√ºberpr√ºfen Sie die Attribute `nodePort` und `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Dies ist n√ºtzlich f√ºr Tests, aber f√ºr die Produktion sollten Sie nur interne Dienste und einen Ingress haben, um die Anwendung freizugeben.
{% endhint %}

**Beispiel einer Ingress-Konfigurationsdatei**

Dies wird die Anwendung unter `http://dashboard.com` freigeben.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Beispiel einer Secrets-Konfigurationsdatei**

Beachten Sie, wie die Passw√∂rter in B64 codiert sind (was nicht sicher ist!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Beispiel f√ºr ConfigMap**

Ein **ConfigMap** ist die Konfiguration, die den Pods gegeben wird, damit sie wissen, wie sie andere Dienste lokalisieren und darauf zugreifen k√∂nnen. In diesem Fall wird jeder Pod wissen, dass der Name `mongodb-service` die Adresse eines Pods ist, mit dem sie kommunizieren k√∂nnen (dieser Pod wird ein mongodb ausf√ºhren):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Dann kann diese Adresse innerhalb einer **Bereitstellungskonfiguration** auf folgende Weise angegeben werden, damit sie im env des Pods geladen wird:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Beispiel f√ºr Volumenkonfiguration**

Sie k√∂nnen verschiedene Beispiele f√ºr Speicherkonfigurations-YAML-Dateien unter [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes) finden.  
**Beachten Sie, dass Volumes nicht innerhalb von Namespaces liegen**

### Namespaces

Kubernetes unterst√ºtzt **mehrere virtuelle Cluster**, die vom selben physischen Cluster unterst√ºtzt werden. Diese virtuellen Cluster werden **Namespaces** genannt. Diese sind f√ºr die Verwendung in Umgebungen mit vielen Benutzern √ºber mehrere Teams oder Projekte verteilt gedacht. F√ºr Cluster mit einigen bis zehn Benutzern sollten Sie keine Namespaces erstellen oder dar√ºber nachdenken m√ºssen. Sie sollten nur mit der Verwendung von Namespaces beginnen, um eine bessere Kontrolle und Organisation jedes Teils der Anwendung, die in Kubernetes bereitgestellt wird, zu haben.

Namespaces bieten einen Bereich f√ºr Namen. Namen von Ressourcen m√ºssen innerhalb eines Namespaces eindeutig sein, aber nicht √ºber Namespaces hinweg. Namespaces k√∂nnen nicht ineinander verschachtelt werden und **jede** Kubernetes-**Ressource** kann nur **in** **einem** **Namespace** sein.

Es gibt standardm√§√üig 4 Namespaces, wenn Sie minikube verwenden:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Es ist nicht f√ºr die Benutzer gedacht und du solltest es nicht ber√ºhren. Es ist f√ºr Master- und kubectl-Prozesse.
* **kube-public**: √ñffentlich zug√§ngliche Daten. Enth√§lt einen Configmap, der Clusterinformationen enth√§lt.
* **kube-node-lease**: Bestimmt die Verf√ºgbarkeit eines Knotens.
* **default**: Der Namespace, den der Benutzer zum Erstellen von Ressourcen verwenden wird.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Beachten Sie, dass die meisten Kubernetes-Ressourcen (z. B. Pods, Services, Replikationscontroller und andere) in bestimmten Namespaces sind. Andere Ressourcen wie Namespace-Ressourcen und Ressourcen auf niedriger Ebene, wie Nodes und PersistenVolumes, befinden sich jedoch nicht in einem Namespace. Um zu sehen, welche Kubernetes-Ressourcen in einem Namespace sind und welche nicht:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

Sie k√∂nnen den Namespace f√ºr alle nachfolgenden kubectl-Befehle in diesem Kontext speichern.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm ist der **Paketmanager** f√ºr Kubernetes. Es erm√∂glicht das Verpacken von YAML-Dateien und deren Verteilung in √∂ffentlichen und privaten Repositories. Diese Pakete werden als **Helm-Charts** bezeichnet.
```
helm search <keyword>
```
## Kubernetes Geheimnisse

Ein **Secret** ist ein Objekt, das **sensible Daten** wie ein Passwort, ein Token oder einen Schl√ºssel enth√§lt. Solche Informationen k√∂nnten anderweitig in einer Pod-Spezifikation oder in einem Image platziert werden. Benutzer k√∂nnen Secrets erstellen und das System erstellt auch Secrets. Der Name eines Secret-Objekts muss ein g√ºltiger **DNS-Subdom√§nenname** sein. Lesen Sie hier [die offizielle Dokumentation](https://kubernetes.io/docs/concepts/configuration/secret/).

Geheimnisse k√∂nnten Dinge wie sein:

- API, SSH-Schl√ºssel.
- OAuth-Token.
- Anmeldeinformationen, Passw√∂rter (Klartext oder b64 + Verschl√ºsselung).
- Informationen oder Kommentare.
- Datenbankverbindungscodes, Zeichenfolgen‚Ä¶ .

Es gibt verschiedene Arten von Secrets in Kubernetes

| Eingebauter Typ                     | Verwendung                                 |
| ----------------------------------- | ----------------------------------------- |
| **Undurchsichtig**                  | **beliebige benutzerdefinierte Daten (Standard)** |
| kubernetes.io/service-account-token | Servicekonto-Token                        |
| kubernetes.io/dockercfg             | serialisierte \~/.dockercfg-Datei         |
| kubernetes.io/dockerconfigjson      | serialisierte \~/.docker/config.json-Datei |
| kubernetes.io/basic-auth            | Anmeldeinformationen f√ºr die Basisauthentifizierung |
| kubernetes.io/ssh-auth              | Anmeldeinformationen f√ºr die SSH-Authentifizierung |
| kubernetes.io/tls                   | Daten f√ºr einen TLS-Client oder -Server   |
| bootstrap.kubernetes.io/token       | Bootstrap-Token-Daten                     |

{% hint style="info" %}
**Der Opaque-Typ ist der Standardtyp, das typische Schl√ºssel-Wert-Paar, das von Benutzern definiert wird.**
{% endhint %}

**Wie Secrets funktionieren:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

Die folgende Konfigurationsdatei definiert ein **Secret** namens `mysecret` mit 2 Schl√ºssel-Wert-Paaren `username: YWRtaW4=` und `password: MWYyZDFlMmU2N2Rm`. Es definiert auch einen **Pod** namens `secretpod`, der die in `mysecret` definierten `username` und `password` in den **Umgebungsvariablen** `SECRET_USERNAME` und `SECRET_PASSWOR` freigibt. Es wird auch das `username`-Secret innerhalb von `mysecret` im Pfad `/etc/foo/my-group/my-username` mit Berechtigungen `0640` **einh√§ngen**.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Geheimnisse in etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** ist ein konsistenter und hochverf√ºgbarer **Schl√ºssel-Wert-Speicher**, der als Kubernetes-Back-End-Speicher f√ºr alle Clusterdaten verwendet wird. Lassen Sie uns auf die in etcd gespeicherten Geheimnisse zugreifen:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Du wirst Zertifikate, Schl√ºssel und URLs sehen, die sich im Dateisystem befinden. Sobald du sie hast, wirst du in der Lage sein, eine Verbindung zum etcd herzustellen.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Sobald Sie die Kommunikation hergestellt haben, k√∂nnen Sie die Geheimnisse erhalten:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Hinzuf√ºgen von Verschl√ºsselung zum ETCD**

Standardm√§√üig werden alle Geheimnisse im ETCD im Klartext gespeichert, es sei denn, Sie wenden eine Verschl√ºsselungsschicht an. Das folgende Beispiel basiert auf [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Danach m√ºssen Sie das `--encryption-provider-config`-Flag auf dem `kube-apiserver` so setzen, dass es auf den Speicherort der erstellten Konfigurationsdatei zeigt. Sie k√∂nnen `/etc/kubernetes/manifest/kube-apiserver.yaml` bearbeiten und die folgenden Zeilen hinzuf√ºgen:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Scrollen Sie nach unten zu volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Scrolle im volumeMounts zum hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**√úberpr√ºfen, ob Daten verschl√ºsselt sind**

Daten werden verschl√ºsselt, wenn sie in etcd geschrieben werden. Nach dem Neustart Ihres `kube-apiservers` sollten neu erstellte oder aktualisierte Secrets verschl√ºsselt gespeichert werden. Zur √úberpr√ºfung k√∂nnen Sie das Befehlszeilenprogramm `etcdctl` verwenden, um den Inhalt Ihres Secrets abzurufen.

1. Erstellen Sie ein neues Secret namens `secret1` im Namespace `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Lesen Sie mit dem Befehlszeilenprogramm `etcdctl` dieses Secret aus etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

wobei `[...]` die zus√§tzlichen Argumente f√ºr die Verbindung zum etcd-Server sein m√ºssen.
3. √úberpr√ºfen Sie, ob das gespeicherte Secret mit `k8s:enc:aescbc:v1:` beginnt, was darauf hinweist, dass der Anbieter `aescbc` die resultierenden Daten verschl√ºsselt hat.
4. √úberpr√ºfen Sie, ob das Secret korrekt entschl√ºsselt wird, wenn es √ºber die API abgerufen wird:

```
kubectl describe secret secret1 -n default
```

sollte `mykey: bXlkYXRh` entsprechen, wobei `mydata` codiert ist. √úberpr√ºfen Sie [Entschl√ºsselung eines Secrets](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret), um das Secret vollst√§ndig zu entschl√ºsseln.

**Da Secrets beim Schreiben verschl√ºsselt werden, wird bei einem Update eines Secrets auch dieser Inhalt verschl√ºsselt:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Abschlie√üende Tipps:**

* Versuchen Sie, keine Geheimnisse im Dateisystem zu speichern, sondern holen Sie sie aus anderen Orten.
* Schauen Sie sich [https://www.vaultproject.io/](https://www.vaultproject.io) an, um Ihren Geheimnissen zus√§tzlichen Schutz zu bieten.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Referenzen

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
