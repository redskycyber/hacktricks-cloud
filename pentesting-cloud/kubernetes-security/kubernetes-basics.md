# Podstawy Kubernetes

## Podstawy Kubernetes

<details>

<summary><strong>Dowiedz siÄ™, jak hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ swojÄ… **firmÄ™ reklamowanÄ… w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** mnie na **Twitterze** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriÃ³w GitHub**.

</details>

**Oryginalnym autorem tej strony jest** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(przeczytaj jego oryginalny post** [**tutaj**](https://sickrov.github.io)**)**

## Architektura i podstawy

### Co robi Kubernetes?

* Pozwala na uruchamianie kontenera/kontenerÃ³w w silniku kontenerÃ³w.
* Harmonogram umoÅ¼liwia efektywne wykonywanie kontenerÃ³w.
* Utrzymuje kontenery w stanie dziaÅ‚ajÄ…cym.
* UmoÅ¼liwia komunikacjÄ™ miÄ™dzy kontenerami.
* UmoÅ¼liwia techniki wdraÅ¼ania.
* ZarzÄ…dza woluminami informacji.

### Architektura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: system operacyjny z podem lub podami.
* **Pod**: Opakowanie wokÃ³Å‚ kontenera lub wielu kontenerÃ³w. Pod powinien zawieraÄ‡ tylko jednÄ… aplikacjÄ™ (zwykle pod uruchamia tylko 1 kontener). Pod jest sposobem, w jaki Kubernetes abstrahuje technologiÄ™ kontenerÃ³w.
* **Service**: KaÅ¼dy pod ma 1 wewnÄ™trzny **adres IP** z wewnÄ™trznego zakresu wÄ™zÅ‚a. Jednak moÅ¼e byÄ‡ rÃ³wnieÅ¼ udostÄ™pniony za pomocÄ… usÅ‚ugi. **UsÅ‚uga ma rÃ³wnieÅ¼ adres IP**, a jej celem jest utrzymanie komunikacji miÄ™dzy podami, wiÄ™c jeÅ›li jeden pod umrze, **nowa replika** (z innym wewnÄ™trznym adresem IP) **bÄ™dzie dostÄ™pna** pod tym samym adresem IP usÅ‚ugi. MoÅ¼e byÄ‡ skonfigurowana jako wewnÄ™trzna lub zewnÄ™trzna. UsÅ‚uga dziaÅ‚a rÃ³wnieÅ¼ jako **wywaÅ¼arka obciÄ…Å¼enia, gdy 2 pody sÄ… podÅ‚Ä…czone** do tej samej usÅ‚ugi.\
Po **utworzeniu usÅ‚ugi** moÅ¼na znaleÅºÄ‡ punkty koÅ„cowe kaÅ¼dej usÅ‚ugi, uruchamiajÄ…c `kubectl get endpoints`
* **Kubelet**: GÅ‚Ã³wny agent wÄ™zÅ‚a. Komponent, ktÃ³ry nawiÄ…zuje komunikacjÄ™ miÄ™dzy wÄ™zÅ‚em a kubectl i moÅ¼e uruchamiaÄ‡ tylko pod (za poÅ›rednictwem serwera API). Kubelet nie zarzÄ…dza kontenerami, ktÃ³re nie zostaÅ‚y utworzone przez Kubernetes.
* **Kube-proxy**: jest usÅ‚ugÄ… odpowiedzialnÄ… za komunikacjÄ™ (usÅ‚ugi) miÄ™dzy serwerem API a wÄ™zÅ‚em. PodstawÄ… sÄ… IPtables dla wÄ™zÅ‚Ã³w. Bardziej doÅ›wiadczeni uÅ¼ytkownicy mogÄ… zainstalowaÄ‡ inne kube-proxy od innych dostawcÃ³w.
* **Kontener pomocniczy (Sidecar container)**: Kontenery pomocnicze to kontenery, ktÃ³re powinny dziaÅ‚aÄ‡ razem z gÅ‚Ã³wnym kontenerem w podzie. Ten wzorzec kontenera pomocniczego rozszerza i ulepsza funkcjonalnoÅ›Ä‡ istniejÄ…cych kontenerÃ³w bez ich zmiany. Obecnie wiemy, Å¼e uÅ¼ywamy technologii kontenerowej do opakowania wszystkich zaleÅ¼noÅ›ci potrzebnych do uruchomienia aplikacji w dowolnym miejscu. Kontener robi tylko jednÄ… rzecz i robi to bardzo dobrze.
* **Proces gÅ‚Ã³wny**:
* **Serwer API**: Jest to sposÃ³b, w jaki uÅ¼ytkownicy i pod uÅ¼ywajÄ… do komunikacji z procesem gÅ‚Ã³wnym. Tylko uwierzytelnione Å¼Ä…dania powinny byÄ‡ dozwolone.
* **Scheduler**: Harmonogramowanie oznacza dopasowanie podÃ³w do wÄ™zÅ‚Ã³w, aby Kubelet mÃ³gÅ‚ je uruchomiÄ‡. Ma wystarczajÄ…cÄ… inteligencjÄ™, aby zdecydowaÄ‡, ktÃ³ry wÄ™zeÅ‚ ma wiÄ™cej dostÄ™pnych zasobÃ³w i przypisaÄ‡ do niego nowy pod. NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e scheduler nie uruchamia nowych podÃ³w, tylko komunikuje siÄ™ z procesem Kubelet dziaÅ‚ajÄ…cym wewnÄ…trz wÄ™zÅ‚a, ktÃ³ry uruchomi nowy pod.
* **Kube Controller Manager**: Sprawdza zasoby, takie jak zbiory replik lub wdroÅ¼enia, aby sprawdziÄ‡, czy na przykÅ‚ad uruchomione jest prawidÅ‚owe liczba podÃ³w lub wÄ™zÅ‚Ã³w. JeÅ›li brakuje poda, skontaktuje siÄ™ z planistÄ…, aby uruchomiÄ‡ nowy. Kontroluje replikacje, tokeny i usÅ‚ugi konta w API.
* **etcd**: Przechowywanie danych, trwaÅ‚e, spÃ³jne i rozproszone. Jest to baza danych Kubernetes i magazyn klucz-wartoÅ›Ä‡, w ktÃ³rym przechowuje peÅ‚ny stan klastrÃ³w (kaÅ¼da zmiana jest tutaj rejestrowana). Komponenty takie jak Scheduler lub Kube Controller Manager zaleÅ¼Ä… od tych danych, aby wiedzieÄ‡, jakie zmiany nastÄ…piÅ‚y (dostÄ™pne zasoby wÄ™zÅ‚Ã³w, liczba uruchomionych podÃ³w...)
* **Cloud Controller Manager**: Jest to specyficzny kontroler do sterowania przepÅ‚ywem i aplikacjami, np. jeÅ›li masz klastry w AWS lub OpenStack.

NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e moÅ¼e byÄ‡ wiele wÄ™zÅ‚Ã³w (uruchamiajÄ…cych wiele podÃ³w), moÅ¼e rÃ³wnieÅ¼ byÄ‡ wiele procesÃ³w gÅ‚Ã³wnych, ktÃ³rych dostÄ™p do serwera API jest zrÃ³wnowaÅ¼ony obciÄ…Å¼eniowo, a ich etcd jest zsynchronizowane.

**Woluminy:**

Kiedy pod tworzy dane, ktÃ³re nie powinny zostaÄ‡ utracone, gdy pod zniknie, powinny byÄ‡ one przechowywane w woluminie fizycznym. **Kubernetes umoÅ¼liwia doÅ‚Ä…czenie woluminu do poda w celu zachowania danych**. Wolumen moÅ¼e znajdowaÄ‡ siÄ™ na lokalnej maszynie lub w **zdalnym magazynie**. JeÅ›li uruchamiasz pod w rÃ³Å¼nych fizycznych wÄ™zÅ‚ach, powinieneÅ› uÅ¼yÄ‡ zdalnego magazynu, aby wszystkie pod mogÅ‚y do niego uzyskaÄ‡ dostÄ™p.

**Inne konfiguracje:**

* **ConfigMap**: MoÅ¼esz skonfigurowaÄ‡ **adresy URL** do dostÄ™pu do usÅ‚ug. Pod pobierze dane stÄ…d, aby wiedzieÄ‡, jak komunikowaÄ‡ siÄ™ z resztÄ… usÅ‚ug (podÃ³w). NaleÅ¼y jednak pamiÄ™taÄ‡, Å¼e to nie jest zalecane miejsce do przechowywania poufnych danych!
* **Secret**: To jest miejsce do **przechowywania poufnych danych**, takich jak hasÅ‚a, klucze API... zakodowane w B64. Pod bÄ™dzie mÃ³gÅ‚ uzyskaÄ‡ dostÄ™p do tych danych, aby uÅ¼ywaÄ‡ wymaganych poÅ›wiadczeÅ„.
* **Deployments**: Tutaj wskazuje siÄ™ komponenty, ktÃ³re majÄ… byÄ‡ uruchamiane przez Kubernetes. UÅ¼ytkownik zwykle nie bÄ™dzie bezpoÅ›rednio pracowaÄ‡ z podami, podami sÄ… abstrahowane w **ReplicaSets** (liczba replikowanych tych samych podÃ³w), ktÃ³re sÄ… uruchamiane za pomocÄ… wdroÅ¼eÅ„. NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e wdroÅ¼enia sÄ… przeznaczone dla aplikacji **bezstanowych**. MinimalnÄ… konfiguracjÄ… dla wdroÅ¼enia jest nazwa i obraz do uruchomienia.
* **StatefulSet**: Ten komponent jest przeznaczony specjalnie dla aplikacji takich jak **bazy danych**, ktÃ³re muszÄ… **uzyskaÄ‡ dostÄ™p do tego samego magazynu**.
* **Ingress**: Jest to konfiguracja, ktÃ³ra sÅ‚uÅ¼y do **udostÄ™pniania aplikacji
### Infrastruktura PKI - Certyfikatowy UrzÄ…d CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA jest zaufanym ÅºrÃ³dÅ‚em dla wszystkich certyfikatÃ³w w klastrze.
* UmoÅ¼liwia komponentom wzajemnÄ… weryfikacjÄ™.
* Wszystkie certyfikaty klastra sÄ… podpisane przez CA.
* ETCd ma swÃ³j wÅ‚asny certyfikat.
* typy:
* certyfikat apiservera.
* certyfikat kubeleta.
* certyfikat schedulera.

## Podstawowe dziaÅ‚ania

### Minikube

**Minikube** moÅ¼na uÅ¼yÄ‡ do przeprowadzenia **szybkich testÃ³w** na kubernetes bez koniecznoÅ›ci wdraÅ¼ania caÅ‚ego Å›rodowiska kubernetes. Uruchomi on **procesy master i node na jednym komputerze**. Minikube bÄ™dzie uÅ¼ywaÄ‡ virtualboxa do uruchomienia node'a. Zobacz [**tutaj, jak go zainstalowaÄ‡**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
ğŸ˜„  minikube v1.19.0 on Ubuntu 20.04
âœ¨  Automatically selected the virtualbox driver. Other choices: none, ssh
ğŸ’¿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ’¾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
ğŸ”¥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
â–ª Generating certificates and keys ...
â–ª Booting up control plane ...
â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
ğŸ”¥  Deleting "minikube" in virtualbox ...
ğŸ’€  Removed all traces of the "minikube" cluster
```
### Podstawy Kubectl

**`Kubectl`** to narzÄ™dzie wiersza poleceÅ„ dla klastrÃ³w Kubernetes. Komunikuje siÄ™ z serwerem API procesu gÅ‚Ã³wnego, aby wykonywaÄ‡ dziaÅ‚ania w Kubernetes lub pytaÄ‡ o dane.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Panel Minikube

Panel umoÅ¼liwia Å‚atwe sprawdzenie, co jest uruchomione w minikube. MoÅ¼esz znaleÅºÄ‡ URL dostÄ™pu do niego w:
```
minikube dashboard --url


ğŸ”Œ  Enabling dashboard ...
â–ª Using image kubernetesui/dashboard:v2.3.1
â–ª Using image kubernetesui/metrics-scraper:v1.0.7
ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### PrzykÅ‚ady plikÃ³w konfiguracyjnych YAML

KaÅ¼dy plik konfiguracyjny skÅ‚ada siÄ™ z 3 czÄ™Å›ci: **metadata**, **specification** (co ma zostaÄ‡ uruchomione) i **status** (poÅ¼Ä…dany stan).\
WewnÄ…trz specyfikacji pliku konfiguracyjnego dla wdroÅ¼enia moÅ¼na znaleÅºÄ‡ szablon zdefiniowany za pomocÄ… nowej struktury konfiguracji okreÅ›lajÄ…cej obraz do uruchomienia:

**PrzykÅ‚ad wdroÅ¼enia + usÅ‚ugi zadeklarowane w tym samym pliku konfiguracyjnym (z** [**tutaj**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

PoniewaÅ¼ usÅ‚uga zazwyczaj jest powiÄ…zana z jednym wdroÅ¼eniem, moÅ¼na zadeklarowaÄ‡ oba w tym samym pliku konfiguracyjnym (usÅ‚uga zadeklarowana w tej konfiguracji jest dostÄ™pna tylko wewnÄ™trznie):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**PrzykÅ‚ad konfiguracji zewnÄ™trznej usÅ‚ugi**

Ta usÅ‚uga bÄ™dzie dostÄ™pna z zewnÄ…trz (sprawdÅº atrybuty `nodePort` i `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
To jest przydatne do testowania, ale w produkcji powinieneÅ› mieÄ‡ tylko wewnÄ™trzne usÅ‚ugi i Ingress do wystawienia aplikacji.
{% endhint %}

**PrzykÅ‚ad pliku konfiguracyjnego Ingress**

To wystawi aplikacjÄ™ pod adresem `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**PrzykÅ‚ad pliku konfiguracyjnego dla tajemnic**

ZauwaÅ¼, jak hasÅ‚a sÄ… zakodowane w B64 (co nie jest bezpieczne!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**PrzykÅ‚ad ConfigMap**

**ConfigMap** to konfiguracja, ktÃ³ra jest dostarczana do podÃ³w, aby wiedziaÅ‚y, jak zlokalizowaÄ‡ i uzyskaÄ‡ dostÄ™p do innych usÅ‚ug. W tym przypadku kaÅ¼dy pod bÄ™dzie wiedziaÅ‚, Å¼e nazwa `mongodb-service` to adres poda, z ktÃ³rym mogÄ… siÄ™ komunikowaÄ‡ (ten pod bÄ™dzie wykonywaÅ‚ mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
NastÄ™pnie, wewnÄ…trz konfiguracji **deploymentu**, ten adres moÅ¼na okreÅ›liÄ‡ w nastÄ™pujÄ…cy sposÃ³b, aby zostaÅ‚ zaÅ‚adowany do Å›rodowiska poda:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**PrzykÅ‚ad konfiguracji woluminu**

MoÅ¼esz znaleÅºÄ‡ rÃ³Å¼ne przykÅ‚ady plikÃ³w konfiguracyjnych yaml dla konfiguracji pamiÄ™ci masowej na stronie [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**ZauwaÅ¼, Å¼e woluminy nie sÄ… wewnÄ…trz przestrzeni nazw**

### Przestrzenie nazw

Kubernetes obsÅ‚uguje **wiele wirtualnych klastrÃ³w** opartych na tym samym fizycznym klastrze. Te wirtualne klastry nazywane sÄ… **przestrzeniami nazw**. SÄ… one przeznaczone do uÅ¼ytku w Å›rodowiskach z wieloma uÅ¼ytkownikami rozproszonymi na wiele zespoÅ‚Ã³w lub projektÃ³w. Dla klastrÃ³w z kilkoma do kilkudziesiÄ™ciu uÅ¼ytkownikÃ³w, nie powinieneÅ› w ogÃ³le musieÄ‡ tworzyÄ‡ lub myÅ›leÄ‡ o przestrzeniach nazw. Przestrzenie nazw powinny byÄ‡ uÅ¼ywane tylko w celu lepszego kontrolowania i organizacji kaÅ¼dej czÄ™Å›ci aplikacji wdraÅ¼anej w kubernetes.

Przestrzenie nazw zapewniajÄ… zakres dla nazw. Nazwy zasobÃ³w muszÄ… byÄ‡ unikalne w obrÄ™bie przestrzeni nazw, ale nie miÄ™dzy przestrzeniami nazw. Przestrzenie nazw nie mogÄ… byÄ‡ zagnieÅ¼dÅ¼ane wewnÄ…trz siebie i **kaÅ¼dy** zasÃ³b Kubernetes moÅ¼e znajdowaÄ‡ siÄ™ tylko **w jednej** przestrzeni nazw.

DomyÅ›lnie istnieje 4 przestrzenie nazw, jeÅ›li korzystasz z minikube:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Nie jest przeznaczony do uÅ¼ytku przez uÅ¼ytkownikÃ³w i nie powinno siÄ™ go dotykaÄ‡. SÅ‚uÅ¼y do procesÃ³w mastera i kubectl.
* **kube-public**: Publicznie dostÄ™pne dane. Zawiera configmapÄ™, ktÃ³ra zawiera informacje o klastrze.
* **kube-node-lease**: OkreÅ›la dostÄ™pnoÅ›Ä‡ wÄ™zÅ‚a.
* **default**: PrzestrzeÅ„ nazw, ktÃ³rÄ… uÅ¼ytkownik bÄ™dzie uÅ¼ywaÅ‚ do tworzenia zasobÃ³w.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
NaleÅ¼y zauwaÅ¼yÄ‡, Å¼e wiÄ™kszoÅ›Ä‡ zasobÃ³w Kubernetes (np. podÃ³w, usÅ‚ug, kontrolerÃ³w replikacji i innych) znajduje siÄ™ w pewnych przestrzeniach nazw. Jednak inne zasoby, takie jak zasoby przestrzeni nazw i zasoby niskiego poziomu, takie jak wÄ™zÅ‚y i persistenVolumes, nie znajdujÄ… siÄ™ w przestrzeni nazw. Aby zobaczyÄ‡, ktÃ³re zasoby Kubernetes sÄ… i ktÃ³re nie sÄ… w przestrzeni nazw:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

MoÅ¼esz zapisaÄ‡ przestrzeÅ„ nazw dla wszystkich kolejnych poleceÅ„ kubectl w tym kontekÅ›cie.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm jest **menedÅ¼erem pakietÃ³w** dla Kubernetes. Pozwala na pakietowanie plikÃ³w YAML i ich dystrybucjÄ™ w publicznych i prywatnych repozytoriach. Te pakiety nazywane sÄ… **Helm Charts**.
```
helm search <keyword>
```
Helm to rÃ³wnieÅ¼ silnik szablonÃ³w, ktÃ³ry umoÅ¼liwia generowanie plikÃ³w konfiguracyjnych z zmiennymi:

## Sekrety Kubernetes

**Secret** to obiekt, ktÃ³ry **zawiera poufne dane**, takie jak hasÅ‚o, token lub klucz. Takie informacje mogÄ… byÄ‡ umieszczone w specyfikacji Podu lub w obrazie. UÅ¼ytkownicy mogÄ… tworzyÄ‡ sekrety, a system rÃ³wnieÅ¼ tworzy sekrety. Nazwa obiektu Secret musi byÄ‡ prawidÅ‚owÄ… **nazwÄ… poddomeny DNS**. Przeczytaj tutaj [oficjalnÄ… dokumentacjÄ™](https://kubernetes.io/docs/concepts/configuration/secret/).

Sekrety mogÄ… byÄ‡ takie jak:

* Klucze API, SSH.
* Tokeny OAuth.
* PoÅ›wiadczenia, hasÅ‚a (tekst zwykÅ‚y lub b64 + szyfrowanie).
* Informacje lub komentarze.
* Kod Å‚Ä…czenia z bazÄ… danych, ciÄ…gi... .

W Kubernetes istniejÄ… rÃ³Å¼ne typy sekretÃ³w

| Wbudowany typ                       | UÅ¼ycie                                     |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **dowolne dane zdefiniowane przez uÅ¼ytkownika (domyÅ›lnie)** |
| kubernetes.io/service-account-token | token konta usÅ‚ugi                        |
| kubernetes.io/dockercfg             | zserializowany plik \~/.dockercfg          |
| kubernetes.io/dockerconfigjson      | zserializowany plik \~/.docker/config.json |
| kubernetes.io/basic-auth            | poÅ›wiadczenia do uwierzytelniania podstawowego |
| kubernetes.io/ssh-auth              | poÅ›wiadczenia do uwierzytelniania SSH      |
| kubernetes.io/tls                   | dane dla klienta lub serwera TLS          |
| bootstrap.kubernetes.io/token       | dane tokena rozruchowego                   |

{% hint style="info" %}
**Typ Opaque jest domyÅ›lny, to typowy para klucz-wartoÅ›Ä‡ zdefiniowany przez uÅ¼ytkownikÃ³w.**
{% endhint %}

**Jak dziaÅ‚ajÄ… sekrety:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

PoniÅ¼szy plik konfiguracyjny definiuje **sekret** o nazwie `mysecret` z dwoma parami klucz-wartoÅ›Ä‡ `username: YWRtaW4=` i `password: MWYyZDFlMmU2N2Rm`. Definiuje rÃ³wnieÅ¼ **pod** o nazwie `secretpod`, ktÃ³ry bÄ™dzie miaÅ‚ `username` i `password` zdefiniowane w `mysecret` wystawione jako **zmienne Å›rodowiskowe** `SECRET_USERNAME` i `SECRET_PASSWOR`. BÄ™dzie rÃ³wnieÅ¼ **montowaÄ‡** sekret `username` wewnÄ…trz `mysecret` w Å›cieÅ¼ce `/etc/foo/my-group/my-username` z uprawnieniami `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Tajemnice w etcd <a href="#odkrywanie-tajemnic-w-etcd" id="odkrywanie-tajemnic-w-etcd"></a>

**etcd** to spÃ³jny i wysoko dostÄ™pny **sklep klucz-wartoÅ›Ä‡** uÅ¼ywany jako magazyn danych klastra Kubernetes. Pozwala nam uzyskaÄ‡ dostÄ™p do przechowywanych w etcd tajemnic:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
Zobaczysz, Å¼e certyfikaty, klucze i adresy URL sÄ… przechowywane w systemie plikÃ³w. Po ich uzyskaniu bÄ™dziesz w stanie poÅ‚Ä…czyÄ‡ siÄ™ z etcd.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Gdy juÅ¼ uda ci siÄ™ nawiÄ…zaÄ‡ komunikacjÄ™, bÄ™dziesz w stanie uzyskaÄ‡ tajemnice:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Dodawanie szyfrowania do ETCD**

DomyÅ›lnie wszystkie tajemnice sÄ… przechowywane w postaci **czystego tekstu** wewnÄ…trz etcd, chyba Å¼e zastosujesz warstwÄ™ szyfrowania. PoniÅ¼szy przykÅ‚ad oparty jest na [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

NastÄ™pnie musisz ustawiÄ‡ flagÄ™ `--encryption-provider-config` na `kube-apiserver`, aby wskazaÄ‡ lokalizacjÄ™ utworzonego pliku konfiguracyjnego. MoÅ¼esz zmodyfikowaÄ‡ `/etc/kubernetes/manifest/kube-apiserver.yaml` i dodaÄ‡ nastÄ™pujÄ…ce linie:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
PrzewiÅ„ w dÃ³Å‚ do volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
PrzewiÅ„ w dÃ³Å‚ do volumeMounts do hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Weryfikacja, czy dane sÄ… zaszyfrowane**

Dane sÄ… szyfrowane podczas zapisu do etcd. Po ponownym uruchomieniu `kube-apiserver`, nowo utworzone lub zaktualizowane tajemnice powinny byÄ‡ zaszyfrowane podczas przechowywania. Aby to sprawdziÄ‡, moÅ¼na uÅ¼yÄ‡ programu wiersza poleceÅ„ `etcdctl`, aby pobraÄ‡ zawartoÅ›Ä‡ tajemnicy.

1. UtwÃ³rz nowÄ… tajemnicÄ™ o nazwie `secret1` w przestrzeni nazw `default`:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. Za pomocÄ… polecenia etcdctl odczytaj tÄ™ tajemnicÄ™ z etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

gdzie `[...]` muszÄ… byÄ‡ dodatkowe argumenty do poÅ‚Ä…czenia z serwerem etcd.
3. Zweryfikuj, czy przechowywana tajemnica ma prefiks `k8s:enc:aescbc:v1:`, co wskazuje, Å¼e dostawca `aescbc` zaszyfrowaÅ‚ dane wynikowe.
4. Zweryfikuj, czy tajemnica jest poprawnie odszyfrowana podczas pobierania za pomocÄ… interfejsu API:

```
kubectl describe secret secret1 -n default
```

powinno pasowaÄ‡ do `mykey: bXlkYXRh`, mydata jest zakodowane, sprawdÅº [dekodowanie tajemnicy](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret), aby caÅ‚kowicie odkodowaÄ‡ tajemnicÄ™.

**PoniewaÅ¼ tajemnice sÄ… szyfrowane podczas zapisu, wykonanie aktualizacji tajemnicy spowoduje zaszyfrowanie tego zawartoÅ›ci:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Ostateczne wskazÃ³wki:**

* Staraj siÄ™ nie przechowywaÄ‡ tajemnic w systemie plikÃ³w, pobieraj je z innych miejsc.
* SprawdÅº [https://www.vaultproject.io/](https://www.vaultproject.io), aby zwiÄ™kszyÄ‡ ochronÄ™ swoich tajemnic.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Referencje

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

<details>

<summary><strong>Naucz siÄ™ hakowaÄ‡ AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* JeÅ›li chcesz zobaczyÄ‡ **reklamÄ™ swojej firmy w HackTricks** lub **pobraÄ‡ HackTricks w formacie PDF**, sprawdÅº [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* ZdobÄ…dÅº [**oficjalne gadÅ¼ety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**RodzinÄ™ PEASS**](https://opensea.io/collection/the-peass-family), naszÄ… kolekcjÄ™ ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **DoÅ‚Ä…cz do** ğŸ’¬ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **Å›ledÅº** mnie na **Twitterze** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podziel siÄ™ swoimi sztuczkami hakerskimi, przesyÅ‚ajÄ…c PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **na GitHubie.**

</details>
