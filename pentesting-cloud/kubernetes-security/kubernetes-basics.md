# Fundamentos de Kubernetes

## Fundamentos de Kubernetes

<details>

<summary><strong>¬°Apoya a HackTricks y obt√©n beneficios!</strong></summary>

* Si quieres ver a tu **empresa anunciada en HackTricks** o si quieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PR a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**El autor original de esta p√°gina es** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(lee su publicaci√≥n original** [**aqu√≠**](https://sickrov.github.io)**)**

## Arquitectura y fundamentos

### ¬øQu√© hace Kubernetes?

* Permite ejecutar contenedores en un motor de contenedores.
* La programaci√≥n permite que los contenedores sean m√°s eficientes en su misi√≥n.
* Mantiene los contenedores vivos.
* Permite la comunicaci√≥n entre contenedores.
* Permite t√©cnicas de implementaci√≥n.
* Maneja vol√∫menes de informaci√≥n.

### Arquitectura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Nodo**: sistema operativo con pod o pods.
  * **Pod**: Envoltorio alrededor de un contenedor o varios contenedores. Un pod solo debe contener una aplicaci√≥n (por lo que generalmente, un pod ejecuta solo 1 contenedor). El pod es la forma en que Kubernetes abstrae la tecnolog√≠a de contenedores que se ejecuta.
    * **Servicio**: Cada pod tiene 1 direcci√≥n **IP interna** del rango interno del nodo. Sin embargo, tambi√©n se puede exponer a trav√©s de un servicio. El **servicio tambi√©n tiene una direcci√≥n IP** y su objetivo es mantener la comunicaci√≥n entre los pods, por lo que si uno muere, el **nuevo reemplazo** (con una IP interna diferente) **ser√° accesible** expuesto en la **misma IP del servicio**. Se puede configurar como interno o externo. El servicio tambi√©n act√∫a como un **balanceador de carga cuando 2 pods est√°n conectados** al mismo servicio.\
      Cuando se **crea un servicio**, se pueden encontrar los puntos finales de cada servicio ejecutando `kubectl get endpoints`
* **Kubelet**: Agente primario del nodo. El componente que establece la comunicaci√≥n entre el nodo y kubectl, y solo puede ejecutar pods (a trav√©s del servidor API). El kubelet no administra contenedores que no fueron creados por Kubernetes.
* **Kube-proxy**: es el servicio encargado de las comunicaciones (servicios) entre el servidor API y el nodo. La base es un IPtables para nodos. Los usuarios m√°s experimentados podr√≠an instalar otros kube-proxies de otros proveedores.
* **Contenedor Sidecar**: Los contenedores Sidecar son los contenedores que deben ejecutarse junto con el contenedor principal en el pod. Este patr√≥n de sidecar extiende y mejora la funcionalidad de los contenedores actuales sin cambiarlos. Hoy en d√≠a, sabemos que usamos la tecnolog√≠a de contenedores para envolver todas las dependencias para que la aplicaci√≥n se ejecute en cualquier lugar. Un contenedor hace solo una cosa y hace esa cosa muy bien.
* **Proceso maestro:**
  * **Servidor API:** Es la forma en que los usuarios y los pods se comunican con el proceso maestro. Solo se deben permitir solicitudes autenticadas.
  * **Programador**: La programaci√≥n se refiere a asegurarse de que los pods se correspondan con los nodos para que Kubelet pueda ejecutarlos. Tiene suficiente inteligencia para decidir qu√© nodo tiene m√°s recursos disponibles y asignar el nuevo pod a √©l. Tenga en cuenta que el programador no inicia nuevos pods, simplemente se comunica con el proceso Kubelet que se ejecuta dentro del nodo, que lanzar√° el nuevo pod.
  * **Administrador de controladores de Kube**: Verifica los recursos como conjuntos de r√©plicas o implementaciones para verificar si, por ejemplo, se est√°n ejecutando el n√∫mero correcto de pods o nodos. En caso de que falte un pod, se comunicar√° con el programador para iniciar uno nuevo. Controla la replicaci√≥n, los tokens y los servicios de cuenta para la API.
  * **etcd**: Almacenamiento de datos, persistente, consistente y distribuido. Es la base de datos de Kubernetes y el almacenamiento de clave-valor donde mantiene el estado completo de los cl√∫steres (cada cambio se registra aqu√≠). Componentes como el programador o el administrador de controladores dependen de esta fecha para saber qu√© cambios han ocurrido (recursos disponibles de los nodos, n√∫mero de pods en ejecuci√≥n...)
* **Administrador de controladores en la nube**: Es el controlador espec√≠fico para el control de flujos y aplicaciones, es decir: si tiene cl√∫steres en AWS o OpenStack.

Tenga en cuenta que, como puede haber varios nodos (ejecutando varios pods), tambi√©n puede haber varios procesos maestros cuyo acceso al servidor API se equilibra y su etcd se sincroniza.

**Vol√∫menes:**

Cuando un pod crea datos que no deben perderse cuando el pod desaparece, deben almacenarse en un volumen f√≠sico. **Kubernetes permite adjuntar un volumen a un pod para persistir los datos**. El volumen puede estar en la m√°quina local o en un **almacenamiento remoto**. Si est√° ejecutando pods en diferentes nodos f√≠sicos, debe usar un almacenamiento remoto para que todos los pods puedan acceder a √©l.

**Otras configuraciones:**

* **ConfigMap**: Puede configurar **URL** para acceder a servicios. El pod obtendr√° datos de aqu√≠ para saber c√≥mo comunicarse con el resto de los servicios (pods). ¬°Tenga en cuenta que este no es el lugar recomendado para guardar credenciales!
* **Secret**: Este es el lugar para **almacenar datos secretos** como contrase√±as, claves de API... codificadas en B64. El pod podr√° acceder a estos datos para usar las credenciales requeridas.
* **Implementaciones**: Aqu√≠ es donde se indican los componentes que se ejecutar√°n por Kubernetes. Un usuario generalmente no trabajar√° directamente con pods, los pods se abstraen en **ReplicaSets** (n√∫mero de pods id√©nticos replicados), que se ejecutan a trav√©s de implementaciones. Tenga en cuenta que las implementaciones son para aplicaciones **sin estado**. La configuraci√≥n m√≠nima para una implementaci√≥n es el nombre y la imagen a ejecutar.
* **StatefulSet**: Este componente est√° destinado espec√≠ficamente a aplicaciones como **bases de datos** que necesitan **acceder al mismo almacenamiento**.
* **Ingress**: Esta es la configuraci√≥n que se utiliza para **exponer la aplicaci√≥n p√∫blicamente con una URL**. Tenga en cuenta que esto tambi√©n se puede hacer utilizando servicios externos, pero esta es la forma correcta de exponer la aplicaci√≥n.
  * Si implementa un Ingress, deber√° crear **Controladores de Ingress**. El controlador de Ingress es un **pod** que ser√° el punto final que recibir√° las solicitudes y verificar√° y las equilibrar√° a los servicios. el controlador de ingreso **enviar√° la solicitud en funci√≥n de las reglas de ingreso configuradas**. Tenga en cuenta que las reglas de ingreso pueden apuntar a diferentes rutas o incluso subdominios a diferentes servicios internos de Kubernetes.
    * Una pr√°ctica de seguridad mejor ser√≠a usar un balanceador de carga en la nube o un servidor proxy como punto de entrada para no tener ninguna parte del cl√∫ster de Kubernetes expuesta.
    * Cuando se recibe una solicitud que no coincide con ninguna regla de ingreso, el controlador de ingreso la dirigir√° al "**backend predeterminado**". Puede `describir` el controlador de ingreso para obtener la direcci√≥n de este par√°metro.
    * `minikube addons enable ingress`
### Infraestructura PKI - Autoridad de Certificaci√≥n CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA es la ra√≠z de confianza para todos los certificados dentro del cl√∫ster.
* Permite que los componentes se validen entre s√≠.
* Todos los certificados del cl√∫ster est√°n firmados por la CA.
* ETCd tiene su propio certificado.
* tipos:
  * certificado de apiserver.
  * certificado de kubelet.
  * certificado de programador.

## Acciones b√°sicas

### Minikube

**Minikube** se puede utilizar para realizar algunas **pruebas r√°pidas** en kubernetes sin necesidad de implementar todo un entorno de kubernetes. Ejecutar√° los procesos de **master y node en una sola m√°quina**. Minikube utilizar√° virtualbox para ejecutar el nodo. Vea [**aqu√≠ c√≥mo instalarlo**](https://minikube.sigs.k8s.io/docs/start/).

```
$ minikube start
üòÑ  minikube v1.19.0 en Ubuntu 20.04
‚ú®  Se seleccion√≥ autom√°ticamente el controlador virtualbox. Otras opciones: none, ssh
üíø  Descargando la imagen de arranque de la VM ...
    > minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
    > minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Iniciando el nodo del plano de control minikube en el cl√∫ster minikube
üíæ  Descargando Kubernetes v1.20.2 preload ...
    > preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creando la VM de virtualbox (CPUs=2, Memoria=3900MB, Disco=20000MB) ...
üê≥  Preparando Kubernetes v1.20.2 en Docker 20.10.4 ...
    ‚ñ™ Generando certificados y claves ...
    ‚ñ™ Iniciando el plano de control ...
    ‚ñ™ Configurando las reglas de RBAC ...
üîé  Verificando los componentes de Kubernetes...
    ‚ñ™ Usando la imagen gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Se habilitaron los complementos: storage-provisioner, default-storageclass
üèÑ  ¬°Listo! kubectl est√° configurado para usar el cl√∫ster "minikube" y el espacio de nombres "default" de forma predeterminada

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- UNA VEZ QUE TENGA UN SERVICIO K8 EN EJECUCI√ìN CON UN SERVICIO EXTERNO -----
$ minikube service mongo-express-service
(Esto abrir√° su navegador para acceder al puerto expuesto del servicio)

$ minikube delete
üî•  Eliminando "minikube" en virtualbox ...
üíÄ  Se eliminaron todas las huellas del cl√∫ster "minikube"
```

### Conceptos b√°sicos de Kubectl

**`Kubectl`** es la herramienta de l√≠nea de comandos para cl√∫steres de kubernetes. Se comunica con el servidor Api del proceso maestro para realizar acciones en kubernetes o para solicitar datos.

```bash
kubectl version #Obtener la versi√≥n del cliente y del servidor
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Acceda a la configuraci√≥n del despliegue y modif√≠quela
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Obtenga los registros del pod para la depuraci√≥n (la salida del contenedor docker en ejecuci√≥n)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Implementar desde el archivo de configuraci√≥n
kubectl apply -f deployment.yml
```

### Panel de control de Minikube

El panel de control le permite ver m√°s f√°cilmente lo que est√° ejecutando minikube, puede encontrar la URL para acceder a √©l en:

```
minikube dashboard --url


üîå  Habilitando el panel de control ...
    ‚ñ™ Usando la imagen kubernetesui/dashboard:v2.3.1
    ‚ñ™ Usando la imagen kubernetesui/metrics-scraper:v1.0.7
ü§î  Verificando la salud del panel de control ...
üöÄ  Lanzando el proxy ...
ü§î  Verificando la salud del proxy ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```

### Ejemplos de archivos de configuraci√≥n YAML

Cada archivo de configuraci√≥n tiene 3 partes: **metadata**, **specification** (lo que se necesita lanzar), **status** (estado deseado).\
Dentro de la especificaci√≥n del archivo de configuraci√≥n de implementaci√≥n, puede encontrar la plantilla definida con una nueva estructura de configuraci√≥n que define la imagen a ejecutar:

**Ejemplo de implementaci√≥n + servicio declarado en el mismo archivo de configuraci√≥n (de** [**aqu√≠**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Como un servicio generalmente est√° relacionado con una implementaci√≥n, es posible declarar ambos en el mismo archivo de configuraci√≥n (el servicio declarado en esta configuraci√≥n solo es accesible internamente):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb-deployment
  labels:
    app: mongodb
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo
        ports:
        - containerPort: 27017
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom: 
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
spec:
  selector:
    app: mongodb
  ports:
    - protocol: TCP
      port: 27017
      targetPort: 27017
```

**E
# Crear namespace
kubectl create namespace my-namespace
```

{% hint style="info" %}
Tenga en cuenta que la mayor√≠a de los recursos de Kubernetes (por ejemplo, pods, servicios, controladores de replicaci√≥n y otros) est√°n en algunos espacios de nombres. Sin embargo, otros recursos como los recursos de espacio de nombres y los recursos de bajo nivel, como los nodos y los vol√∫menes persistentes, no est√°n en un espacio de nombres. Para ver qu√© recursos de Kubernetes est√°n y no est√°n en un espacio de nombres:

```bash
kubectl api-resources --namespaced=true #En un espacio de nombres
kubectl api-resources --namespaced=false #No en un espacio de nombres
```
{% endhint %}

Puede guardar el espacio de nombres para todos los comandos kubectl posteriores en ese contexto.

```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```

### Helm

Helm es el **administrador de paquetes** para Kubernetes. Permite empaquetar archivos YAML y distribuirlos en repositorios p√∫blicos y privados. Estos paquetes se llaman **Helm Charts**.

```
helm search <keyword>
```

Helm tambi√©n es un motor de plantillas que permite generar archivos de configuraci√≥n con variables:

## Secretos de Kubernetes

Un **Secreto** es un objeto que **contiene datos sensibles** como una contrase√±a, un token o una clave. De lo contrario, dicha informaci√≥n podr√≠a ponerse en una especificaci√≥n de Pod o en una imagen. Los usuarios pueden crear Secretos y el sistema tambi√©n crea Secretos. El nombre de un objeto Secret debe ser un nombre de subdominio DNS v√°lido. Lea aqu√≠ [la documentaci√≥n oficial](https://kubernetes.io/docs/concepts/configuration/secret/).

Los secretos podr√≠an ser cosas como:

* API, claves SSH.
* Tokens OAuth.
* Credenciales, contrase√±as (texto plano o b64 + cifrado).
* Informaci√≥n o comentarios.
* C√≥digo de conexi√≥n de base de datos, cadenas‚Ä¶ .

Hay diferentes tipos de secretos en Kubernetes

| Tipo integrado                       | Uso                                       |
| ----------------------------------- | ----------------------------------------- |
| **Opaco**                           | **datos definidos por el usuario arbitrarios (predeterminado)** |
| kubernetes.io/service-account-token | token de cuenta de servicio               |
| kubernetes.io/dockercfg             | archivo \~/.dockercfg serializado          |
| kubernetes.io/dockerconfigjson      | archivo \~/.docker/config.json serializado |
| kubernetes.io/basic-auth            | credenciales para autenticaci√≥n b√°sica     |
| kubernetes.io/ssh-auth              | credenciales para autenticaci√≥n SSH        |
| kubernetes.io/tls                   | datos para un cliente o servidor TLS       |
| bootstrap.kubernetes.io/token       | datos de token de arranque                 |

{% hint style="info" %}
**El tipo Opaque es el predeterminado, el par clave-valor t√≠pico definido por los usuarios.**
{% endhint %}

**C√≥mo funcionan los secretos:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

El siguiente archivo de configuraci√≥n define un **secreto** llamado `mysecret` con 2 pares clave-valor `username: YWRtaW4=` y `password: MWYyZDFlMmU2N2Rm`. Tambi√©n define un **pod** llamado `secretpod` que tendr√° el `username` y la `password` definidos en `mysecret` expuestos en las **variables de entorno** `SECRET_USERNAME` y `SECRET_PASSWOR`. Tambi√©n **montar√°** el secreto `username` dentro de `mysecret` en la ruta `/etc/foo/my-group/my-username` con permisos `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
  name: secretpod
spec:
  containers:
  - name: secretpod
    image: nginx
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
  restartPolicy: Never
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
        mode: 0640
```
{% endcode %}

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Espere hasta que el pod secretpod est√© en ejecuci√≥n
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```

### Secretos en etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** es una tienda de **clave-valor consistente y altamente disponible** utilizada como almacenamiento de respaldo de Kubernetes para todos los datos del cl√∫ster. Accedamos a los secretos almacenados en etcd:

```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```

Ver√° que los certificados, claves y URL se encuentran en el sistema de archivos. Una vez que lo obtenga, podr√° conectarse a etcd.

```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```

Una vez que logre establecer la comunicaci√≥n, podr√° obtener los secretos:

```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket>