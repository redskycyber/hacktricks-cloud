# Conceitos B√°sicos do Kubernetes

## Conceitos B√°sicos do Kubernetes

<details>

<summary><strong>Apoie o HackTricks e obtenha benef√≠cios!</strong></summary>

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou se deseja acessar a **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>

**O autor original desta p√°gina √©** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(leia seu post original** [**aqui**](https://sickrov.github.io)**)**

## Arquitetura e Conceitos B√°sicos

### O que o Kubernetes faz?

* Permite a execu√ß√£o de cont√™ineres em um mecanismo de cont√™ineres.
* O agendamento permite que os cont√™ineres sejam executados de forma eficiente.
* Mant√©m os cont√™ineres em execu√ß√£o.
* Permite a comunica√ß√£o entre cont√™ineres.
* Permite t√©cnicas de implanta√ß√£o.
* Manipula volumes de informa√ß√µes.

### Arquitetura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **Node**: sistema operacional com pod ou pods.
  * **Pod**: inv√≥lucro em torno de um cont√™iner ou v√°rios cont√™ineres. Um pod deve conter apenas um aplicativo (portanto, geralmente, um pod executa apenas 1 cont√™iner). O pod √© a maneira como o Kubernetes abstrai a tecnologia de cont√™iner em execu√ß√£o.
    * **Service**: Cada pod tem 1 **endere√ßo IP interno** da faixa interna do n√≥. No entanto, ele tamb√©m pode ser exposto por meio de um servi√ßo. O **servi√ßo tamb√©m tem um endere√ßo IP** e seu objetivo √© manter a comunica√ß√£o entre os pods, para que, se um morrer, o **novo substituto** (com um IP interno diferente) **seja acess√≠vel** exposto no **mesmo IP do servi√ßo**. Ele pode ser configurado como interno ou externo. O servi√ßo tamb√©m atua como um **balanceador de carga quando 2 pods est√£o conectados** ao mesmo servi√ßo.\
      Quando um **servi√ßo** √© **criado**, voc√™ pode encontrar os endpoints de cada servi√ßo executando `kubectl get endpoints`
* **Kubelet**: agente prim√°rio do n√≥. O componente que estabelece a comunica√ß√£o entre o n√≥ e o kubectl e s√≥ pode executar pods (por meio do servidor API). O kubelet n√£o gerencia cont√™ineres que n√£o foram criados pelo Kubernetes.
* **Kube-proxy**: √© o servi√ßo respons√°vel pelas comunica√ß√µes (servi√ßos) entre o servidor API e o n√≥. A base √© um IPtables para n√≥s. Usu√°rios mais experientes podem instalar outros kube-proxies de outros fornecedores.
* **Container Sidecar**: Os containers Sidecar s√£o os containers que devem ser executados juntamente com o cont√™iner principal no pod. Este padr√£o de sidecar estende e aprimora a funcionalidade dos cont√™ineres atuais sem alter√°-los. Atualmente, sabemos que usamos a tecnologia de cont√™iner para envolver todas as depend√™ncias para que o aplicativo seja executado em qualquer lugar. Um cont√™iner faz apenas uma coisa e faz essa coisa muito bem.
* **Processo Master:**
  * **Api Server:** √â a maneira como os usu√°rios e os pods usam para se comunicar com o processo master. Somente solicita√ß√µes autenticadas devem ser permitidas.
  * **Scheduler**: O agendamento refere-se a garantir que os pods sejam correspondidos aos n√≥s para que o Kubelet possa execut√°-los. Ele tem intelig√™ncia suficiente para decidir qual n√≥ tem mais recursos dispon√≠veis e atribuir o novo pod a ele. Observe que o agendador n√£o inicia novos pods, ele apenas se comunica com o processo Kubelet em execu√ß√£o dentro do n√≥, que iniciar√° o novo pod.
  * **Kube Controller Manager**: Ele verifica recursos como conjuntos de r√©plicas ou implanta√ß√µes para verificar se, por exemplo, o n√∫mero correto de pods ou n√≥s est√° em execu√ß√£o. Caso um pod esteja faltando, ele se comunicar√° com o agendador para iniciar um novo. Ele controla a replica√ß√£o, tokens e servi√ßos de conta para a API.
  * **etcd**: Armazenamento de dados, persistente, consistente e distribu√≠do. √â o banco de dados do Kubernetes e o armazenamento de chave-valor onde ele mant√©m o estado completo dos clusters (cada altera√ß√£o √© registrada aqui). Componentes como o Agendador ou o Gerenciador de controladores dependem desses dados para saber quais altera√ß√µes ocorreram (recursos dispon√≠veis dos n√≥s, n√∫mero de pods em execu√ß√£o...)
* **Gerenciador de controladores em nuvem**: √â o controlador espec√≠fico para controles de fluxo e aplicativos, ou seja, se voc√™ tiver clusters na AWS ou no OpenStack.

Observe que, como pode haver v√°rios n√≥s (executando v√°rios pods), tamb√©m pode haver v√°rios processos mestre, cujo acesso ao servidor API √© balanceado e seu etcd sincronizado.

**Volumes:**

Quando um pod cria dados que n√£o devem ser perdidos quando o pod desaparecer, eles devem ser armazenados em um volume f√≠sico. **O Kubernetes permite anexar um volume a um pod para persistir os dados**. O volume pode estar na m√°quina local ou em um **armazenamento remoto**. Se voc√™ estiver executando pods em diferentes n√≥s f√≠sicos, dever√° usar um armazenamento remoto para que todos os pods possam acess√°-lo.

**Outras configura√ß√µes:**

* **ConfigMap**: Voc√™ pode configurar **URLs** para acessar servi√ßos. O pod obter√° dados daqui para saber como se comunicar com o restante dos servi√ßos (pods). Observe que este n√£o √© o local recomendado para salvar credenciais!
* **Secret**: Este √© o local para **armazenar dados secretos** como senhas, chaves de API... codificadas em B64. O pod poder√° acessar esses dados para usar as credenciais necess√°rias.
* **Implanta√ß√µes**: Aqui √© onde os componentes a serem executados pelo Kubernetes s√£o indicados. Um usu√°rio geralmente n√£o trabalhar√° diretamente com pods, os pods s√£o abstra√≠dos em **ReplicaSets** (n√∫mero de pods id√™nticos replicados), que s√£o executados por meio de implanta√ß√µes. Observe que as implanta√ß√µes s√£o para aplicativos **sem estado**. A configura√ß√£o m√≠nima para uma implanta√ß√£o √© o nome e a imagem a serem executados.
* **StatefulSet**: Este componente √© especificamente destinado a aplicativos como **bancos de dados** que precisam **acessar o mesmo armazenamento**.
* **Ingress**: Esta √© a configura√ß√£o que √© usada para **expor o aplicativo publicamente com uma URL**. Observe que isso tamb√©m pode ser feito usando servi√ßos externos, mas esta √© a maneira correta de expor o aplicativo.
  * Se voc√™ implementar um Ingress, precisar√° criar **Controladores de Ingress**. O Controlador de Ingress √© um **pod** que ser√° o ponto de extremidade que receber√° as solicita√ß√µes e verificar√° e balancear√° as cargas para os servi√ßos. o controlador de ingress **enviar√° a solicita√ß√£o com base nas regras de ingress configuradas**. Observe que as regras de ingress podem apontar para caminhos diferentes ou at√© subdom√≠nios para diferentes servi√ßos internos do Kubernetes.
    * Uma pr√°tica de seguran√ßa melhor seria usar um balanceador de carga em nuvem ou um servidor proxy como ponto de entrada para n√£o ter nenhuma parte do cluster Kubernetes exposta.
    * Quando uma solicita√ß√£o que n√£o corresponde a nenhuma regra de ingress √© recebida, o controlador de ingress a direcionar√° para o "**Backend padr√£o**". Voc√™ pode `descrever` o controlador de ingress para obter o endere√ßo desse par√¢metro.
    * `minikube addons enable ingress`

### Infraestrutura PKI - Autoridade de Certifica√ß√£o CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* O CA √© a raiz confi√°vel para todos os certificados dentro do cluster.
* Permite que os componentes se validem entre si.
* Todos os certificados do cluster s√£o assinados pelo CA.
* ETCd tem seu pr√≥prio certificado.
* tipos:
  * certificado do servidor API.
  * certificado do kubelet.
  * certificado do agendador.
## A√ß√µes B√°sicas

### Minikube

**Minikube** pode ser usado para realizar alguns **testes r√°pidos** no kubernetes sem precisar implantar um ambiente completo do kubernetes. Ele executar√° os processos de mestre e n√≥ em uma √∫nica m√°quina. Minikube usar√° o virtualbox para executar o n√≥. Veja [**aqui como instal√°-lo**](https://minikube.sigs.k8s.io/docs/start/).

```
$ minikube start
üòÑ  minikube v1.19.0 on Ubuntu 20.04
‚ú®  Automatically selected the virtualbox driver. Other choices: none, ssh
üíø  Downloading VM boot image ...
    > minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
    > minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
üëç  Starting control plane node minikube in cluster minikube
üíæ  Downloading Kubernetes v1.20.2 preload ...
    > preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
üî•  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
üê≥  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
    ‚ñ™ Generating certificates and keys ...
    ‚ñ™ Booting up control plane ...
    ‚ñ™ Configuring RBAC rules ...
üîé  Verifying Kubernetes components...
    ‚ñ™ Using image gcr.io/k8s-minikube/storage-provisioner:v5
üåü  Enabled addons: storage-provisioner, default-storageclass
üèÑ  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(Este comando abrir√° seu navegador para acessar a porta exposta do servi√ßo)

$ minikube delete
üî•  Deleting "minikube" in virtualbox ...
üíÄ  Removed all traces of the "minikube" cluster
```

### Conceitos B√°sicos do Kubectl

**`Kubectl`** √© a ferramenta de linha de comando para clusters kubernetes. Ele se comunica com o servidor Api do processo mestre para executar a√ß√µes no kubernetes ou para solicitar dados.

```bash
kubectl version #Obter a vers√£o do cliente e do servidor
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Acesse a configura√ß√£o do deployment e modifique-a
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Obtenha os logs do pod para depura√ß√£o (a sa√≠da do cont√™iner docker em execu√ß√£o)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Implantar a partir do arquivo de configura√ß√£o
kubectl apply -f deployment.yml
```

### Painel do Minikube

O painel permite que voc√™ veja mais facilmente o que o minikube est√° executando, voc√™ pode encontrar a URL para acess√°-lo em:

```
minikube dashboard --url


üîå  Enabling dashboard ...
    ‚ñ™ Using image kubernetesui/dashboard:v2.3.1
    ‚ñ™ Using image kubernetesui/metrics-scraper:v1.0.7
ü§î  Verifying dashboard health ...
üöÄ  Launching proxy ...
ü§î  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```

### Exemplos de arquivos de configura√ß√£o YAML

Cada arquivo de configura√ß√£o tem 3 partes: **metadata**, **specification** (o que precisa ser lan√ßado), **status** (estado desejado).\
Dentro da especifica√ß√£o do arquivo de configura√ß√£o de implanta√ß√£o, voc√™ pode encontrar o modelo definido com uma nova estrutura de configura√ß√£o definindo a imagem a ser executada:

**Exemplo de implanta√ß√£o + servi√ßo declarado no mesmo arquivo de configura√ß√£o (de** [**aqui**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Como um servi√ßo geralmente est√° relacionado a uma implanta√ß√£o, √© poss√≠vel declarar ambos no mesmo arquivo de configura√ß√£o (o servi√ßo declarado nesta configura√ß√£o s√≥ √© acess√≠vel internamente):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mongodb-deployment
  labels:
    app: mongodb
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo
        ports:
        - containerPort: 27017
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-username
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom: 
            secretKeyRef:
              name: mongodb-secret
              key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
  name: mongodb-service
spec:
  selector:
    app: mongodb
  ports:
    - protocol: TCP
      port: 27017
      targetPort: 27017
```

**Exemplo de configura√ß√£o de servi√ßo externo**

Este servi√ßo ser√° acess√≠vel externamente (verifique os atributos `nodePort` e `type: LoadBlancer`):

```yaml
---
apiVersion: v1
kind: Service
metadata:
  name: mongo-express-service
spec:
  selector:
    app: mongo-express
  type: LoadBalancer
  ports:
    - protocol: TCP
      port: 8081
      targetPort: 8081
### Helm

Helm √© o **gerenciador de pacotes** para Kubernetes. Ele permite empacotar arquivos YAML e distribu√≠-los em reposit√≥rios p√∫blicos e privados. Esses pacotes s√£o chamados de **Helm Charts**.

```
helm search <palavra-chave>
```

Helm tamb√©m √© um mecanismo de modelo que permite gerar arquivos de configura√ß√£o com vari√°veis:

## Segredos do Kubernetes

Um **Segredo** √© um objeto que **cont√©m dados sens√≠veis** como uma senha, um token ou uma chave. Essas informa√ß√µes podem ser colocadas em uma especifica√ß√£o de Pod ou em uma imagem. Os usu√°rios podem criar segredos e o sistema tamb√©m cria segredos. O nome de um objeto Secret deve ser um **nome de subdom√≠nio DNS v√°lido**. Leia aqui [a documenta√ß√£o oficial](https://kubernetes.io/docs/concepts/configuration/secret/).

Segredos podem ser coisas como:

* Chaves API, SSH.
* Tokens OAuth.
* Credenciais, senhas (texto simples ou b64 + criptografia).
* Informa√ß√µes ou coment√°rios.
* C√≥digo de conex√£o de banco de dados, strings....

Existem diferentes tipos de segredos no Kubernetes

| Tipo Incorporado                     | Uso                                       |
| ----------------------------------- | ----------------------------------------- |
| **Opaco**                           | **dados definidos pelo usu√°rio arbitr√°rios (padr√£o)** |
| kubernetes.io/service-account-token | token de conta de servi√ßo                 |
| kubernetes.io/dockercfg             | arquivo \~/.dockercfg serializado         |
| kubernetes.io/dockerconfigjson      | arquivo \~/.docker/config.json serializado |
| kubernetes.io/basic-auth            | credenciais para autentica√ß√£o b√°sica      |
| kubernetes.io/ssh-auth              | credenciais para autentica√ß√£o SSH         |
| kubernetes.io/tls                   | dados para um cliente ou servidor TLS     |
| bootstrap.kubernetes.io/token       | dados de token de inicializa√ß√£o           |

{% hint style="info" %}
**O tipo Opaque √© o padr√£o, o par chave-valor t√≠pico definido pelos usu√°rios.**
{% endhint %}

**Como os segredos funcionam:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

O arquivo de configura√ß√£o a seguir define um **segredo** chamado `mysecret` com 2 pares de chave-valor `username: YWRtaW4=` e `password: MWYyZDFlMmU2N2Rm`. Ele tamb√©m define um **pod** chamado `secretpod` que ter√° o `username` e `password` definidos em `mysecret` expostos nas **vari√°veis de ambiente** `SECRET_USERNAME` e `SECRET_PASSWORD`. Ele tamb√©m ir√° **montar** o segredo `username` dentro de `mysecret` no caminho `/etc/foo/my-group/my-username` com permiss√µes `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
  name: secretpod
spec:
  containers:
  - name: secretpod
    image: nginx
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
  restartPolicy: Never
  volumes:
  - name: foo
    secret:
      secretName: mysecret
      items:
      - key: username
        path: my-group/my-username
        mode: 0640
```
{% endcode %}

```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Aguarde at√© que o pod secretpod esteja em execu√ß√£o
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```

### Segredos no etcd <a href="#discover-secrets-in-etcd" id="discover-secrets-in-etcd"></a>

**etcd** √© um armazenamento de chave-valor consistente e altamente dispon√≠vel usado como armazenamento de suporte do Kubernetes para todos os dados do cluster. Vamos acessar os segredos armazenados no etcd:

```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```

Voc√™ ver√° que os certificados, chaves e URLs est√£o localizados no FS. Depois de obt√™-los, voc√™ poder√° se conectar ao etcd.

```bash
#ETCDCTL_API=3 etcdctl --cert <caminho para client.crt> --key <caminho para client.ket> --cacert <caminho para CA.cert> endpoint=[<ip:porta>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```

Depois de estabelecer a comunica√ß√£o, voc√™ poder√° obter os segredos:

```bash
#ETCDCTL_API=3 etcdctl --cert <caminho para client.crt> --key <caminho para client.ket> --cacert <caminho para CA.cert> endpoint=[<ip:porta>] get <caminho/para/segredo>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```

**Adicionando criptografia ao ETCD**

Por padr√£o, todos os segredos s√£o **armazenados em texto plano** dentro do etcd, a menos que voc√™ aplique uma camada de criptografia. O exemplo a seguir √© baseado em [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - aescbc:
        keys:
        - name: key1
          secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMX