# Kubernetes Temelleri

## Kubernetes Temelleri

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahramana kadar AWS hackleme Ã¶ÄŸrenin<strong>!</strong></summary>

HackTricks'Ä± desteklemenin diÄŸer yollarÄ±:

* Åirketinizi HackTricks'te **reklamÄ±nÄ±zÄ± gÃ¶rmek** veya **HackTricks'i PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARI**](https://github.com/sponsors/carlospolop)'na gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nleri**](https://peass.creator-spring.com)'ni edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki Ã¶zel [**NFT'ler**](https://opensea.io/collection/the-peass-family)'i keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarÄ±na **PR gÃ¶ndererek paylaÅŸÄ±n**.

</details>

**Bu sayfanÄ±n orijinal yazarÄ±** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(orijinal gÃ¶nderisini** [**buradan**](https://sickrov.github.io)** okuyun)**

## MimarlÄ±k ve Temeller

### Kubernetes ne yapar?

* Bir konteyneri/konteynerleri bir konteyner motorunda Ã§alÄ±ÅŸtÄ±rmaya izin verir.
* Konteyner gÃ¶revlerini verimli bir ÅŸekilde planlar.
* Konteynerleri canlÄ± tutar.
* Konteyner iletiÅŸimine izin verir.
* DaÄŸÄ±tÄ±m tekniklerine izin verir.
* Bilgi hacimlerini yÃ¶netir.

### MimarlÄ±k

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **DÃ¼ÄŸÃ¼m (Node)**: Pod veya pod'larla birlikte Ã§alÄ±ÅŸan iÅŸletim sistemi.
* **Pod**: Bir konteynerin veya birden fazla konteynerin etrafÄ±nÄ± saran bir kapsayÄ±cÄ±dÄ±r. Bir pod yalnÄ±zca bir uygulama iÃ§ermelidir (bu nedenle genellikle bir pod yalnÄ±zca 1 konteyner Ã§alÄ±ÅŸtÄ±rÄ±r). Pod, Kubernetes'in Ã§alÄ±ÅŸan konteyner teknolojisini soyutlama ÅŸeklidir.
* **Servis (Service)**: Her pod'un dÃ¼ÄŸÃ¼mÃ¼n iÃ§ aÄŸ aralÄ±ÄŸÄ±ndan 1 dahili **IP adresi** vardÄ±r. Bununla birlikte, bir servis aracÄ±lÄ±ÄŸÄ±yla da dÄ±ÅŸa aÃ§Ä±labilir. **Servisin de bir IP adresi vardÄ±r** ve amacÄ± pod'lar arasÄ±ndaki iletiÅŸimi sÃ¼rdÃ¼rmektir, bÃ¶ylece biri Ã¶lÃ¼rse **yeni bir yerine geÃ§en pod** (farklÄ± bir dahili IP ile) **servisin aynÄ± IP'sinde eriÅŸilebilir** hale gelir. Ä°Ã§sel veya harici olarak yapÄ±landÄ±rÄ±labilir. Servis, 2 pod'un aynÄ± servise baÄŸlandÄ±ÄŸÄ±nda bir **yÃ¼k dengeleyici olarak da hareket eder**.\
Bir **servis oluÅŸturulduÄŸunda**, her servisin uÃ§ noktalarÄ±nÄ± Ã§alÄ±ÅŸtÄ±rarak bulabilirsiniz `kubectl get endpoints`
* **Kubelet**: Ana dÃ¼ÄŸem ajanÄ±dÄ±r. DÃ¼ÄŸÃ¼m ve kubectl arasÄ±nda iletiÅŸim kurar ve yalnÄ±zca pod'larÄ± (API sunucusu aracÄ±lÄ±ÄŸÄ±yla) Ã§alÄ±ÅŸtÄ±rabilir. Kubelet, Kubernetes tarafÄ±ndan oluÅŸturulmayan konteynerleri yÃ¶netmez.
* **Kube-proxy**: apisunucusu ve dÃ¼ÄŸem arasÄ±ndaki iletiÅŸim (servisler) ile ilgilenen hizmettir. Temel olarak dÃ¼ÄŸemler iÃ§in bir IPtables'tÄ±r. Deneyimli kullanÄ±cÄ±lar baÅŸka satÄ±cÄ±lardan kube-proxy'ler kurabilirler.
* **Sidecar konteyner (Sidecar container)**: Sidecar konteynerler, ana konteynerle birlikte pod'da Ã§alÄ±ÅŸmasÄ± gereken konteynerlerdir. Bu yan konteyner modeli, mevcut konteynerlerin iÅŸlevselliÄŸini geniÅŸletir ve geliÅŸtirirken onlarÄ± deÄŸiÅŸtirmez. GÃ¼nÃ¼mÃ¼zde, uygulamanÄ±n herhangi bir yerde Ã§alÄ±ÅŸabilmesi iÃ§in tÃ¼m baÄŸÄ±mlÄ±lÄ±klarÄ± sarmak iÃ§in konteyner teknolojisini kullandÄ±ÄŸÄ±mÄ±zÄ± biliyoruz. Bir konteyner yalnÄ±zca bir ÅŸey yapar ve bu iÅŸi Ã§ok iyi yapar.
* **Ana iÅŸlem (Master process)**:
* **API Sunucusu (Api Server)**: KullanÄ±cÄ±larÄ±n ve pod'larÄ±n ana iÅŸlemle iletiÅŸim kurmak iÃ§in kullandÄ±ÄŸÄ± yoldur. YalnÄ±zca kimlik doÄŸrulamasÄ± yapÄ±lmÄ±ÅŸ isteklere izin verilmelidir.
* **PlanlayÄ±cÄ± (Scheduler)**: Planlama, Pod'larÄ±n Kubelet tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±labilmesi iÃ§in Pod'larÄ±n DÃ¼ÄŸemlere eÅŸleÅŸtirildiÄŸinden emin olmayÄ± ifade eder. Yeni bir pod baÅŸlatmak iÃ§in hangi dÃ¼ÄŸÃ¼mÃ¼n daha fazla kullanÄ±labilir kaynaÄŸa sahip olduÄŸuna karar vermek iÃ§in yeterli zekaya sahiptir. PlanlayÄ±cÄ± yeni pod'larÄ± baÅŸlatmaz, yalnÄ±zca dÃ¼ÄŸem iÃ§inde Ã§alÄ±ÅŸan Kubelet iÅŸlemiyle iletiÅŸim kurar ve yeni pod'Ä± baÅŸlatÄ±r.
* **Kube Denetleyici YÃ¶neticisi (Kube Controller Manager)**: Replica setler veya daÄŸÄ±tÄ±mlar gibi kaynaklarÄ± kontrol eder ve Ã¶rneÄŸin doÄŸru sayÄ±da pod veya dÃ¼ÄŸem Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in kontrol eder. Bir pod eksikse, yeni bir pod baÅŸlatmak iÃ§in planlayÄ±cÄ±yla iletiÅŸim kurar. API'ya replikasyon, tokenlar ve hesap hizmetleri kontrol eder.
* **etcd**: Veri depolama, kalÄ±cÄ±, tutarlÄ± ve daÄŸÄ±tÄ±lmÄ±ÅŸtÄ±r. Kubernetes'in veritabanÄ±dÄ±r ve kÃ¼me durumunun tamamÄ±nÄ± (her deÄŸiÅŸiklik burada kaydedilir) tutan anahtar-deÄŸer depolama alanÄ±dÄ±r. PlanlayÄ±cÄ± veya Denetleyici yÃ¶neticisi gibi bileÅŸenler, hangi deÄŸiÅŸikliklerin meydana geldiÄŸini bilmek iÃ§in bu verilere baÄŸÄ±mlÄ±dÄ±r (dÃ¼ÄŸemlerin kullanÄ±labilir kaynaklarÄ±, Ã§alÄ±ÅŸan pod'larÄ±n sayÄ±sÄ±...).
* **Bulut denetleyici yÃ¶neticisi (Cloud controller manager)**: AkÄ±ÅŸ kontrolleri ve uygulamalar iÃ§in Ã¶zel denetleyicidir, Ã¶rneÄŸin AWS veya OpenStack'ta kÃ¼meniz varsa.

Bir dÃ¼ÄŸemde (birkaÃ§ pod Ã§alÄ±ÅŸtÄ±ran birkaÃ§ dÃ¼ÄŸem) birden fazla ana iÅŸlem olabileceÄŸi gibi, Api sunucusuna eriÅŸimleri yÃ¼k dengelemeli ve etcd'leri senkronize edilebilir.

**Hacimler (Volumes):**

Bir pod, kaybolmasÄ± durumunda kaybolmamasÄ± gereken veri oluÅŸturduÄŸunda, veri bir fiziksel hacme depolanmalÄ±dÄ±r. **Kubernetes, veriyi korumak iÃ§in bir pod'a bir hacim eklemeye izin verir**. Hacim yerel makinede veya **uzak bir depolama alanÄ±nda** olabilir. FarklÄ± fiziksel dÃ¼ÄŸemlerde pod'lar Ã§alÄ±ÅŸtÄ±rÄ±yorsanÄ±z, tÃ¼m pod'larÄ±n buna eriÅŸebilmesi iÃ§in uzak bir depolama alanÄ± kullanmalÄ±sÄ±nÄ±z.

**DiÄŸer yapÄ±landÄ±rmalar:**

* **ConfigMap**: Servislere eriÅŸmek iÃ§in **URL'leri** yapÄ±landÄ±rabilirsiniz. Pod, diÄŸer servislerle (pod'larla) iletiÅŸim kurmak iÃ§in buradan veri alÄ±r. Bununla birlikte, bu kimlik bilgilerini kaydetmek iÃ§in Ã¶nerilen yer deÄŸildir!
* **Secret**: Åifreler, API anahtarlarÄ± gibi **gizli verileri** saklamak iÃ§in kullanÄ±lan yerdir. Pod, gerekli kimlik bilgilerini kullanmak iÃ§in bu verilere eriÅŸebilir.
* **DaÄŸÄ±tÄ±mlar (Deployments)**: Kubernetes tarafÄ±ndan Ã§alÄ±ÅŸtÄ±rÄ±lacak bileÅŸenlerin belirtildiÄŸi yerdir. Bir kullanÄ±cÄ± genellikle doÄŸrudan pod'larla Ã§alÄ±ÅŸmaz, pod'lar **ReplicaSet'lerde** (Ã§oÄŸaltÄ±lan aynÄ± pod'larÄ±n sayÄ±sÄ±) soyutlanÄ±r ve daÄŸÄ±tÄ±mlar aracÄ±lÄ±ÄŸÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. DaÄŸÄ±tÄ±mlar genellikle **durumsuz (stateless)** uygulamalar iÃ§indir. Bir daÄŸÄ±tÄ±m iÃ§in minimum yapÄ±landÄ±rma adÄ± ve Ã§alÄ±ÅŸtÄ±rÄ±lacak gÃ¶rÃ¼ntÃ¼dÃ¼r.
* **StatefulSet**: Bu bileÅŸen, **verilere eriÅŸmesi gereken veritabanlarÄ±** gibi uygulamalar iÃ§in Ã¶zel olarak tasarlan
### PKI altyapÄ±sÄ± - Sertifika Otoritesi CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA, kÃ¼me iÃ§indeki tÃ¼m sertifikalar iÃ§in gÃ¼venilir kÃ¶ktÃ¼r.
* BileÅŸenlerin birbirini doÄŸrulamasÄ±na izin verir.
* TÃ¼m kÃ¼me sertifikalarÄ± CA tarafÄ±ndan imzalanÄ±r.
* ETCd'nin kendi sertifikasÄ± vardÄ±r.
* tÃ¼rleri:
* apiserver sertifikasÄ±.
* kubelet sertifikasÄ±.
* scheduler sertifikasÄ±.

## Temel Eylemler

### Minikube

**Minikube**, bir tÃ¼m kubernetes ortamÄ± daÄŸÄ±tmadan kubernetes Ã¼zerinde bazÄ± **hÄ±zlÄ± testler** yapmak iÃ§in kullanÄ±labilir. **Master ve node iÅŸlemlerini tek bir makinede** Ã§alÄ±ÅŸtÄ±racaktÄ±r. Minikube, node'u Ã§alÄ±ÅŸtÄ±rmak iÃ§in virtualbox kullanacaktÄ±r. [**Burada nasÄ±l kurulacaÄŸÄ±nÄ±**](https://minikube.sigs.k8s.io/docs/start/) gÃ¶rebilirsiniz.
```
$ minikube start
ğŸ˜„  minikube v1.19.0 on Ubuntu 20.04
âœ¨  Automatically selected the virtualbox driver. Other choices: none, ssh
ğŸ’¿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ’¾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
ğŸ”¥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
â–ª Generating certificates and keys ...
â–ª Booting up control plane ...
â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
ğŸ”¥  Deleting "minikube" in virtualbox ...
ğŸ’€  Removed all traces of the "minikube" cluster
```
### Kubectl Temelleri

**`Kubectl`**, kubernetes kÃ¼melelerinde kullanÄ±lan komut satÄ±rÄ± aracÄ±dÄ±r. Kubernetes'te iÅŸlemler gerÃ§ekleÅŸtirmek veya veri istemek iÃ§in ana iÅŸlemciye ait Api sunucusuyla iletiÅŸim kurar.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube Kontrol Paneli

Kontrol paneli, minikube'nin Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ± ÅŸeyleri daha kolay gÃ¶rebilmenizi saÄŸlar, eriÅŸmek iÃ§in URL'yi aÅŸaÄŸÄ±da bulabilirsiniz:
```
minikube dashboard --url


ğŸ”Œ  Enabling dashboard ...
â–ª Using image kubernetesui/dashboard:v2.3.1
â–ª Using image kubernetesui/metrics-scraper:v1.0.7
ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### YAML yapÄ±landÄ±rma dosyalarÄ± Ã¶rnekleri

Her yapÄ±landÄ±rma dosyasÄ± 3 bÃ¶lÃ¼mden oluÅŸur: **metadata**, **specification** (baÅŸlatÄ±lmasÄ± gereken ÅŸey), **status** (istenen durum).\
DaÄŸÄ±tÄ±m yapÄ±landÄ±rma dosyasÄ±nÄ±n Ã¶zellik bÃ¶lÃ¼mÃ¼nde, Ã§alÄ±ÅŸtÄ±rÄ±lacak gÃ¶rÃ¼ntÃ¼yÃ¼ tanÄ±mlayan yeni bir yapÄ±landÄ±rma yapÄ±sÄ±yla bir ÅŸablon bulunabilir:

**AynÄ± yapÄ±landÄ±rma dosyasÄ±nda bildirilen DaÄŸÄ±tÄ±m + Hizmet Ã¶rneÄŸi (buradan alÄ±nmÄ±ÅŸtÄ±r** [**buradan**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

Bir hizmet genellikle bir daÄŸÄ±tÄ±mla iliÅŸkilidir, bu nedenle her ikisi de aynÄ± yapÄ±landÄ±rma dosyasÄ±nda bildirilebilir (bu yapÄ±landÄ±rmada bildirilen hizmet yalnÄ±zca dahili olarak eriÅŸilebilir):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**DÄ±ÅŸ servis yapÄ±landÄ±rmasÄ±nÄ±n Ã¶rneÄŸi**

Bu servis harici olarak eriÅŸilebilir olacak (`nodePort` ve `type: LoadBalancer` Ã¶zniteliklerini kontrol edin):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Bu test iÃ§in kullanÄ±ÅŸlÄ±dÄ±r, ancak Ã¼retim iÃ§in yalnÄ±zca dahili hizmetlere ve uygulamayÄ± aÃ§Ä±ÄŸa Ã§Ä±karmak iÃ§in bir Ingress'e sahip olmanÄ±z gerekmektedir.
{% endhint %}

**Ingress yapÄ±landÄ±rma dosyasÄ± Ã¶rneÄŸi**

Bu, uygulamayÄ± `http://dashboard.com` adresinde aÃ§Ä±ÄŸa Ã§Ä±karacaktÄ±r.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Gizli yapÄ±landÄ±rma dosyasÄ± Ã¶rneÄŸi**

Åifrelerin B64 ile kodlandÄ±ÄŸÄ±na dikkat edin (bu gÃ¼venli deÄŸildir!).
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**ConfigMap Ã–rneÄŸi**

**ConfigMap**, pod'larÄ±n diÄŸer hizmetlere nasÄ±l eriÅŸeceÄŸini ve bulacaÄŸÄ±nÄ± bilmesi iÃ§in verilen yapÄ±landÄ±rmadÄ±r. Bu durumda, her bir pod, `mongodb-service` adÄ±nÄ±n iletiÅŸim kurabilecekleri bir pod'un adresi olduÄŸunu bilecektir (bu pod bir mongodb Ã§alÄ±ÅŸtÄ±racaktÄ±r):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
ArdÄ±ndan, bir **daÄŸÄ±tÄ±m yapÄ±landÄ±rmasÄ±** iÃ§inde bu adres aÅŸaÄŸÄ±daki ÅŸekilde belirtilebilir, bÃ¶ylece pod'un env'sine yÃ¼klenir:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Depolama yapÄ±landÄ±rmasÄ± Ã¶rneÄŸi**

Depolama yapÄ±landÄ±rmasÄ± yaml dosyalarÄ±nÄ±n farklÄ± Ã¶rneklerini [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes) adresinde bulabilirsiniz.\
**Dikkat: Volumeler namespace'lerin iÃ§inde deÄŸildir**

### Namespace'ler

Kubernetes, aynÄ± fiziksel kÃ¼me tarafÄ±ndan desteklenen **Ã§oklu sanal kÃ¼meleri** destekler. Bu sanal kÃ¼meler **namespace** olarak adlandÄ±rÄ±lÄ±r. Bunlar, birÃ§ok kullanÄ±cÄ±nÄ±n birden Ã§ok takÄ±ma veya projeye yayÄ±ldÄ±ÄŸÄ± ortamlarda kullanÄ±lmak Ã¼zere tasarlanmÄ±ÅŸtÄ±r. BirkaÃ§ ila onlarca kullanÄ±cÄ±nÄ±n bulunduÄŸu kÃ¼melere sahipseniz, namespace oluÅŸturmanÄ±za veya dÃ¼ÅŸÃ¼nmenize gerek yoktur. Sadece kubernetes'te daÄŸÄ±tÄ±lan her uygulama parÃ§asÄ±nÄ±n daha iyi bir kontrol ve dÃ¼zenlemesine sahip olmak iÃ§in namespace'leri kullanmaya baÅŸlamalÄ±sÄ±nÄ±z.

Namespace'ler, isimler iÃ§in bir kapsam saÄŸlar. KaynaklarÄ±n isimleri bir namespace iÃ§inde benzersiz olmalÄ±dÄ±r, ancak namespace'ler arasÄ±nda benzersiz olmasÄ± gerekmez. Namespace'ler birbirinin iÃ§ine yerleÅŸtirilemez ve **her** Kubernetes **kaynaÄŸÄ±** yalnÄ±zca **bir** **namespace** iÃ§inde olabilir.

Minikube kullanÄ±yorsanÄ±z varsayÄ±lan olarak 4 namespace bulunur:
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: KullanÄ±cÄ±lar tarafÄ±ndan kullanÄ±lmak iÃ§in deÄŸil ve dokunmamanÄ±z gereken bir alan. Bu alan, master ve kubectl iÅŸlemleri iÃ§in kullanÄ±lÄ±r.
* **kube-public**: Genel olarak eriÅŸilebilir verileri iÃ§erir. KÃ¼me bilgilerini iÃ§eren bir configmap iÃ§erir.
* **kube-node-lease**: Bir dÃ¼ÄŸÃ¼mÃ¼n kullanÄ±labilirliÄŸini belirler.
* **default**: KullanÄ±cÄ±nÄ±n kaynak oluÅŸturmak iÃ§in kullanacaÄŸÄ± ad alanÄ±.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
UnutmayÄ±n ki Ã§oÄŸu Kubernetes kaynaÄŸÄ± (Ã¶rneÄŸin pod'lar, servisler, replikasyon denetleyicileri ve diÄŸerleri) bir namespace iÃ§indedir. Bununla birlikte, namespace kaynaklarÄ± ve dÃ¼ÅŸÃ¼k seviye kaynaklar gibi diÄŸer kaynaklar, Ã¶rneÄŸin dÃ¼ÄŸÃ¼mler ve kalÄ±cÄ± birimler bir namespace iÃ§inde deÄŸildir. Hangi Kubernetes kaynaklarÄ±nÄ±n bir namespace iÃ§inde olduÄŸunu ve olmadÄ±ÄŸÄ±nÄ± gÃ¶rmek iÃ§in:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

TÃ¼m sonraki kubectl komutlarÄ± iÃ§in bu baÄŸlamda ad alanÄ±nÄ± kaydedebilirsiniz.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm, Kubernetes iÃ§in bir **paket yÃ¶neticisidir**. YAML dosyalarÄ±nÄ± paketleyip, bunlarÄ± genel ve Ã¶zel depolarda daÄŸÄ±tmaya olanak saÄŸlar. Bu paketlere **Helm Charts** denir.
```
helm search <keyword>
```
Helm ayrÄ±ca deÄŸiÅŸkenlerle yapÄ±landÄ±rma dosyalarÄ± oluÅŸturmaya izin veren bir ÅŸablon motorudur:

## Kubernetes sÄ±rlarÄ±

Bir **Secret**, bir ÅŸifre, bir belirteÃ§ veya bir anahtar gibi **hassas verileri iÃ§eren** bir nesnedir. Bu tÃ¼r bilgiler aksi takdirde bir Pod tanÄ±mÄ±nda veya bir gÃ¶rÃ¼ntÃ¼de olabilir. KullanÄ±cÄ±lar Secrets oluÅŸturabilir ve sistem de Secrets oluÅŸturur. Bir Secret nesnesinin adÄ± geÃ§erli bir **DNS alt alan adÄ±** olmalÄ±dÄ±r. [Resmi belgelere](https://kubernetes.io/docs/concepts/configuration/secret/) buradan ulaÅŸabilirsiniz.

Secrets ÅŸunlar olabilir:

* API, SSH AnahtarlarÄ±.
* OAuth belirteÃ§leri.
* Kimlik bilgileri, Parolalar (dÃ¼z metin veya b64 + ÅŸifreleme).
* Bilgi veya yorumlar.
* VeritabanÄ± baÄŸlantÄ± kodu, dizeleri... .

Kubernetes'te farklÄ± tÃ¼rde sÄ±rlar vardÄ±r

| Dahili TÃ¼r                          | KullanÄ±m                                   |
| ----------------------------------- | ----------------------------------------- |
| **Opaque**                          | **key-value Ã§ifti (VarsayÄ±lan)**           |
| kubernetes.io/service-account-token | hizmet hesabÄ± belirteci                    |
| kubernetes.io/dockercfg             | serileÅŸtirilmiÅŸ \~/.dockercfg dosyasÄ±      |
| kubernetes.io/dockerconfigjson      | serileÅŸtirilmiÅŸ \~/.docker/config.json dosyasÄ± |
| kubernetes.io/basic-auth            | temel kimlik doÄŸrulama iÃ§in kimlik bilgileri |
| kubernetes.io/ssh-auth              | SSH kimlik doÄŸrulama iÃ§in kimlik bilgileri  |
| kubernetes.io/tls                   | bir TLS istemci veya sunucu iÃ§in veri      |
| bootstrap.kubernetes.io/token       | baÅŸlatma belirteci verisi                  |

{% hint style="info" %}
**Opaque tÃ¼rÃ¼ varsayÄ±lan olanÄ±dÄ±r, kullanÄ±cÄ±lar tarafÄ±ndan tanÄ±mlanan tipik bir key-value Ã§iftidir.**
{% endhint %}

**SÄ±rlar nasÄ±l Ã§alÄ±ÅŸÄ±r:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

AÅŸaÄŸÄ±daki yapÄ±landÄ±rma dosyasÄ±, `mysecret` adÄ±nda `username: YWRtaW4=` ve `password: MWYyZDFlMmU2N2Rm` olmak Ã¼zere 2 key-value Ã§iftine sahip bir **secret** tanÄ±mlar. AyrÄ±ca, `secretpod` adÄ±nda bir **pod** tanÄ±mlar, bu pod `mysecret` iÃ§inde tanÄ±mlanan `username` ve `password`'u **Ã§evre deÄŸiÅŸkenleri** `SECRET_USERNAME` ve `SECRET_PASSWOR` olarak aÃ§Ä±ÄŸa Ã§Ä±karÄ±r. AyrÄ±ca, `username` sÄ±rrÄ±nÄ± `mysecret` iÃ§inde `/etc/foo/my-group/my-username` yoluna `0640` izinleriyle **mount** eder.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### etcd'teki SÄ±rlar <a href="#etcd-teki-sirlari-kesfet" id="etcd-teki-sirlari-kesfet"></a>

**etcd**, tÃ¼m kÃ¼me verileri iÃ§in Kubernetes'in destekleyici depolama olarak kullanÄ±lan tutarlÄ± ve yÃ¼ksek eriÅŸilebilir bir **anahtar-deÄŸer deposu**dur. Hadi etcd'de depolanan sÄ±rlara eriÅŸelim:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
SertifikalarÄ±n, anahtarlarÄ±n ve URL'lerin FS'de nerede bulunduÄŸunu gÃ¶receksiniz. Bunu aldÄ±ktan sonra etcd'ye baÄŸlanabileceksiniz.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Bir kez iletiÅŸim kurmayÄ± baÅŸardÄ±ÄŸÄ±nÄ±zda, sÄ±rlara eriÅŸebilirsiniz:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**ETCD'ye ÅŸifreleme eklemek**

VarsayÄ±lan olarak, tÃ¼m sÄ±rlar etcd iÃ§inde dÃ¼z metin olarak depolanÄ±r, ancak bir ÅŸifreleme katmanÄ± uygulamazsanÄ±z. AÅŸaÄŸÄ±daki Ã¶rnek, [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/) adresindeki belgeye dayanmaktadÄ±r.

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Bundan sonra, oluÅŸturulan yapÄ±landÄ±rma dosyasÄ±nÄ±n konumunu gÃ¶stermek iÃ§in `kube-apiserver` Ã¼zerinde `--encryption-provider-config` bayraÄŸÄ±nÄ± ayarlamanÄ±z gerekmektedir. `/etc/kubernetes/manifest/kube-apiserver.yaml` dosyasÄ±nÄ± dÃ¼zenleyebilir ve aÅŸaÄŸÄ±daki satÄ±rlarÄ± ekleyebilirsiniz:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
volumeMounts bÃ¶lÃ¼mÃ¼nde aÅŸaÄŸÄ± kaydÄ±rÄ±n:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
`volumeMounts` iÃ§inde aÅŸaÄŸÄ± kaydÄ±rÄ±n ve `hostPath`'e ulaÅŸÄ±n:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Veri ÅŸifrelenmesinin doÄŸrulanmasÄ±**

Veri, etcd'ye yazÄ±ldÄ±ÄŸÄ±nda ÅŸifrelenir. `kube-apiserver`'Ä±nÄ±zÄ± yeniden baÅŸlattÄ±ktan sonra, yeni oluÅŸturulan veya gÃ¼ncellenen herhangi bir gizli bilginin depolandÄ±ÄŸÄ±nda ÅŸifrelenmiÅŸ olmasÄ± gerekmektedir. Kontrol etmek iÃ§in `etcdctl` komut satÄ±rÄ± programÄ±nÄ± kullanarak gizli bilginizin iÃ§eriÄŸini alabilirsiniz.

1.  `default` ad alanÄ±nda `secret1` adÄ±nda yeni bir gizli bilgi oluÅŸturun:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2.  Etcd'den bu gizli bilgiyi okumak iÃ§in etcdctl komut satÄ±rÄ±nÄ± kullanÄ±n:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

`[...]`, etcd sunucusuna baÄŸlanmak iÃ§in ek argÃ¼manlar olmalÄ±dÄ±r.
3.  Depolanan gizli bilginin `k8s:enc:aescbc:v1:` ile baÅŸladÄ±ÄŸÄ±nÄ± doÄŸrulayÄ±n. Bu, `aescbc` saÄŸlayÄ±cÄ±sÄ±nÄ±n sonuÃ§ veriyi ÅŸifrelediÄŸini gÃ¶sterir.
4.  API aracÄ±lÄ±ÄŸÄ±yla alÄ±ndÄ±ÄŸÄ±nda gizli bilginin doÄŸru bir ÅŸekilde Ã§Ã¶zÃ¼mlendiÄŸini doÄŸrulayÄ±n:

```
kubectl describe secret secret1 -n default
```

`mykey: bXlkYXRh` ile eÅŸleÅŸmelidir, mydata kodlanmÄ±ÅŸtÄ±r, gizli bilgiyi tamamen Ã§Ã¶zmek iÃ§in [bir gizli bilgiyi Ã§Ã¶zme](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) baÄŸlantÄ±sÄ±na bakÄ±n.

**Gizli bilgiler yazÄ±lÄ±rken ÅŸifrelendiÄŸi iÃ§in, bir gizli bilgide gÃ¼ncelleme yapmak, iÃ§eriÄŸin ÅŸifrelenmesini saÄŸlar:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**Son ipuÃ§larÄ±:**

* SÄ±rlarÄ± FS'de tutmamaya Ã§alÄ±ÅŸÄ±n, onlarÄ± baÅŸka yerlerden alÄ±n.
* SÄ±rlarÄ±nÄ±za daha fazla koruma eklemek iÃ§in [https://www.vaultproject.io/](https://www.vaultproject.io)'ya gÃ¶z atÄ±n.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Referanslar

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sÄ±fÄ±rdan kahraman olmak iÃ§in AWS hackleme Ã¶ÄŸrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diÄŸer yollarÄ±:

* Åirketinizi HackTricks'te **reklamÄ±nÄ±zÄ± gÃ¶rmek** veya HackTricks'i **PDF olarak indirmek** iÃ§in [**ABONELÄ°K PLANLARINA**](https://github.com/sponsors/carlospolop) gÃ¶z atÄ±n!
* [**Resmi PEASS & HackTricks Ã¼rÃ¼nlerini**](https://peass.creator-spring.com) edinin
* Ã–zel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluÅŸan koleksiyonumuz [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'i keÅŸfedin
* ğŸ’¬ [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katÄ±lÄ±n** veya **Twitter** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR gÃ¶ndererek paylaÅŸÄ±n**.

</details>
