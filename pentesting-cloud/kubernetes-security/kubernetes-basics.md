# Osnove Kubernetesa

## Osnove Kubernetesa

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini podrÅ¡ke HackTricks-u:

* Ako Å¾elite videti **oglaÅ¡avanje vaÅ¡e kompanije na HackTricks-u** ili **preuzeti HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** me na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

**Originalni autor ove stranice je** [**Jorge**](https://www.linkedin.com/in/jorge-belmonte-a924b616b/) **(proÄitajte njegov originalni post** [**ovde**](https://sickrov.github.io)**)**

## Arhitektura i osnove

### Å ta radi Kubernetes?

* OmoguÄ‡ava pokretanje kontejnera u kontejnerskom okruÅ¾enju.
* Planiranje omoguÄ‡ava efikasno izvrÅ¡avanje kontejnera.
* OdrÅ¾ava kontejnere aktivnim.
* OmoguÄ‡ava komunikaciju izmeÄ‘u kontejnera.
* OmoguÄ‡ava tehnike implementacije.
* Upravlja obimom informacija.

### Arhitektura

![](https://sickrov.github.io/media/Screenshot-68.jpg)

* **ÄŒvor**: operativni sistem sa podom ili podovima.
* **Pod**: OmotaÄ oko jednog ili viÅ¡e kontejnera. Jedan pod treba da sadrÅ¾i samo jednu aplikaciju (tako da obiÄno jedan pod pokreÄ‡e samo 1 kontejner). Pod je naÄin na koji Kubernetes apstrahuje tehnologiju kontejnera koja se izvrÅ¡ava.
* **Servis**: Svaki pod ima 1 internu **IP adresu** iz interne opsega Ävora. MeÄ‘utim, moÅ¾e biti izloÅ¾en i putem servisa. Servis takoÄ‘e ima IP adresu i njegov cilj je odrÅ¾avanje komunikacije izmeÄ‘u podova, tako da ako jedan umre, **novi zamena** (sa drugom internom IP adresom) **Ä‡e biti dostupan** izloÅ¾en na **isto IP adrese servisa**. MoÅ¾e biti konfigurisan kao interni ili eksterni. Servis takoÄ‘e deluje kao **balanser optereÄ‡enja kada su 2 poda povezana** na isti servis.\
Kada se **kreira servis**, moÅ¾ete pronaÄ‡i krajnje taÄke svakog servisa pokretanjem `kubectl get endpoints`
* **Kubelet**: Primarni Ävorski agent. Komponenta koja uspostavlja komunikaciju izmeÄ‘u Ävora i kubectl-a i moÅ¾e pokretati samo podove (putem API servera). Kubelet ne upravlja kontejnerima koji nisu kreirani od strane Kubernetes-a.
* **Kube-proxy**: je servis koji je zaduÅ¾en za komunikaciju (servisi) izmeÄ‘u api servera i Ävora. Osnova su IPtables za Ävorove. Iskusniji korisnici mogu instalirati druge kube-proksije od drugih dobavljaÄa.
* **Sidecar kontejner**: Sidecar kontejneri su kontejneri koji treba da se pokreÄ‡u zajedno sa glavnim kontejnerom u podu. Ovaj sidecar obrazac proÅ¡iruje i poboljÅ¡ava funkcionalnost trenutnih kontejnera bez njihove promene. Danas znamo da koristimo tehnologiju kontejnera da bismo zapakovali sve zavisnosti kako bi aplikacija mogla da se pokrene bilo gde. Kontejner radi samo jednu stvar i to radi veoma dobro.
* **Glavni proces**:
* **API server**: NaÄin na koji korisnici i podovi komuniciraju sa glavnim procesom. Dozvoljeni su samo autentifikovani zahtevi.
* **Planer**: Planiranje se odnosi na to da se osigura da se podovi uparuju sa Ävorovima kako bi Kubelet mogao da ih pokrene. Ima dovoljno inteligencije da odluÄi koji Ävor ima viÅ¡e dostupnih resursa i dodeli novi pod njemu. Napomena: planer ne pokreÄ‡e nove podove, samo komunicira sa Kubelet procesom koji se izvrÅ¡ava unutar Ävora, koji Ä‡e pokrenuti novi pod.
* **Kube Controller menadÅ¾er**: Proverava resurse kao Å¡to su skupovi replika ili implementacije kako bi proverio da li, na primer, radi ispravan broj podova ili Ävorova. U sluÄaju da pod nedostaje, komuniciraÄ‡e sa planerom da pokrene novi. KontroliÅ¡e replikaciju, tokene i usluge naloga za API.
* **etcd**: SkladiÅ¡te podataka, trajno, dosledno i distribuirano. To je baza podataka Kubernetes-a i skladiÅ¡te kljuÄ-vrednost gde Äuva potpuno stanje klastera (svaka promena se beleÅ¾i ovde). Komponente poput Planera ili MenadÅ¾era kontrolora zavise od ovih podataka kako bi znale koje promene su se dogodile (dostupni resursi Ävorova, broj pokrenutih podova...).
* **MenadÅ¾er kontrolera u oblaku**: SpecifiÄan kontroler za kontrolu protoka i aplikacija, npr. ako imate klaster u AWS-u ili OpenStack-u.

Imajte na umu da moÅ¾e biti viÅ¡e Ävorova (koji pokreÄ‡u viÅ¡e podova), moÅ¾e biti i viÅ¡e glavnih procesa Äiji pristup Api serveru je ravnoteÅ¾en i njihov etcd je sinhronizovan.

**Volumeni**:

Kada pod kreira podatke koji ne smeju biti izgubljeni kada pod nestane, treba ih Äuvati na fiziÄkom volumenu. **Kubernetes omoguÄ‡ava povezivanje volumena sa podom kako bi se podaci saÄuvali**. Volumen moÅ¾e biti na lokalnom raÄunaru ili na **udaljenom skladiÅ¡tu**. Ako pokreÄ‡ete podove na razliÄitim fiziÄkim Ävorovima, trebali biste koristiti udaljeno skladiÅ¡te kako bi svi podovi mogli da mu pristupe.

**Druga konfiguracija**:

* **ConfigMap**: MoÅ¾ete konfigurisati **URL-ove** za pristup uslugama. Pod Ä‡e dobiti podatke odavde kako bi znao kako da komunicira sa ostalim uslugama (podovima). Imajte na umu da ovo nije preporuÄeno mesto za Äuvanje akreditiva!
* **Tajna**: Ovo je mesto za **Äuvanje tajnih podataka** poput lozinki, API kljuÄeva... kodiranih u B64 formatu. Pod Ä‡e moÄ‡i da pristupi ovim podacima kako bi koristio potrebne akreditive.
* **Implementacije**: Ovde se navode komponente koje Ä‡e pokretati Kubernetes. Korisnik obiÄno neÄ‡e direktno raditi sa podovima, podovi su apstrahovani u **ReplicaSet-ove** (broj istih replika podova), koji se pokreÄ‡u putem implementacija. Napomena: implementacije su za **bezstanovne** aplikacije. Minimalna konfiguracija za implementaciju je ime i slika koju treba pokrenuti.
* **StatefulSet**: Ova komponenta je namenjena posebno za aplikacije poput **baza podataka** koje moraju da **pristupe istom skladiÅ¡tu**.
* **Ingress**: Ovo je konfiguracija koja se koristi za **javno izlaganje aplikacije putem URL-a**. Imajte na umu da se to moÅ¾e uraditi i pomoÄ‡u spoljnih usluga, ali ovo je ispravan naÄin izlaganja aplikacije.
* Ako implementirate Ingress, moraÄ‡ete da kreirate **Ingress kontrolere**. In
### PKI infrastruktura - Sertifikacioni autoritet CA:

![](https://sickrov.github.io/media/Screenshot-66.jpg)

* CA je pouzdani koren za sve sertifikate unutar klastera.
* OmoguÄ‡ava komponentama da se meÄ‘usobno validiraju.
* Svi klaster sertifikati su potpisani od strane CA.
* ETCd ima svoj sopstveni sertifikat.
* Tipovi:
* Sertifikat apiservera.
* Sertifikat kubeleta.
* Sertifikat scheduler-a.

## Osnovne radnje

### Minikube

**Minikube** se moÅ¾e koristiti za izvoÄ‘enje **brzih testova** na Kubernetesu bez potrebe za implementacijom celokupnog Kubernetes okruÅ¾enja. PokrenuÄ‡e **master i node procese na jednom raÄunaru**. Minikube Ä‡e koristiti virtualbox za pokretanje node-a. Pogledajte [**ovde kako ga instalirati**](https://minikube.sigs.k8s.io/docs/start/).
```
$ minikube start
ğŸ˜„  minikube v1.19.0 on Ubuntu 20.04
âœ¨  Automatically selected the virtualbox driver. Other choices: none, ssh
ğŸ’¿  Downloading VM boot image ...
> minikube-v1.19.0.iso.sha256: 65 B / 65 B [-------------] 100.00% ? p/s 0s
> minikube-v1.19.0.iso: 244.49 MiB / 244.49 MiB  100.00% 1.78 MiB p/s 2m17.
ğŸ‘  Starting control plane node minikube in cluster minikube
ğŸ’¾  Downloading Kubernetes v1.20.2 preload ...
> preloaded-images-k8s-v10-v1...: 491.71 MiB / 491.71 MiB  100.00% 2.59 MiB
ğŸ”¥  Creating virtualbox VM (CPUs=2, Memory=3900MB, Disk=20000MB) ...
ğŸ³  Preparing Kubernetes v1.20.2 on Docker 20.10.4 ...
â–ª Generating certificates and keys ...
â–ª Booting up control plane ...
â–ª Configuring RBAC rules ...
ğŸ”  Verifying Kubernetes components...
â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
ğŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
ğŸ„  Done! kubectl is now configured to use "minikube" cluster and "default" namespace by defaul

$ minikube status
host: Running
kubelet: Running
apiserver: Running
kubeconfig: Configured

---- ONCE YOU HAVE A K8 SERVICE RUNNING WITH AN EXTERNAL SERVICE -----
$ minikube service mongo-express-service
(This will open your browser to access the service exposed port)

$ minikube delete
ğŸ”¥  Deleting "minikube" in virtualbox ...
ğŸ’€  Removed all traces of the "minikube" cluster
```
### Osnove Kubectl-a

**`Kubectl`** je alat za komandnu liniju za kubernetes klaster. Komunicira sa Api serverom glavnog procesa kako bi izvrÅ¡io radnje u kubernetesu ili zatraÅ¾io podatke.
```bash
kubectl version #Get client and server version
kubectl get pod
kubectl get services
kubectl get deployment
kubectl get replicaset
kubectl get secret
kubectl get all
kubectl get ingress
kubectl get endpoints

#kubectl create deployment <deployment-name> --image=<docker image>
kubectl create deployment nginx-deployment --image=nginx
#Access the configuration of the deployment and modify it
#kubectl edit deployment <deployment-name>
kubectl edit deployment nginx-deployment
#Get the logs of the pod for debbugging (the output of the docker container running)
#kubectl logs <replicaset-id/pod-id>
kubectl logs nginx-deployment-84cd76b964
#kubectl describe pod <pod-id>
kubectl describe pod mongo-depl-5fd6b7d4b4-kkt9q
#kubectl exec -it <pod-id> -- bash
kubectl exec -it mongo-depl-5fd6b7d4b4-kkt9q -- bash
#kubectl describe service <service-name>
kubectl describe service mongodb-service
#kubectl delete deployment <deployment-name>
kubectl delete deployment mongo-depl
#Deploy from config file
kubectl apply -f deployment.yml
```
### Minikube kontrolna tabla

Kontrolna tabla vam omoguÄ‡ava da lakÅ¡e vidite Å¡ta minikube radi, URL za pristup moÅ¾ete pronaÄ‡i u:
```
minikube dashboard --url


ğŸ”Œ  Enabling dashboard ...
â–ª Using image kubernetesui/dashboard:v2.3.1
â–ª Using image kubernetesui/metrics-scraper:v1.0.7
ğŸ¤”  Verifying dashboard health ...
ğŸš€  Launching proxy ...
ğŸ¤”  Verifying proxy health ...
http://127.0.0.1:50034/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/
```
### Primeri YAML konfiguracionih fajlova

Svaki konfiguracioni fajl ima 3 dela: **metadata**, **specifikacija** (Å¡ta treba da se pokrene), **status** (Å¾eljeno stanje).\
Unutar specifikacije konfiguracionog fajla za implementaciju, moÅ¾ete pronaÄ‡i Å¡ablon definisan novom konfiguracionom strukturom koja definiÅ¡e sliku koja Ä‡e se pokrenuti:

**Primer Deployment + Service deklarisani u istom konfiguracionom fajlu (sa** [**ovde**](https://gitlab.com/nanuchi/youtube-tutorial-series/-/blob/master/demo-kubernetes-components/mongo.yaml)**)**

PoÅ¡to je servis obiÄno povezan sa jednom implementacijom, moguÄ‡e je deklarisati oba u istom konfiguracionom fajlu (servis deklarisan u ovom konfigu je dostupan samo interno):
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
name: mongodb-deployment
labels:
app: mongodb
spec:
replicas: 1
selector:
matchLabels:
app: mongodb
template:
metadata:
labels:
app: mongodb
spec:
containers:
- name: mongodb
image: mongo
ports:
- containerPort: 27017
env:
- name: MONGO_INITDB_ROOT_USERNAME
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-username
- name: MONGO_INITDB_ROOT_PASSWORD
valueFrom:
secretKeyRef:
name: mongodb-secret
key: mongo-root-password
---
apiVersion: v1
kind: Service
metadata:
name: mongodb-service
spec:
selector:
app: mongodb
ports:
- protocol: TCP
port: 27017
targetPort: 27017
```
**Primer konfiguracije spoljnog servisa**

Ovaj servis Ä‡e biti dostupan spolja (proverite atribute `nodePort` i `type: LoadBalancer`):
```yaml
---
apiVersion: v1
kind: Service
metadata:
name: mongo-express-service
spec:
selector:
app: mongo-express
type: LoadBalancer
ports:
- protocol: TCP
port: 8081
targetPort: 8081
nodePort: 30000
```
{% hint style="info" %}
Ovo je korisno za testiranje, ali za produkciju trebate imati samo interne usluge i Ingress za izlaganje aplikacije.
{% endhint %}

**Primer konfiguracionog fajla za Ingress**

Ovo Ä‡e izloÅ¾iti aplikaciju na `http://dashboard.com`.
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
name: dashboard-ingress
namespace: kubernetes-dashboard
spec:
rules:
- host: dashboard.com
http:
paths:
- backend:
serviceName: kubernetes-dashboard
servicePort: 80
```
**Primer konfiguracionog fajla sa tajnama**

Primetite kako su lozinke kodirane u B64 (Å¡to nije bezbedno!)
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mongodb-secret
type: Opaque
data:
mongo-root-username: dXNlcm5hbWU=
mongo-root-password: cGFzc3dvcmQ=
```
**Primer ConfigMap-a**

**ConfigMap** je konfiguracija koja se daje podovima kako bi znali kako da pronaÄ‘u i pristupe drugim servisima. U ovom sluÄaju, svaki pod Ä‡e znati da je naziv `mongodb-service` adresa poda sa kojim mogu komunicirati (ovaj pod Ä‡e izvrÅ¡avati mongodb):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
name: mongodb-configmap
data:
database_url: mongodb-service
```
Zatim, unutar **konfiguracije implementacije** ova adresa moÅ¾e biti specificirana na sledeÄ‡i naÄin kako bi se uÄitala unutar okruÅ¾enja poda:
```yaml
[...]
spec:
[...]
template:
[...]
spec:
containers:
- name: mongo-express
image: mongo-express
ports:
- containerPort: 8081
env:
- name: ME_CONFIG_MONGODB_SERVER
valueFrom:
configMapKeyRef:
name: mongodb-configmap
key: database_url
[...]
```
**Primer konfiguracije zapisa**

RazliÄiti primeri konfiguracije skladiÅ¡ta u YAML formatu mogu se pronaÄ‡i na [https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes](https://gitlab.com/nanuchi/youtube-tutorial-series/-/tree/master/kubernetes-volumes).\
**Napomena: zapisi nisu unutar imenskih prostora**

### Imenski prostori

Kubernetes podrÅ¾ava **viÅ¡e virtuelnih klastera** podrÅ¾anih istim fiziÄkim klasterom. Ovi virtuelni klasteri nazivaju se **imenski prostori**. Namijenjeni su za upotrebu u okruÅ¾enjima sa mnogo korisnika rasporeÄ‘enih u viÅ¡e timova ili projekata. Za klaster sa nekoliko do desetina korisnika, ne biste trebali morati stvarati ili razmiÅ¡ljati o imenskim prostorima. Imenske prostore trebate koristiti samo kako biste imali bolju kontrolu i organizaciju svakog dijela aplikacije koja je implementirana u Kubernetes-u.

Imenski prostori pruÅ¾aju opseg za imena. Imena resursa moraju biti jedinstvena unutar imenskog prostora, ali ne i izmeÄ‘u imenskih prostora. Imenski prostori ne mogu biti ugnijeÅ¾Ä‘eni jedan u drugi i **svaki** Kubernetes **resurs** moÅ¾e biti samo **u** **jednom** **imenskom** **prostoru**.

Ako koristite minikube, podrazumijevano postoje 4 imenska prostora.
```
kubectl get namespace
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```
* **kube-system**: Nije namenjen korisnicima i ne treba ga dirati. Koristi se za procese mastera i kubectl.
* **kube-public**: Javno dostupni podaci. SadrÅ¾i configmap koji sadrÅ¾i informacije o klasteru.
* **kube-node-lease**: OdreÄ‘uje dostupnost Ävora.
* **default**: Imenik koji korisnik koristi za kreiranje resursa.
```bash
#Create namespace
kubectl create namespace my-namespace
```
{% hint style="info" %}
Imajte na umu da se veÄ‡ina Kubernetes resursa (npr. podovi, servisi, kontroleri replikacija i drugi) nalazi u nekim namespace-ima. MeÄ‘utim, drugi resursi poput namespace resursa i resursa niskog nivoa, kao Å¡to su Ävorovi i persistenVolume-ovi, nisu u namespace-u. Da biste videli koji Kubernetes resursi jesu i nisu u namespace-u:
```bash
kubectl api-resources --namespaced=true #In a namespace
kubectl api-resources --namespaced=false #Not in a namespace
```
{% endhint %}

MoÅ¾ete saÄuvati namespace za sve naredne kubectl komande u tom kontekstu.
```bash
kubectl config set-context --current --namespace=<insert-namespace-name-here>
```
### Helm

Helm je **upravljaÄ paketima** za Kubernetes. OmoguÄ‡ava pakovanje YAML datoteka i njihovu distribuciju u javnim i privatnim repozitorijumima. Ovi paketi se nazivaju **Helm Charts**.
```
helm search <keyword>
```
Helm je takoÄ‘e Å¡ablonski motor koji omoguÄ‡ava generisanje konfiguracionih fajlova sa promenljivama:

## Kubernetes tajne

**Tajna** je objekat koji **sadrÅ¾i osetljive podatke** kao Å¡to su lozinka, token ili kljuÄ. Takve informacije bi inaÄe bile smeÅ¡tene u specifikaciji Pod-a ili u slici. Korisnici mogu kreirati Tajne, a sistem takoÄ‘e kreira Tajne. Ime objekta Tajne mora biti validno **DNS poddomensko ime**. ProÄitajte ovde [zvaniÄnu dokumentaciju](https://kubernetes.io/docs/concepts/configuration/secret/).

Tajne mogu biti stvari kao Å¡to su:

* API, SSH kljuÄevi.
* OAuth tokeni.
* Kredencijali, lozinke (Äisti tekst ili b64 + enkripcija).
* Informacije ili komentari.
* Kod za povezivanje sa bazom podataka, stringovi... .

Postoje razliÄite vrste tajni u Kubernetes-u

| UgraÄ‘ena vrsta                      | Upotreba                                   |
| ----------------------------------- | ------------------------------------------ |
| **OpaÄ**                            | **proizvoljni podaci definisani od strane korisnika (podrazumevano)** |
| kubernetes.io/service-account-token | token za servisni nalog                     |
| kubernetes.io/dockercfg             | serijalizovani \~/.dockercfg fajl           |
| kubernetes.io/dockerconfigjson      | serijalizovani \~/.docker/config.json fajl  |
| kubernetes.io/basic-auth            | kredencijali za osnovnu autentifikaciju     |
| kubernetes.io/ssh-auth              | kredencijali za SSH autentifikaciju         |
| kubernetes.io/tls                   | podaci za TLS klijenta ili servera          |
| bootstrap.kubernetes.io/token       | podaci o poÄetnom token-u                   |

{% hint style="info" %}
**OpaÄ vrsta je podrazumevana, tipiÄan par kljuÄ-vrednost definisan od strane korisnika.**
{% endhint %}

**Kako tajne funkcioniÅ¡u:**

![](https://sickrov.github.io/media/Screenshot-164.jpg)

SledeÄ‡i konfiguracioni fajl definiÅ¡e **tajnu** nazvanu `mysecret` sa 2 parova kljuÄ-vrednost `username: YWRtaW4=` i `password: MWYyZDFlMmU2N2Rm`. TakoÄ‘e definiÅ¡e **pod** nazvan `secretpod` koji Ä‡e imati `username` i `password` definisane u `mysecret` izloÅ¾ene u **okruÅ¾enjskim promenljivama** `SECRET_USERNAME` \_\_ i \_\_ `SECRET_PASSWOR`. TakoÄ‘e Ä‡e **montirati** tajnu `username` unutar `mysecret` na putanju `/etc/foo/my-group/my-username` sa dozvolama `0640`.

{% code title="secretpod.yaml" %}
```yaml
apiVersion: v1
kind: Secret
metadata:
name: mysecret
type: Opaque
data:
username: YWRtaW4=
password: MWYyZDFlMmU2N2Rm
---
apiVersion: v1
kind: Pod
metadata:
name: secretpod
spec:
containers:
- name: secretpod
image: nginx
env:
- name: SECRET_USERNAME
valueFrom:
secretKeyRef:
name: mysecret
key: username
- name: SECRET_PASSWORD
valueFrom:
secretKeyRef:
name: mysecret
key: password
volumeMounts:
- name: foo
mountPath: "/etc/foo"
restartPolicy: Never
volumes:
- name: foo
secret:
secretName: mysecret
items:
- key: username
path: my-group/my-username
mode: 0640
```
{% endcode %}
```bash
kubectl apply -f <secretpod.yaml>
kubectl get pods #Wait until the pod secretpod is running
kubectl exec -it  secretpod -- bash
env | grep SECRET && cat /etc/foo/my-group/my-username && echo
```
### Tajne u etcd <a href="#otkrivanje-tajni-u-etcd" id="otkrivanje-tajni-u-etcd"></a>

**etcd** je dosledno i visoko dostupno skladiÅ¡te kljuÄ-vrednost koje se koristi kao podrÅ¡ka za Kubernetes za sve podatke klastera. Hajde da pristupimo tajnama koje su smeÅ¡tene u etcd-u:
```bash
cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
```
VideÄ‡ete da se sertifikati, kljuÄevi i URL-ovi nalaze u FS-u. Kada to dobijete, biÄ‡ete u moguÄ‡nosti da se poveÅ¾ete sa etcd-om.
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] health

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] health
```
Jednom kada uspostavite komunikaciju, biÄ‡ete u moguÄ‡nosti da dobijete tajne:
```bash
#ETCDCTL_API=3 etcdctl --cert <path to client.crt> --key <path to client.ket> --cacert <path to CA.cert> endpoint=[<ip:port>] get <path/to/secret>

ETCDCTL_API=3 etcdctl --cert /etc/kubernetes/pki/apiserver-etcd-client.crt --key /etc/kubernetes/pki/apiserver-etcd-client.key --cacert /etc/kubernetes/pki/etcd/etcd/ca.cert endpoint=[127.0.0.1:1234] get /registry/secrets/default/secret_02
```
**Dodavanje enkripcije na ETCD**

Podrazumevano, svi tajni podaci se Äuvaju u obiÄnom tekstu unutar etcd, osim ako ne primenite sloj enkripcije. SledeÄ‡i primer je zasnovan na [https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

{% code title="encryption.yaml" %}
```yaml
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
- resources:
- secrets
providers:
- aescbc:
keys:
- name: key1
secret: cjjPMcWpTPKhAdieVtd+KhG4NN+N6e3NmBPMXJvbfrY= #Any random key
- identity: {}
```
{% endcode %}

Nakon toga, trebate postaviti `--encryption-provider-config` zastavicu na `kube-apiserver` da bi pokazala na lokaciju kreiranog konfiguracionog fajla. MoÅ¾ete izmeniti `/etc/kubernetes/manifest/kube-apiserver.yaml` i dodati sledeÄ‡e linije:
```yaml
containers:
- command:
- kube-apiserver
- --encriyption-provider-config=/etc/kubernetes/etcd/<configFile.yaml>
```
Pomerite se nadole u volumeMounts:
```yaml
- mountPath: /etc/kubernetes/etcd
name: etcd
readOnly: true
```
Pomerite se nadole u volumeMounts do hostPath:
```yaml
- hostPath:
path: /etc/kubernetes/etcd
type: DirectoryOrCreate
name: etcd
```
**Provera da li su podaci Å¡ifrovani**

Podaci se Å¡ifruju prilikom upisa u etcd. Nakon restartovanja `kube-apiservera`, svaki novokreirani ili aÅ¾urirani tajni podatak trebao bi biti Å¡ifrovan prilikom skladiÅ¡tenja. Da biste to proverili, moÅ¾ete koristiti `etcdctl` komandnu liniju da biste dobili sadrÅ¾aj vaÅ¡eg tajnog podatka.

1. Kreirajte novi tajni podatak pod nazivom `secret1` u podrazumevanom (`default`) namespace-u:

```
kubectl create secret generic secret1 -n default --from-literal=mykey=mydata
```
2. KoristeÄ‡i etcdctl komandnu liniju, proÄitajte tajni podatak iz etcd:

`ETCDCTL_API=3 etcdctl get /registry/secrets/default/secret1 [...] | hexdump -C`

gde `[...]` moraju biti dodatni argumenti za povezivanje sa etcd serverom.
3. Proverite da li je saÄuvani tajni podatak prefiksan sa `k8s:enc:aescbc:v1:`, Å¡to ukazuje da je `aescbc` provajder Å¡ifrovao rezultirajuÄ‡e podatke.
4. Proverite da li je tajni podatak ispravno deÅ¡ifrovan prilikom dobijanja putem API-ja:

```
kubectl describe secret secret1 -n default
```

trebalo bi da se poklapa sa `mykey: bXlkYXRh`, mydata je kodiran, proverite [dekodiranje tajnog podatka](https://kubernetes.io/docs/concepts/configuration/secret#decoding-a-secret) da biste potpuno dekodirali tajni podatak.

**PoÅ¡to su tajni podaci Å¡ifrovani prilikom aÅ¾uriranja, izvrÅ¡avanje aÅ¾uriranja na tajnom podatku Ä‡e Å¡ifrovati taj sadrÅ¾aj:**
```
kubectl get secrets --all-namespaces -o json | kubectl replace -f -
```
**KonaÄni saveti:**

* PokuÅ¡ajte da ne Äuvate tajne u FS-u, preuzmite ih sa drugih mesta.
* Pogledajte [https://www.vaultproject.io/](https://www.vaultproject.io) za dodatnu zaÅ¡titu vaÅ¡ih tajni.
* [https://kubernetes.io/docs/concepts/configuration/secret/#risks](https://kubernetes.io/docs/concepts/configuration/secret/#risks)
* [https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm](https://docs.cyberark.com/Product-Doc/OnlineHelp/AAM-DAP/11.2/en/Content/Integrations/Kubernetes\_deployApplicationsConjur-k8s-Secrets.htm)

## Reference

{% embed url="https://sickrov.github.io/" %}

{% embed url="https://www.youtube.com/watch?v=X48VuDVv0do" %}

<details>

<summary><strong>NauÄite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naÄini da podrÅ¾ite HackTricks:

* Ako Å¾elite da vidite **vaÅ¡u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniÄni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), naÅ¡u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **PridruÅ¾ite se** ğŸ’¬ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili me **pratite** na **Twitter-u** ğŸ¦ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
